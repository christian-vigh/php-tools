<?php
	//!phpcmd(Administration, 1.0, production) : Manipulates log data on remote servers.
	/***************************************************************************************************

	    NAME
		rslogs.phs

	    DESCRIPTION
		Manipulates log data on remote servers.

	    AUTHOR
	     	Christian Vigh, 06/2015.

	    HISTORY
	    [Version : 1.0]	[Date : 2015/06/06]	[Author : CV]
	     	Initial version.

	    [Version : 1.0.1]	[Date : 2015/11/29]     [Author : CV]
		. Added the -list_configured_servers option.

	    [Version : 1.1]	[Date : 2016/01/13]     [Author : CV]
		. Removed the ResetLog*() methods and parameters, as well as the FindString() function and
		  the following parameters : -find_string, -limit, -sort_by, -where.
		. Added the following options : -query_domains_by_date, -query_urls_by_date, -query_ip_count,
		  -query_ips, -query_urls 
		. Added topics in the help definition.

	    [Version : 1.1.1]	[Date : 2016/01/22]	[Author : CV]
		. Added the -trace_ip option.
		. Changed all the options of type "query" to take into account the servers specified on the
		  command line.

	 ***************************************************************************************************/
	require ( "tools.phpinclude" ) ;

	use  Thrak\Processors\CL\CLParser ;
	use  Thrak\Processors\CL\CLException ;
	use  Thrak\Types\String ;
	use  Thrak\IO\Console ;
	use  Thrak\IO\Path ;
	use  Thrak\IO\AsciiReport ;
	use  Thrak\Processors\IniFile ;
	use  Thrak\Processors\WhoisInformation ;
	use  Thrak\Database\Tables\ResolvedDomains ;
	use  Thrak\Database\Tables\StringStore ;
	use  Thrak\Reflection\ReflectionClass ;


	require ( "RsAdmin.phpclass" ) ;


	/*==================================================================================================

		Command line parameters.

	  ==================================================================================================*/
	$Definitions = <<<END
<command name="rslogs" allow-files="false">

	<usage>
		Manipulates log data on remote servers.
	</usage>

	<topic name="check, integrity">
		Integrity checking parameters.
	</topic>

	<topic name="config, configuraation">
		Configuration-related parameters.
	</topic>

	<topic name="update">
		Options related to local database update.
	</topic>

	<topic name="list">
		Statistics about local database.
	</topic>

	<topic name="query">
		Local database query options.
	</topic>

	
	<flag name="check_extracted_data, ced" topic="check">
		Checks that extracted (and analyzed) data is in sync with log entries.
	</flag>

	<file name="configuration_file, cf" disposition="existing" default="thraktools://Data/rsadmin.ini" topic="config">
		Hosted servers parameters file.
	</file>
	
	<flag name="extract, e" topic="update">
		Extracts data from the captured log entries, having the type specified by the -log_type parameter.
	</flag>
	
	<flag name="list_configured_servers, lcs" topic="list">
		Lists the servers configured for this command.
	</flag>
	
	<flag name="list_log_entry_statistics, lles" topic="list">
		Lists log entry statistics by occurrences.
	</flag>

	<flag name="list_string_store_statistics, lsss, ls" topic="list">
		Lists statistics about string store tables.
	</flag>

	<flag name="list_table_information, lti" topic="list">
		Lists table information.
	</flag>

	<keyword name="log_type, logtype, lt" default="all" topic="update">
		Specifies the type of logs to be processed.
		
		<case name="all" value="-1">
			Inspects all logs.
		</case>

		<case name="auth, a" constant="RsAdmin::LOGTYPE_AUTH">
			Authentication logs.
		</case>
		
		<case name="http, h" constant="RsAdmin::LOGTYPE_HTTP">
			Http access logs.
		</case>
		
		<case name="http_errors, http_error, httperr, he, error, err, e"  constant="RsAdmin::LOGTYPE_HTTP_ERROR">
			Http error logs.
		</case>
		
		<case name="http_errors_404, http_error_404, httperr404, he404, error404, err404, e404, e4"  constant="RsAdmin::LOGTYPE_HTTP_ERROR_404">
			Http special error 404 logs.
		</case>
			
		<case name="mail, m" constant="RsAdmin::LOGTYPE_MAIL">
			Mail logs.
		</case>
		
		<case name="ssh, s" constant="RsAdmin::LOGTYPE_SSH">
			SSH access logs.
		</case>		
	</keyword>
	
	<flag name="optimize_tables, ot" topic="update">
		Optimizes all the tables related to log entries.
	</flag>

	<datetime name="query_domains_by_date, qdd" arguments="1..2" default="today" help-text="date/date range" topic="query">
		Displays accesses performed during the specified date or range of dates.
	</datetime>

	<datetime name="query_urls_by_date, qud" arguments="1..2" default="today" help-text="date/date range" topic="query">
		Displays accesses performed during the specified date or range of dates.
		Same as -query_domains_by_date, except that it displays an url (if available) instead of a domain name.
	</datetime>

	<datetime name="query_ip_count, qic" arguments="1..2" default="today" help-text="date/date range" topic="query">
		Display access count per ip for the specified date range.
	</datetime>

	<ip-address name="query_ips, query_ip, qi" arguments="1..*" topic="query">
		Displays accesses performed by the specified ip(s) together with their domain name.
	</ip-address>
	
	<ip-address name="query_urls, query_url, qu" arguments="1..*" topic="query">
		Displays accesses performed by the specified ip(s).
		Same as -query_ips, except that it displays an url (if available) instead of a domain name.
	</ip-address>
	
	<flag name="resolve_ips, resolve_ip, ri" topic="update">
		Resolves ip addresses to domain names (for unresolved ip addresses), including whois data for both the
		ip (if any) and its hoster.
	</flag>
	
	<file name="rslogs_configuration_file, rcf" disposition="existing" default="thraktools://Data/rslogs.ini" topic="config">
		Rslogs parameters file.
	</file>
	
	<string name="servers, server, s" default="*" arguments="0..*" topic="config">
		Server name(s) on which http logs are to be retrieved.
		Wildcard characters are authorized, and search is performed on every server alias.
	</string>

	<flag name="sync" topic="update">
		Equivalent to : -update -extract -resolve_ips.
	</flag>

	<ip-address name="trace_ip, ti" topic="query">
		Traces the various accesses from the specified ip address. Similar to the -query_ip option, but
		displays the whole log message.
	</ip-address>
	
	<flag name="update, u" topic="update">
		Updates the logs from the remote servers, having the type specified by the -log_type parameter.
	</flag>
</command>
END;

	

	/*==============================================================================================================
	
		Support functions.
  
	  ==============================================================================================================*/

	// get_date_range -
	//	Tries to normalize a date range if the time part was omitted.
	function  get_date_range ( $cmddates )
	   {
		$dates		=  [ $cmddates [0] [ 'datetime' ] ] ;

		if  ( count ( $cmddates )  ==  1 )
			$dates []	=  $cmddates [0] [ 'date' ] . ' 23:59:59' ;
		else if  ( $dates [1] [ 'time' ]  ==  '00:00:00' )
			$dates []	=  $cmddates [1] [ 'date' ] . ' 23:59:59' ;

		return ( $dates ) ;
	    }


	// get_logtype_name -
	//	Returns a logfile type name corresponding to the specified constant.
	function  get_logtype_name ( $value )
	   {
		switch  ( $value )
		   {
			case  RsAdmin::LOGTYPE_AUTH		:  return ( 'auth' ) ;
			case  RsAdmin::LOGTYPE_HTTP		:  return ( 'http' ) ;
			case  RsAdmin::LOGTYPE_HTTP_ERROR	:  return ( 'http error' ) ;
			case  RsAdmin::LOGTYPE_HTTP_ERROR_404	:  return ( 'http err404' ) ;
			case  RsAdmin::LOGTYPE_MAIL		:  return ( 'mail' ) ;
			case  RsAdmin::LOGTYPE_SSH		:  return ( 'ssh' ) ;
			default					:  return ( 'UNKNOWN' ) ;
		    }
	    }


	// get_server_ids -
	//	Retrieves the ids of the specified servers in the servers table.
	function  get_server_ids  ( $servers )
	   {
		global		$Database ;

		if  ( ! is_array ( $servers ) ) 
			$servers	=  [ $servers ] ;

		$names		=  [] ;

		foreach  ( $servers  as  $server )
			$names []	=  "'" . $server . "'" ;

		$query		=  "SELECT ser_id FROM servers WHERE ser_name IN ( " . implode ( ', ', $names ) . " )" ;
		$Database -> SetQuery ( $query ) ;
		$ids		=  $Database -> LoadValues ( ) ;

		$id_count	=  count ( $ids ) ;
		$server_count	=  count ( $servers ) ;

		if  ( $id_count  !=  $server_count )
			error ( "Could not find all the specified servers" ) ;

		return ( $ids ) ;
	    }


	/*==================================================================================================

		Data checking functions.

	  ==================================================================================================*/

	// CheckExtractedData -
	//	Performs the following checks :
	//	- Every server_logfile_entries row which has the serle_processed flag set to 1 MUST have at least
	//	  one row in the server_logfile_data table. If not, the serle_processed flag will be reset for
	//	  the corresponding entries.
	//	- Every server_logfile_entries row which has the serle_processed flag set to 0 MUST NOT have any
	//	  row in the server_logfile_data table. If rows are present in the server_logfile_data table, they
	//	  will be deleted.
	//	- Every row in the server_logfile_data table MUST have a parent in the server_logfile_entries table
	function  CheckExtractedData ( )
	   {
		global		$RsAdmin ;


		$db			=  $RsAdmin -> Database ;
		$log_entries_table	=  RsAdmin::TABLE_SERVER_LOGFILE_ENTRIES ;
		$log_data_table		=  RsAdmin::TABLE_SERVER_LOGFILE_DATA ;

		// server_logfile_entries rows having serle_processed = 1 must have at least one row in server_logfile_data
		echo ( 'Checking for log entries marked as processed without any corresponding extracted data... ' ) ;
		$query		=  "
					SELECT  serle_id
					FROM $log_entries_table
					WHERE
						serle_processed = 1 AND
						NOT EXISTS 
						   (
							SELECT serld_id
							FROM $log_data_table
							WHERE 
								serld_parent_id = serle_id
 						    ) 
				   " ;

		$db -> SetSimpleQuery ( $query ) ;

		$ids		=  $db -> LoadValues ( ) ;
		
		if  ( $ids ) 
		   {
			$id_list	=  implode ( ',', $ids ) ;
			$id_count	=  count ( $ids ) ;
			$query		=  "
						UPDATE $log_entries_table
						SET
							serle_processed = 0,
							serle_entry_type = 0 
						WHERE
							serle_id IN ( $id_list )
					   " ;
			$db -> Execute ( $query ) ;
			$affected_rows	=  $db -> GetAffectedRows ( ) ;

			output ( "$id_count/$affected_rows rows processed" ) ;
		    }
		else
			output ( "ok" ) ;

		// server_logfile_entries rows having serle_processed = 0 must not any row in server_logfile_data
		echo ( 'Checking for log entries not marked as processed but having corresponding extracted data... ' ) ;
		$query		=  "
					SELECT  serle_id
					FROM $log_entries_table
					WHERE
						serle_processed = 0 AND
						EXISTS 
						   (
							SELECT serld_id
							FROM $log_data_table
							WHERE 
								serld_parent_id = serle_id
 						    ) 
				   " ;

		$db -> SetSimpleQuery ( $query ) ;

		$ids		=  $db -> LoadValues ( ) ;
		
		if  ( $ids ) 
		   {
			$id_list	=  implode ( ',', $ids ) ;
			$id_count	=  count ( $ids ) ;
			$query		=  "
						DELETE FROM $log_data_table
						WHERE
							serld_parent_id IN ( $id_list )
					   " ;
			$db -> Execute ( $query ) ;
			$affected_rows	=  $db -> GetAffectedRows ( ) ;

			output ( "$id_count entry/$affected_rows data rows processed" ) ;
		    }
		else
			output ( "ok" ) ;

		// Every row in the server_logfile_data table MUST have a parent in the server_logfile_entries table
		echo ( 'Checking for orphan rows in extracted log data... ' ) ;
		$query		=  "
					SELECT  serld_id
					FROM $log_data_table
					WHERE
						NOT EXISTS 
						   (
							SELECT serle_id
							FROM $log_entries_table
							WHERE 
								serld_parent_id = serle_id
 						    ) 
				   " ;

		$db -> SetSimpleQuery ( $query ) ;

		$ids		=  $db -> LoadValues ( ) ;
		
		if  ( $ids ) 
		   {
			$id_list	=  implode ( ',', $ids ) ;
			$id_count	=  count ( $ids ) ;
			$query		=  "
						DELETE FROM $log_data_table
						WHERE
							serld_id IN ( $id_list )
					   " ;
			$db -> Execute ( $query ) ;
			$affected_rows	=  $db -> GetAffectedRows ( ) ;

			output ( "$id_count/$affected_rows data rows processed" ) ;
		    }
		else
			output ( "ok" ) ;

	    }



	/*==================================================================================================

		Data list functions.

	  ==================================================================================================*/

	// ListLogEntryStatistics -
	//	Lists statistics about log entry types.
	function  ListLogEntryStatistics ( )
	   {
		global		$Database ;

		$query			=  "
						SELECT 
							serle_logfile_type AS 'type', 
							COUNT(*) AS 'count'
						FROM " . RsAdmin::TABLE_SERVER_LOGFILE_ENTRIES . "
						GROUP BY serle_logfile_type
						ORDER BY serle_logfile_type				   
					    " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows			=  $Database -> LoadRows ( ) ;
		$report			=  new AsciiReport 
		   (
			[ 'member' => 'type'		, 'title' => 'Type'					],
			[ 'member' => 'count'		, 'title' => 'Count'		, 'align' => 'right'	],
			[ 'member' => 'unprocessed'	, 'title' => 'Unprocessed'	, 'align' => 'right'	]
		    ) ;
		$data			=  [] ;
		$total			=  0 ;
		$total_unprocessed	=  0 ;

		foreach  ( $rows  as  $row )
		   {
			switch  ( $row [ 'type' ] )
			   {
				case  RsAdmin::LOGTYPE_HTTP			:  $type = 'Http access'	; break ;
				case  RsAdmin::LOGTYPE_MAIL			:  $type = 'Mail'		; break ;
				case  RsAdmin::LOGTYPE_AUTH			:  $type = 'Auth'		; break ;
				case  RsAdmin::LOGTYPE_HTTP_ERROR		:  $type = 'Http Error'		; break ;
				case  RsAdmin::LOGTYPE_HTTP_ERROR_404		:  $type = 'Http error 404'	; break ;
				case  RsAdmin::LOGTYPE_SSH			:  $type = 'Ssh'		; break ;
				default						:  $type = '*** unknown ***'	; break ;
			    }

			$data_row	=  [ 'type' => $type, 'count' => number_format ( $row [ 'count' ], 0, '.', ' ' ) ] ;
			$query		=  "
						SELECT 
							COUNT(*) AS 'count'
						FROM " . RsAdmin::TABLE_SERVER_LOGFILE_ENTRIES . "
						WHERE
							serle_logfile_type = {$row [ 'type' ]} AND
							serle_processed = 0
					    " ;
			$Database -> SetSimpleQuery ( $query ) ;
			$unprocessed	=  $Database -> LoadValue ( ) ;
			$data_row [ 'unprocessed' ]	=  number_format ( $unprocessed, 0, '.', ' ' ) ;
			$data []			=  $data_row ;

			$total			+=  $row [ 'count' ] ;
			$total_unprocessed	+=  $unprocessed ;
		    }

		output ( "Logfile entries per type :" ) ;
		$data []		=  '!=' ;
		$data []		=  
		   [
			'type'		=>  'TOTAL :',
			'count'		=>  number_format ( $total, 0, '.', ' ' ),
			'unprocessed'	=>  number_format ( $total_unprocessed, 0, '.', ' ' )
		    ] ;

		echo $report -> Generate ( $data ) ;
	    }


	// ListStringStoreStatistics -
	//	Lists statistics about string store tables.
	function  ListStringStoreStatistics ( )
	   {
		global		$Database, $StringStoreTables ;


		$index	=  0 ;

		foreach  ( $StringStoreTables  as  $string_store => $types )
		   {
			$table		=  $string_store ;
			$constants	=  $types ;

			$Database -> SetSimpleQuery ( "SELECT COUNT(*) FROM $table" ) ;
			$count		=  $Database -> LoadValue ( ) ;

			if  ( $index )
				output ( '' ) ;

			if  ( $count )
			   {
				$report		=  new  AsciiReport 
				   (
					[ 'member' => 'item' , 'title' => 'Statistic' ],
					[ 'member' => 'value', 'title' => 'Value', 'align' => 'right' ]
				    ) ;

				// Total number of rows
				$data		=  [] ;
				$data []	=  [ 'item' => 'Total rows', 'value' => number_format ( $count, 0, '.', ' ' ) ] ;

				// Number of rows per defined type
				$Database -> SetSimpleQuery
				   ("
					SELECT type, COUNT(*) AS count
					FROM $table
					GROUP BY type
					ORDER BY type
				    ") ;
				$rows		=  $Database -> LoadRows ( ) ;
				$types		=  [ 'Row count by type :' ] ;
				$counts		=  [ '' ] ;

				foreach  ( $rows  as  $row )
				   {
					if  ( isset ( $constants [ $row [ 'type' ] ] ) )
					   {
						$types []	=  '   - ' . $constants [ $row [ 'type' ] ] [ 'label' ] . ' (' . $row [ 'type' ] . ')' ;
						$counts []	=  number_format ( $row [ 'count' ], 0, '.', ' ' ) ;
					    }
					else
					   {
						$types []	=  '   - Other rows (' . $row [ 'type' ] . ')' ;
						$counts []	=  number_format ( $row [ 'count' ], 0, '.', ' ' ) ;
					    }
				    }

				$item		=  implode ( "\n", $types ) ;
				$count		=  implode ( "\n", $counts ) ;
				$data []	=  [ 'item' => $item, 'value' => $count ] ;

				// Min and max lengths
				$Database -> SetSimpleQuery ( "SELECT MIN( LENGTH( value ) ) FROM $table" ) ;
				$count1	=  $Database -> LoadValue ( ) ;

				$Database -> SetSimpleQuery ( "SELECT MAX( LENGTH( value ) ) FROM $table" ) ;
				$count2	=  $Database -> LoadValue ( ) ;

				$data []	=  
				   [ 
					'item'	=> "Min row length\nMax row length",
					'value' => number_format ( $count1, 0, '.', ' ' ) . "\n" . number_format ( $count2, 0, '.', ' ' )
				    ] ;

				// Try to find duplicate checksums (collisions)
				$Database -> SetSimpleQuery
				   ("
					SELECT type, checksum, COUNT(*) AS count
					FROM $table
					GROUP BY type, checksum
					HAVING COUNT(*)  >  1
					ORDER BY type, checksum
				    ") ;
				$rows	=  $Database -> LoadRows ( ) ;

				if  ( $rows )
				   {
					$items		=  [ 'Checksum collisions :' ] ;
					$values		=  [ 'Count :' ] ;

					foreach ( $rows  as  $row )
					   {
						$items []	=  '   - Type = ' . $row [ 'type' ] . ', checksum = ' . $row [ 'checksum' ] ;
						$values []	=  number_format ( $row [ 'count' ], 0, '.', ' ' ) ;

						$item		=  implode ( "\n", $items ) ;
						$value		=  implode ( "\n", $values ) ;
					    }

					$item		=  implode ( "\n", $items ) ;
					$count		=  implode ( "\n", $values ) ;
					$data []	=  [ 'item' => $item, 'value' => $count ] ;
				    }
				else
					$data []	=  [ 'item' => 'Checksum collisions :', 'value' => 'none' ] ;

				// Try to find duplicate values (case-insensitive search, thus the use of the HEX() function in the GROUP BY clause)
				$Database -> SetSimpleQuery
				   ("
					SELECT value, COUNT(value) AS count
					FROM $table
					GROUP BY type, HEX(value)
					HAVING COUNT(value)  >  1
					ORDER BY type, value
				    ") ;
				$rows	=  $Database -> LoadRows ( ) ;

				if  ( $rows )
				   {
					$items		=  [ 'Duplicate value count :' ] ;
					$values		=  [ 'Row ids :' ] ;

					// Loop through each row and retrieve every row id having the found value
					foreach ( $rows  as  $row )
					   {
						$escaped_value	=  $Database -> Escape ( $row [ 'value' ] ) ;
						$count		=  $row [ 'count' ] ;
						$ids		=  [] ;

						$Database -> SetSimpleQuery
						   ("
							SELECT id 
							FROM $table
							WHERE
								value = '$escaped_value' ;
						    ") ;
						$id_rows	=  $Database -> LoadRows ( ) ;

						foreach  ( $id_rows  as  $id_row )
							$ids []		=  $id_row [ 'id' ] ;

						$items []	=  $row [ 'count' ] ;
						$values []	=  implode ( ', ', $ids ) ;
					    }

					$item		=  implode ( "\n", $items ) ;
					$value		=  implode ( "\n", $values ) ;
					$data []	=  [ 'item' => $item, 'value' => $value ] ;
				    }
				else
					$data []	=  [ 'item' => 'Duplicate values :', 'value' => 'none' ] ;

				// Generate the report
				output ( "Statistics for string store $table :" ) ;
				echo $report -> Generate ( $data ) ;
			    }
			else
				warning ( "String store $table is empty" ) ;

			$index ++ ;
		    }
	    }


	// ListTableInformation -
	//	Lists information about server tables related to logs.
	function  ListTableInformation ( )
	   {
		global		$RsAdmin ;

		$db		=  $RsAdmin -> Database ;
		$report		=  new  AsciiReport 
		   (
			[ 'member' => 'table'		, 'title' => 'Table'							],
			[ 'member' => 'engine'		, 'title' => 'Engine'							],
			[ 'member' => 'format'		, 'title' => 'Row format'						],
			[ 'member' => 'rows'		, 'title' => 'Rows'		, 'align' => 'right'			],
			[ 'member' => 'data_size'	, 'title' => 'Data size'	, 'align' => 'right'			],
			[ 'member' => 'index_size'	, 'title' => 'Index size'	, 'align' => 'right'			],
			[ 'member' => 'comment'		, 'title' => 'Comment'		, 'width' => 60, 'overflow' => 'wrap'	]
		    ) ;
		$db -> SetSimpleQuery ( "SHOW TABLE STATUS" ) ;
		$rows			=  $db -> LoadRows ( ) ;
		$data			=  [] ;
		$total_rows		=  0 ;
		$total_data_length	=  0 ;
		$total_index_length	=  0 ;

		foreach  ( $rows  as  $row )
		   {
			$total_rows		+=  $row [ 'Rows' ] ;
			$total_data_length	+=  $row [ 'Data_length' ] ;
			$total_index_length	+=  $row [ 'Index_length' ] ;

			$data_row	=
			   [
				'table'		=>  $row [ 'Name' ],
				'engine'	=>  $row [ 'Engine' ],
				'format'	=>  $row [ 'Row_format' ],
				'rows'		=>  number_format ( $row [ 'Rows' ], 0, '.', ' ' ),
				'data_size'	=>  number_format ( $row [ 'Data_length' ], 0, '.', ' ' ),
				'index_size'	=>  number_format ( $row [ 'Index_length' ], 0, '.', ' ' ),
				'comment'	=>  $row [ 'Comment' ]
			    ] ;

			$data []	=  $data_row ;
		    }

		$data []		=  '!=' ;
		$data []		=
		   [
			'!'		=>  true,
			'table'		=>  'Total:',
			'engine'	=>  '',
			'format'	=>  '',
			'rows'		=>  number_format ( $total_rows, 0, '.', ' ' ),
			'data_size'	=>  number_format ( $total_data_length, 0, '.', ' ' ),
			'index_size'	=>  number_format ( $total_index_length, 0, '.', ' ' ),
			'comment'	=>  ''
		    ] ;

		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'table' ) ;
	    }


	/*==================================================================================================

	    LoadConfigurationParameters -
		Loads parameters defined in the rslogs.ini configuration file.

	  ==================================================================================================*/
	function  LoadConfigurationParameters ( )
	   {
		global		$RsLogs,
				$CleanIps, $CleanMessages, $CleanSshConnections,
				$IpsToClean, $MessagesToClean ;

		
		// [Settings] section, CleanIps/CleanMessages/CleanSshConnections key :
		//	If true, the Ips listed in the Ips key of the [Cleaning Options] section will be processed,
		//	when the -clean_tables option is specified.
		//	The same principle applies to the CleanMessages key with Messages.
		//	CleanSshConnections does not have a counterpart in the [Cleaning Options] section. It cleans
		//	the log entries that are marked as a private SSH connection (logfile type = 
		$CleanIps		=  String::BooleanValue ( $RsLogs -> GetKey ( 'Settings', 'CleanIps', 'true' ) ) ;
		$CleanMessages		=  String::BooleanValue ( $RsLogs -> GetKey ( 'Settings', 'CleanMessages', 'true' ) ) ;
		$CleanSshConnections	=  String::BooleanValue ( $RsLogs -> GetKey ( 'Settings', 'CleanSshConnections', 'true' ) ) ;
			
		// [Cleaning options] settings
		$ips			=  $RsLogs -> GetKey ( 'Cleaning Options', 'Ips' ) ;

		if  ( $ips )
		   {
			$ips			=  str_replace ( '/\s+/', ' ', trim ( $ips ) ) ;
			$IpsToClean		=  explode ( ' ', $ips ) ;
		    }

		$messages		=  $RsLogs -> GetKey ( 'Cleaning Options', 'Messages' ) ;

		if  ( $messages )
		   {
			$messages		=  explode ( "\n", trim ( $messages ) ) ;

			foreach ( $messages  as  $message )
				$MessagesToClean []	=  trim ( $message ) ;
		    }
	    }


	/*==================================================================================================

		Queries.

	  ==================================================================================================*/
	
	// QueryDomainsByDate -
	//	Queries the logs for the specified date range.
	function  QueryDomainsByDate ( $dates )
	   {
		global		$Database, $ServerList ;

		$ip_store_type	=  LogStringStore::LOGSTORE_IP ;
		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;
		$query		=  "
					SELECT
						server_logfile_entries. serle_date 	AS 'date',
						servers. ser_name 			AS 'server',
						server_domains. serd_domain 		AS 'domain',
						server_logfiles. serl_path 		AS 'logfile',
						server_string_store. value 		AS 'ip',
						IF( server_resolved_ips. serri_domain_id = 0, 
							computer_string_store. value,
							domain_string_store. value ) AS 'ipdomain'
					FROM server_logfile_data
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_string_store ON
						server_string_store. id = server_logfile_data. serld_string_store_id
					LEFT JOIN server_resolved_ips ON
						server_resolved_ips. serri_ip_id = server_string_store. id
					LEFT JOIN server_string_store AS domain_string_store ON
						domain_string_store. id = server_resolved_ips. serri_domain_id
					LEFT JOIN server_string_store AS computer_string_store ON
						computer_string_store. id = server_resolved_ips. serri_computer_name_id
					WHERE
						servers. ser_id IN ( $server_ids ) AND
						server_logfile_entries. serle_date BETWEEN '{$dates [0]}' AND '{$dates [1]}' AND
						server_logfile_data. serld_string_store_id IN
						   (
							SELECT id
							FROM server_string_store
							WHERE
								type = $ip_store_type
						    ) AND
						server_logfile_data. serld_logfile_type <> 5 AND
						server_logfile_data. serld_string_store_id NOT IN
						   (
							SELECT DISTINCT serld_string_store_id
							FROM server_logfile_data 
							LEFT JOIN server_logfile_entries ON
								server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
							WHERE
								serld_logfile_type = 5 AND
		                                                server_logfile_entries. serle_date BETWEEN '{$dates [0]}' AND '{$dates [1]}'
						    )
					ORDER BY 
						server_logfile_entries. serle_date,
						servers. ser_name,
						server_domains. serd_domain,
						server_string_store. value
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$date		=  $row [ 'date' ] ;
			$domain		=  $row [ 'domain' ] ;

			if  ( strncmp ( $row [ 'logfile' ], '/server/www/', 12 ) )
				$logfile	=  $row [ 'logfile' ] ;
			else
				$logfile	=  substr ( $row [ 'logfile' ], 12 ) ;

			$ip		=  $row [ 'ip' ] ;
			$ipdomain	=  $row [ 'ipdomain' ] ;

			$data []	=
			   [
				'date'		=>  $date,
				'domain'	=>  $domain,
				'logfile'	=>  $logfile,
				'ip'		=>  $ip,
				'ipdomain'	=>  $ipdomain
			    ] ;
		    }

		$report		=  new AsciiReport 
		   (
			[ 'member' => 'date'	, 'title' => 'Date'		],
			[ 'member' => 'domain'	, 'title' => 'Domain'		],
			[ 'member' => 'logfile'	, 'title' => 'Log file'		],
			[ 'member' => 'ip'	, 'title' => 'Ip'		],
			[ 'member' => 'ipdomain', 'title' => 'Ip domain'	]
		    ) ;

		$report -> Generate ( $data, true ) ;
		echo $report -> Summary ( 'ip entry' ) ;
	    }
	

	// QueryIps -
	//	Queries the logs for the specified ips.
	function  QueryIps ( $ips )
	   {
		global		$Database, $ServerList ;

		$ip_list	=  [] ;

		foreach  ( $ips  as  $ip )
			$ip_list []	=  "'" . $ip [ 'ip-address' ] . "'" ;

		$ip_string	=  implode ( ', ', $ip_list ) ;
		$ip_store_type	=  LogStringStore::LOGSTORE_IP ;
		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;

		$query		=  "
					SELECT
						server_logfile_entries. serle_date 	AS 'date',
						servers. ser_name 			AS 'server',
						server_domains. serd_domain 		AS 'domain',
						server_logfiles. serl_path 		AS 'logfile',
						server_string_store. value 		AS 'ip',
						IF( server_resolved_ips. serri_domain_id = 0, 
							computer_string_store. value,
							domain_string_store. value ) AS 'ipdomain'
					FROM server_logfile_data
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_string_store ON
						server_string_store. id = server_logfile_data. serld_string_store_id
					LEFT JOIN server_resolved_ips ON
						server_resolved_ips. serri_ip_id = server_string_store. id
					LEFT JOIN server_string_store AS domain_string_store ON
						domain_string_store. id = server_resolved_ips. serri_domain_id
					LEFT JOIN server_string_store AS computer_string_store ON
						computer_string_store. id = server_resolved_ips. serri_computer_name_id
					WHERE
						servers. ser_id IN ( $server_ids ) AND
						server_logfile_data. serld_string_store_id IN
						   (
							SELECT id
							FROM server_string_store
							WHERE
								type = $ip_store_type AND
								value IN ( $ip_string )
						    ) 
					ORDER BY 
						server_logfile_entries. serle_date,
						servers. ser_name,
						server_domains. serd_domain,
						server_string_store. value
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$date		=  $row [ 'date' ] ;
			$domain		=  $row [ 'domain' ] ;

			if  ( strncmp ( $row [ 'logfile' ], '/server/www/', 12 ) )
				$logfile	=  $row [ 'logfile' ] ;
			else
				$logfile	=  substr ( $row [ 'logfile' ], 12 ) ;

			$ip		=  $row [ 'ip' ] ;
			$ipdomain	=  $row [ 'ipdomain' ] ;

			$data []	=
			   [
				'date'		=>  $date,
				'domain'	=>  $domain,
				'logfile'	=>  $logfile,
				'ip'		=>  $ip,
				'ipdomain'	=>  $ipdomain
			    ] ;
		    }

		$report		=  new AsciiReport 
		   (
			[ 'member' => 'date'	, 'title' => 'Date'		],
			[ 'member' => 'domain'	, 'title' => 'Domain'		],
			[ 'member' => 'logfile'	, 'title' => 'Log file'		],
			[ 'member' => 'ip'	, 'title' => 'Ip'		],
			[ 'member' => 'ipdomain', 'title' => 'Ip domain'	]
		    ) ;

		$report -> Generate ( $data, true ) ;
		echo $report -> Summary ( 'ip entry' ) ;
	    }
	

	// QueryUrls -
	//	Same as QueryIps, but display an url instead of a domain name.
	function  QueryUrls ( $ips )
	   {
		global		$Database, $ServerList ;

		$ip_list	=  [] ;

		foreach  ( $ips  as  $ip )
			$ip_list []	=  "'" . $ip [ 'ip-address' ] . "'" ;

		$ip_string	=  implode ( ', ', $ip_list ) ;
		$ip_store_type	=  LogStringStore::LOGSTORE_IP ;
		$url_store_type	=  LogStringStore::LOGSTORE_HTTP_REQUEST_URL ;
		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;

		$query		=  "
					SELECT
						server_logfile_entries. serle_date 	AS 'date',
						servers. ser_name 			AS 'server',
						server_domains. serd_domain 		AS 'domain',
						server_logfiles. serl_path 		AS 'logfile',
						server_string_store. value 		AS 'ip',
						url_string_store. value 		AS 'url'
					FROM server_logfile_data
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_string_store ON
						server_string_store. id = server_logfile_data. serld_string_store_id
					LEFT JOIN server_logfile_data AS server_logfile_url_data ON
						server_logfile_url_data. serld_parent_id = server_logfile_data. serld_parent_id AND
						server_logfile_url_data. serld_data_type = $url_store_type
					LEFT JOIN server_string_store AS url_string_store ON
						server_logfile_url_data. serld_string_store_id = url_string_store. id
					WHERE
						servers. ser_id IN ( $server_ids ) AND
						server_logfile_data. serld_string_store_id IN
						   (
							SELECT id
							FROM server_string_store
							WHERE
								type = $ip_store_type AND
								value IN ( $ip_string )
						    )
					ORDER BY 
						server_logfile_entries. serle_date,
						servers. ser_name,
						server_domains. serd_domain,
						server_string_store. value
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$date		=  $row [ 'date' ] ;
			$domain		=  $row [ 'domain' ] ;

			if  ( strncmp ( $row [ 'logfile' ], '/server/www/', 12 ) )
				$logfile	=  $row [ 'logfile' ] ;
			else
				$logfile	=  substr ( $row [ 'logfile' ], 12 ) ;

			$ip		=  $row [ 'ip' ] ;
			$url		=  $row [ 'url' ] ;

			$data []	=
			   [
				'date'		=>  $date,
				'domain'	=>  $domain,
				'logfile'	=>  $logfile,
				'ip'		=>  $ip,
				'url'		=>  $url
			    ] ;
		    }

		$report		=  new AsciiReport 
		   (
			[ 'member' => 'date'	, 'title' => 'Date'		],
			[ 'member' => 'domain'	, 'title' => 'Domain'		],
			[ 'member' => 'logfile'	, 'title' => 'Log file'		],
			[ 'member' => 'ip'	, 'title' => 'Ip'		],
			[ 'member' => 'url'	, 'title' => 'Url'		]
		    ) ;

		$report -> Generate ( $data, true ) ;
		echo $report -> Summary ( 'url' ) ;
	    }
	    
	// QueryUrlsByDate -
	//	Same as QueryIps, but display an url instead of a domain name.
	function  QueryUrlsByDate ( $dates )
	   {
		global		$Database, $ServerList ;

		$ip_store_type	=  LogStringStore::LOGSTORE_IP ;
		$url_store_type	=  LogStringStore::LOGSTORE_HTTP_REQUEST_URL ;
		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;

		$query		=  "
					SELECT
						server_logfile_entries. serle_date 	AS 'date',
						servers. ser_name 			AS 'server',
						server_domains. serd_domain 		AS 'domain',
						server_logfiles. serl_path 		AS 'logfile',
						server_string_store. value 		AS 'ip',
						url_string_store. value 		AS 'url'
					FROM server_logfile_data
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_string_store ON
						server_string_store. id = server_logfile_data. serld_string_store_id
					LEFT JOIN server_logfile_data AS server_logfile_url_data ON
						server_logfile_url_data. serld_parent_id = server_logfile_data. serld_parent_id AND
						server_logfile_url_data. serld_data_type = $url_store_type
					LEFT JOIN server_string_store AS url_string_store ON
						server_logfile_url_data. serld_string_store_id = url_string_store. id
					WHERE
						servers. ser_id IN ( $server_ids ) AND 
						server_logfile_entries. serle_date BETWEEN '{$dates [0]}' AND '{$dates [1]}' AND
						server_logfile_data. serld_string_store_id IN
						   (
							SELECT id
							FROM server_string_store
							WHERE
								type = $ip_store_type
						    ) AND
						server_logfile_data. serld_logfile_type <> 5 AND
						server_logfile_data. serld_string_store_id NOT IN
						   (
							SELECT DISTINCT serld_string_store_id
							FROM server_logfile_data 
							LEFT JOIN server_logfile_entries ON
								server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
							WHERE
								serld_logfile_type = 5 AND
		                                                server_logfile_entries. serle_date BETWEEN '{$dates [0]}' AND '{$dates [1]}'
						    )
					ORDER BY 
						server_logfile_entries. serle_date,
						servers. ser_name,
						server_domains. serd_domain,
						server_string_store. value
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$date		=  $row [ 'date' ] ;
			$domain		=  $row [ 'domain' ] ;

			if  ( strncmp ( $row [ 'logfile' ], '/server/www/', 12 ) )
				$logfile	=  $row [ 'logfile' ] ;
			else
				$logfile	=  substr ( $row [ 'logfile' ], 12 ) ;

			$ip		=  $row [ 'ip' ] ;
			$url		=  $row [ 'url' ] ;

			$data []	=
			   [
				'date'		=>  $date,
				'domain'	=>  $domain,
				'logfile'	=>  $logfile,
				'ip'		=>  $ip,
				'url'		=>  $url
			    ] ;
		    }

		$report		=  new AsciiReport 
		   (
			[ 'member' => 'date'	, 'title' => 'Date'		],
			[ 'member' => 'domain'	, 'title' => 'Domain'		],
			[ 'member' => 'logfile'	, 'title' => 'Log file'		],
			[ 'member' => 'ip'	, 'title' => 'Ip'		],
			[ 'member' => 'url'	, 'title' => 'Url'		]
		    ) ;

		$report -> Generate ( $data, true ) ;
		echo $report -> Summary ( 'url' ) ;
	    }

	    
	// QueryIpCount -
	//	Query ip count for the specified date range.
	function  QueryIpCount ( $dates )
	   {
		global		$Database, $ServerList ;

		$ip_store_type	=  LogStringStore::LOGSTORE_IP ;
		$url_store_type	=  LogStringStore::LOGSTORE_HTTP_REQUEST_URL ;
		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;

		$query		=  "
					SELECT date, ip, count
					FROM
					   (
						SELECT
							DATE( server_logfile_entries. serle_date ) AS 'date',
							server_string_store. value AS 'ip',
							server_string_store. id AS 'ip_id',
							COUNT( server_string_store. value ) AS 'count'
						FROM server_logfile_data
						INNER JOIN server_logfile_entries ON
							server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
						INNER JOIN server_string_store ON
							server_string_store. id = server_logfile_data. serld_string_store_id
						WHERE
							server_logfile_data. serld_data_type = 1 AND
							server_string_store. value NOT IN ( '127.0.0.1', '::1', 'unknown' ) AND
							server_logfile_entries. serle_date BETWEEN '{$dates [0]}' AND '{$dates [1]}' 
						GROUP BY
							DATE( server_logfile_entries. serle_date ),
							server_string_store. value
						ORDER BY
							COUNT( server_string_store. value ),
							INET_ATON( server_string_store. value )
					    ) AS Selection
					WHERE 
						servers. ser_id IN ( $server_ids ) AND
						NOT EXISTS
						   (
							SELECT seri_id
							FROM server_iptables
							WHERE
								seri_source = ip
							LIMIT 1
 						    ) AND
						NOT EXISTS
						   (
							SELECT serld_id
							FROM server_logfile_data
							WHERE
								serld_logfile_type = 5 AND
								serld_string_store_id = ip_id
							LIMIT 1
						    )				   
				    " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$report		=  new AsciiReport 
		   (
			[ 'member' => 'date'	, 'title' => 'Date'		],
			[ 'member' => 'ip'	, 'title' => 'Ip'		],
			[ 'member' => 'count'	, 'title' => 'Count'		]
		    ) ;

		$report -> Generate ( $rows, true ) ;
		echo $report -> Summary ( 'entry' ) ;
	    }


	/*==================================================================================================

	    OptimizeLogTables -
		Optimizes all the tables related to log entries.

	  ==================================================================================================*/
	function  OptimizeLogTables ( )
	   {
		global		$RsAdmin ;


		$db		=  $RsAdmin -> Database ;
		$db -> SetSimpleQuery ( "SHOW TABLE STATUS" ) ;
		$rows		=  $db-> LoadRows ( ) ;
		$tables		=  [] ;
		$max_length	=  0 ;

		foreach  ( $rows  as  $row )
		   {
			$length		=  strlen ( $row [ 'Name' ] ) ;

			if  ( $length  >  $max_length )
				$max_length	=  $length ;

			$tables []	=  $row [ 'Name' ] ;
		    }

		foreach  ( $tables  as  $table )
		   {
			$name	= sprintf ( "%-{$max_length}s", $table ) ;

			echo ( "Optimizing $name..." ) ;
			$db -> Execute ( "OPTIMIZE TABLE $table" ) ;
			output ( "done" ) ;
		    }
	    }


	/*==================================================================================================

	    ExtractLogData -
		Extracts log data from the specified log types.

	  ==================================================================================================*/
	function  ExtractLogData  ( $logtypes, $me = false )
	   {
		global		$Database, $RsAdmin ;


		$global_new_records	=  0 ;

		output ( "Analyzing new log entries :" ) ;
		$ip_ids			=  [] ;

		foreach  ( $logtypes  as  $logtype )
		   {
			$local_log		 =  $RsAdmin -> GetLocalLogInstance ( $logtype ) ;
			$title			 =  $local_log -> Title ;
			$server_ip_ids		 =  [] ;
			$new_records		 =  $local_log -> Extract ( $server_ip_ids ) ;
			$ip_ids			 =  array_merge ( $ip_ids, $server_ip_ids ) ;

			$global_new_records	+=  $new_records ;
			$logtype_new_records	 =  $new_records ;

			output ( "\n\t---> " . number_format ( $logtype_new_records, 0, '.', ' ' ) . " entries extracted for $title log" ) ;
		    }

		output ( "---> " . number_format ( $global_new_records, 0, '.', ' ' ) . " entries extracted." ) ;

		$ip_ids		=  array_unique ( $ip_ids ) ;

		// Display the list of retrieved ips
		$iplist		=  implode ( ', ', $ip_ids ) ;
		$today		=  date ( 'Y-m-d' ) ;
		$query		=  "
					SELECT
						server_string_store. value  				AS 'ip',
						servers. ser_name 					AS 'server',
						server_domains. serd_domain 				AS 'domain',
						server_logfile_data. serld_logfile_type 		AS 'logtype',
						COUNT( server_string_store. value )			AS 'count',
						(
							SELECT COUNT(*)
							FROM server_logfile_data AS logdata
							LEFT JOIN server_logfile_entries ON
								server_logfile_entries. serle_id = logdata. serld_parent_id
							LEFT JOIN server_logfiles ON
								server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
							LEFT JOIN server_domains AS domain_data ON
								domain_data. serd_id = server_logfiles. serl_domain_id
							WHERE 
								domain_data. serd_id = server_domains. serd_id AND
								logdata. serld_string_store_id = server_string_store. id AND
								logdata. serld_logfile_type = server_logfile_data. serld_logfile_type AND
								DATE( server_logfile_entries. serle_date ) = '$today'

						 )							AS  'today_count',
						IF( EXISTS
							(
								SELECT serld_id 
								FROM server_logfile_data AS ssh_data
								WHERE 
									ssh_data. serld_string_store_id = server_string_store. id AND
									ssh_data. serld_logfile_type = " . RsAdmin::LOGTYPE_SSH . " AND
									server_string_store. type = " . LogStringStore::LOGSTORE_IP . "
							 ), '*', ''
						    )							AS 'me',
						IF( EXISTS
							(
								SELECT seri_id 
								FROM server_iptables 
								WHERE
									server_iptables. seri_source = server_string_store. value
							 ), '*', ''
						   )							AS 'blocked'
					FROM server_string_store
					LEFT JOIN server_logfile_data ON
						server_logfile_data. serld_string_store_id = server_string_store. id
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_logfile_entries_string_store ON
						server_logfile_entries_string_store. id = server_logfile_entries. serle_message_id
					WHERE
						server_string_store. id IN ( $iplist ) AND 
						server_string_store. value NOT IN ( '::1', '127.0.0.1' ) 
					GROUP BY
						servers. ser_id,
						server_domains. serd_id,
						server_logfile_data. serld_logfile_type,
						server_string_store. id
					ORDER BY
						server_logfile_data. serld_logfile_type,
						servers. ser_name,
						server_domains. serd_domain,
						INET_ATON( server_string_store. value )
				   " ;
		$Database -> SetQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;

		$report_columns	=  
		  [
			[ 'member' => 'logtype'		, 'title' => 'Log type'		, 'format' => 'get_logtype_name'	],
			[ 'member' => 'ip'		, 'title' => 'Ip'							],
			[ 'member' => 'server'		, 'title' => 'Server'							],
			[ 'member' => 'domain'		, 'title' => 'Domain'							],
			[ 'member' => 'count'		, 'title' => 'All time count'						],
			[ 'member' => 'today_count'	, 'title' => 'Today\'s count'						],
			[ 'member' => 'blocked' 	, 'title' => 'Blocked?'		, 'align' => 'center'			]
		   ] ;

		if  ( $me ) 
		   {
			$report_columns []	=
				[ 'member' => 'me'		, 'title' => 'Me?'		, 'align' => 'center'			] ;

			$rows		=  array_filter 
			   (
				$rows,
				function ( $value )
				   { return ( $value [ 'today_count' ]  !=  0 ) ; }
			    ) ;
		    }
		else
		   {
			$rows		=  array_filter 
			   (
				$rows,
				function ( $value )
				   { return ( $value [ 'me' ]  !=  '*'  &&  $value [ 'today_count' ]  !=  0 ) ; }
			    ) ;
		     }

		$report		=  new AsciiReport ( $report_columns ) ;
		$report -> Generate ( $rows, true ) ;
		echo $report -> Summary ( 'new ip' ) ;
	    }
	
	


	/*==================================================================================================

	    RetrieveHostSpecificLogs -
		Retrieves the log files from the specified server.

	  ==================================================================================================*/
	function  RetrieveHostSpecificLogs  ( $host, $logtype )
	   {
		$logfiles	=  new RemoteLogs ( $host, $logtype ) ;
		$new_records	=  0 ;

		foreach  ( $logfiles  as  $logfile )
		   {
			$new_records	+=  $logfile -> Update ( ) ;
		    }

		return ( $new_records ) ;
	    }
	
	
	/*==================================================================================================

	    RetrieveHostLogs -
		Retrieves the log files from the specified server.

	  ==================================================================================================*/
	function  RetrieveHostLogs  ( $hosts, $logtypes )
	   {
		global		$RsAdmin ;


		$global_new_records	=  0 ;

		foreach  ( $hosts as  $host )
		   {
			output ( "Server $host : " ) ;		
			$host_new_records	=  0 ;
		
			foreach  ( $logtypes  as  $logtype )
			   {
				$new_records		 =  RetrieveHostSpecificLogs ( $host, $logtype ) ;
				$global_new_records	+=  $new_records ;
				$host_new_records	+=  $new_records ;
			    }

			output ( "\t---> " . number_format ( $host_new_records, 0, '.', ' ' ) . " records written for host $host" ) ;
		    }

		output ( "---> " . number_format ( $global_new_records, 0, '.', ' ' ) . " records written." ) ;

		// Set the last update date for every log file 
		$RsAdmin -> Database -> Execute ( "UPDATE " . RsAdmin::TABLE_SERVER_LOGFILES . " SET serl_last_update = NOW()" ) ;
	    }


	/*==============================================================================================================
	
	    TraceIp -
	        Traces the various accesses from the specified ip address.
	
	  ==============================================================================================================*/
	function  TraceIp ( $ip )
	   {
		global		$Database, $ServerList ;


		$server_ids	=  implode ( ', ', get_server_ids ( $ServerList ) ) ;
		$query		=  "
					SELECT
						server_string_store. value  				AS 'ip',
						servers. ser_name 					AS 'server',
						server_domains. serd_domain 				AS 'domain',
						server_logfiles. serl_logfile_type 			AS 'logfile_type',
						SUBSTRING_INDEX( server_logfiles. serl_path, '/', -1 )	AS 'logfile_name',
						server_logfile_entries. serle_entry_type		AS 'entry_type',
						server_logfile_entries. serle_date 			AS 'date',
						server_logfile_entries_string_store. value 		AS 'message'
					FROM server_string_store
					LEFT JOIN server_logfile_data ON
						server_logfile_data. serld_string_store_id = server_string_store. id
					LEFT JOIN server_logfile_entries ON
						server_logfile_entries. serle_id = server_logfile_data. serld_parent_id
					LEFT JOIN server_logfiles ON
						server_logfiles. serl_id = server_logfile_entries. serle_logfile_id
					LEFT JOIN server_domains ON
						server_domains. serd_id = server_logfiles. serl_domain_id
					LEFT JOIN servers ON
						servers. ser_id = server_domains. serd_server_id
					LEFT JOIN server_logfile_entries_string_store ON
						server_logfile_entries_string_store. id = server_logfile_entries. serle_message_id
					WHERE
						servers. ser_id IN ( $server_ids ) AND
						server_string_store. type = 1 AND 
						server_string_store. value = '{$ip [ 'ip-address' ]}'
					ORDER BY
						servers. ser_name,
						server_domains. serd_domain,
						server_logfile_entries. serle_date,
						SUBSTRING_INDEX( server_logfiles. serl_path, '/', -1 )
				   " ;
		$Database -> SetQuery ( $query ) ;
		$rows	=  $Database -> LoadRows ( ) ;

		$report		=  new AsciiReport
		   (
			[ 'member' => 'server'		, 'title' => 'Server'		],
			[ 'member' => 'domain'		, 'title' => 'Domain'		],
			[ 'member' => 'logfile_name'	, 'title' => 'Logfile'		],
			[ 'member' => 'date'		, 'title' => 'Date'		],
			[ 'member' => 'message' 	, 'title' => 'Message', 'width' => 80, 'overflow' => 'wrap' ]
		    ) ;

		$report -> Generate ( $rows, true ) ;
		echo $report -> Summary ( 'log entry' ) ;
	    }

	
	/*==================================================================================================

		Global constants and variables.

	  ==================================================================================================*/
	$CL 				=  new  CLParser ( $Definitions ) ;

	$CheckExtractedData		=  $CL -> check_extracted_data ;
	$ConfigurationFile		=  $CL -> configuration_file ;
	$Extract			=  $CL -> extract ;
	$ListConfiguredServers		=  $CL -> list_configured_servers ;
	$ListLogEntryStatistics		=  $CL -> list_log_entry_statistics ;
	$ListStringStoreStatistics	=  $CL -> list_string_store_statistics ;
	$ListTableInformation		=  $CL -> list_table_information ;
	$LogType			=  ( integer ) $CL -> log_type ;
	$OptimizeTables			=  $CL -> optimize_tables ;
	$QueryDomainsByDate		=  $CL -> query_domains_by_date ;
	$QueryUrlsByDate		=  $CL -> query_urls_by_date ;
	$QueryIpCount			=  $CL -> query_ip_count ;
	$QueryIps			=  $CL -> query_ips ;
	$QueryUrls			=  $CL -> query_urls ;
	$ResolveIps			=  $CL -> resolve_ips ;
	$RsLogsConfigurationFile	=  $CL -> rslogs_configuration_file ;
	$Servers			=  $CL -> servers ;
	$Sync				=  $CL -> sync ;
	$TraceIp			=  $CL -> trace_ip ;
	$Update				=  $CL -> update ;
		
	$RsAdmin			=  new RsAdmin ( $ConfigurationFile ) ;
	$RsLogs				=  IniFile::LoadFromfile ( $RsLogsConfigurationFile ) ;

	$CleanIps			=  false ;
	$CleanMessages			=  false ;
	$CleanSshConnections		=  false ;
	$IpsToClean			=  [] ;
	$MessagesToClean		=  [] ;

	$ServerList			=  $RsAdmin -> FindServers ( $Servers ) ;
	$ServerDomains			=  $RsAdmin -> FindServerDomains ( $Servers ) ;

	$HadOption			=  false ;
	$HadListOption			=  false ;

	// Instanciate a string store object
	$StringStore			=  new LogStringStore ( RsAdmin::TABLE_SERVER_STRING_STORE, $RsAdmin -> Database ) ;

	// To be removed in the future
	$StringStoreTables		=  
	   [ 
		'server_string_store'			=>  LogStringStore::GetTypes ( ),
		'server_logfile_entries_string_store'	=>
		   [
			[ 'name' => 'Message', 'label' => 'Message', 'value' => 0 ]
		    ],
		'whois_string_store'			=>
		   [
			WhoisInformation::WHOIS_STRING_STORE_KEYWORD	=>
			   [ 
				'name'	=> 'WHOIS_STRING_STORE_KEYWORD', 
				'label' => 'Keyword', 
				'value' => WhoisInformation::WHOIS_STRING_STORE_KEYWORD	
			    ],
			WhoisInformation::WHOIS_STRING_STORE_TEXT	=>
			   [ 
				'name'	=> 'WHOIS_STRING_STORE_TEXT', 
				'label' => 'Text', 
				'value' => WhoisInformation::WHOIS_STRING_STORE_TEXT		
			    ],
			WhoisInformation::WHOIS_STRING_STORE_VALUE	=> 
			   [ 
				'name'	=> 'WHOIS_STRING_STORE_VALUE', 
				'label' => 'Value', 
				'value' => WhoisInformation::WHOIS_STRING_STORE_VALUE		
			    ]
		    ]
	    ] ;

	// Default value for log type is "all log types"
	if  ( $LogType  ==  -1 )
		$LogTypes	=  
		   [ 
			RsAdmin::LOGTYPE_HTTP, 
			RsAdmin::LOGTYPE_HTTP_ERROR, 
			RsAdmin::LOGTYPE_HTTP_ERROR_404,
			RsAdmin::LOGTYPE_MAIL,
			RsAdmin::LOGTYPE_AUTH,
			RsAdmin::LOGTYPE_SSH
		    ] ;
	else
		$LogTypes	=  [ $LogType ] ;

	// Load rslogs-specific configuration parameters
	LoadConfigurationParameters ( $RsLogs ) ;


	/*==================================================================================================

		Main program.

	  ==================================================================================================*/
	// -sync :
	//	Equivalent to : -update -extract -resolve_ips.
	if  ( $Sync ) 
	   {
		$Update			=  true ;
		$Extract		=  true ;
		$ResolveIps		=  true ;
	    }

	// -update :
	//	Updates the log files whose type has been specified by the -log_type parameter.
	if  ( $Update )
	   {
		RetrieveHostLogs ( $ServerList, $LogTypes ) ;
		
		$HadOption	=  true ;
	    }
	
	// -extract :
	//	Extracts data from log files whose type has been specified by the -log_type parameter.
	if  ( $Extract )
	   {
		ExtractLogData ( $LogTypes ) ;
		
		$HadOption	=  true ;
	    }
	
	// -resolve_ips :
	//	Resolves ip addresses collected so far.
	if  ( $ResolveIps )
	   {
		$RsAdmin -> ResolveIps ( ) ;
		$HadOption	=  true ;
	    }
	
	// -optimize_tables :
	//	Optimizes all the log-related tables.
	if  ( $OptimizeTables )
	   {
		OptimizeLogTables ( ) ;
		$HadOption	=  true ;
	    }

	// -update :
	//	Updates the log files whose type has been specified by the -log_type parameter.
	if  ( ! $HadOption  &&  $Update )
	   {
		RetrieveHostLogs ( $ServerList, $LogTypes ) ;
		
		$HadOption	=  true ;
	    }
	
	// -extract :
	//	Extracts data from log files whose type has been specified by the -log_type parameter.
	if  ( ! $HadOption  &&  $Extract )
	   {
		ExtractLogData ( $LogTypes ) ;
		
		$HadOption	=  true ;
	    }
	
	// -check_extracted_data :
	//	Checks that the extracted (and analyzed) data is consistent.
	if  ( ! $HadOption  &&  $CheckExtractedData )
	   {
		CheckExtractedData ( ) ;
		$HadOption	=  true ;
	    }

	// -list_configured_servers :
	//	Lists the servers configured for this command.
	if  ( ! $HadOption  &&  $ListConfiguredServers ) 
	   {
		$RsAdmin -> ListServers ( ) ;
		$HadListOption	=  true ;
	    }

	// -list_row_count :
	//	Lists the row count for each server table.
	if  ( ! $HadListOption  &&  $ListTableInformation )
	   {
		ListTableInformation ( ) ;
		$HadListOption	=  true ;
	    }

	// -list_log_entry_statistics :
	//	Lists statistics about log entries.
	if  ( ! $HadListOption  &&  $ListLogEntryStatistics )
	   {
		ListLogEntryStatistics ( ) ;
		$HadListOption	=  true ;
	    }

	// -list_string_store_statistics :
	//	Lists statistics about string store tables.
	if  ( ! $HadListOption  &&  $ListStringStoreStatistics )
	   {
		ListStringStoreStatistics ( ) ;
		$HadListOption	=  true ;
	    }

	// -query_domains_by_date :
	//	Queries the logs for the date or range of dates.
	if  ( ! $HadListOption  &&  $CL -> IsSpecified ( 'query_domains_by_date' ) ) 
	   {
		QueryDomainsByDate ( get_date_range ( $QueryDomainsByDate ) ) ;
		$HadListOption	=  true ;
	    }

	// -query_urls_by_date :
	//	Queries the logs for the date or range of dates.
	if  ( ! $HadListOption  &&  $CL -> IsSpecified ( 'query_urls_by_date' ) ) 
	   {
		QueryUrlsByDate ( get_date_range ( $QueryUrlsByDate ) ) ;
		$HadListOption	=  true ;
	    }

	// -query_ip_count :
	//	Queries ip count for the specified date range.
	if  ( ! $HadListOption  &&  $CL -> IsSpecified ( 'query_ip_count' ) ) 
	   {
		QueryIpCount ( get_date_range ( $QueryIpCount ) ) ;
		$HadListOption	=  true ;
	    }

	// -query_ips :
	//	Queries the logs for the specified ips.
	if  ( ! $HadListOption  &&  count ( $QueryIps ) ) 
	   {
		QueryIps ( $QueryIps ) ;
		$HadListOption	=  true ;
	    }

	// -query_urls :
	//	Queries the logs for the specified ips.
	if  ( ! $HadListOption  &&  count ( $QueryUrls ) ) 
	   {
		QueryUrls ( $QueryUrls ) ;
		$HadListOption	=  true ;
	    }

	// -trace_ip :
	//	Traces the various accesses from the specified ip.
	if  ( ! $HadListOption  &&  $TraceIp ) 
	   {
		TraceIp ( $TraceIp ) ;
		$HadListOption	=  true ;
	    }

	if  ( $HadListOption )
		$HadOption	=  true ;

	// No option specified : display help
	if  ( ! $HadOption ) 
		$CL -> DisplayHelp ( ) ;