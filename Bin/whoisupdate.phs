<?php
	//!phpcmd(Administration, 2.0, production) : Collects whois information.
	/**************************************************************************************************************
	
	    NAME
	        whoisupdate.phs
	
	    DESCRIPTION
	        Collects whois information.
	
	    AUTHOR
	        Christian Vigh, 07/2015.
	
	    HISTORY
	    [Version : 1.0]	[Date : 2015/07/31]     [Author : CV]
	        Initial version.

	    (... a bunch of intermediate versions)

	    [Version : 1.1]	[Date : 2015/09/24]     [Author : CV]
		. When searching for an ip address whose LSB is zero, if a range of 0.0.0.0 - 255.255.255.255 is found,
		  then only a 256-addresses range will be allocated.

	    [Version : 1.1.0]	[Date : 2015/09/26]     [Author : CV]
		. Added the whois_missing_ranges table, that holds the last computed missing ranges
		. Added the whois_variables table, which hold the following 
		. Added the following parameters

	    [Version : 2.0]	[Date : 2015/12/25]     [Author : CV]
		. Added the -join_unallocated_ranges option.
		. Optimized range merge after reading from database (passed from 90s to 3s...)
		. Optimized subrange removal
		. Completely rewrote database update
		. Removed the notion of parent range

	 **************************************************************************************************************/
	require ( "tools.phpinclude" ) ;

	use  Thrak\Processors\CL\CLParser ;
	use  Thrak\Types\StringUtilities ;
	use  Thrak\Types\String\Convert ;
	use  Thrak\Types\ArrayHelpers ;
	use  Thrak\IO\Console ;
	use  Thrak\IO\Path ;
	use  Thrak\IO\AsciiReport ;
	use  Thrak\Processors\WhoisInformation ;
	use  Thrak\Database\BufferedInsert ;
	use  Thrak\Database\Tables\StringStore ;
	use  Thrak\Internet\TLDList ;
	use  Thrak\System\Timer ;


	require ( "RsAdmin.phpclass" ) ;


	/*==============================================================================================================
	
	        Command-line definition.
	
	  ==============================================================================================================*/
	$Definitions = <<<END
<command>

	<usage>
		Collects whois information.
	</usage>

	<topic name="config">
		Configuration options.
	</topic>

	<topic name="list">
		List options.
	</topic>

	<topic name="misc">
		Miscellaneous options.
	</topic>

	<topic name="remote">
		Options for data retrieval from remote servers.
	</topic>

	<topic name="update">
		Whois information update options.
	</topic>


	<ip-address name="add_unallocated_range, aur" arguments="2..2" topic="update">
		Adds an unallocated ip range.
	</ip-address>

	<flag name="collect, c" topic="remote, update">
		Collects whois data on remote servers.
	</flag>

	<file name="configuration_file, cf" disposition="existing" default="thraktools://Data/rsadmin.ini" topic="config">
		Hosted servers parameters file.
	</file>
	
	<flag name="extract_new_ips, eni, x" topic="update">
		Updates the whois database with the new ips coming from the server_string_store table.
	</flag>

	<flag name="keep_files, kf" topic="remote, update">
		Normally, files are removed from the remote servers once they have been processed.
		This options tels whoisupdate to keep them after processing.
	</flag>

	<unsigned name="limit, l" min-value="1" topic="list">
		Defines the maximum number of records to be displayed.
		To be used with the -list_xxx options.
	</unsigned>

	<flag name="join_unallocated_ranges, jur" topic="update">
		Groups unallocated consecutive ranges into one single range. Only service provider entries are
		concerned.
	</flag>
		
	<flag name="list_allocation_statistics, las" topic="list">
		Lists statistics about ip address allocations (allocated/unallocated, range count, ip count).
	</flag>

	<flag name="list_configured_servers, lcs" topic="list">
		Lists the servers configured for this command.
	</flag>

	<flag name="list_countries, lc" topic="list">
		Lists the countries referenced in the whois database, together with the number of ip ranges
		allocated, and the number of ip addresses.
	</flag>

	<ip-address name="list_ip_references, lir" topic="list">
		Lists all the rows that include the specified ip address.
	</ip-address>

	<flag name="list_keywords, lk" topic="list">
		Lists all the possible keywords found in the input file.
	</flag>

	<unsigned name="list_missing_ranges, lmr" min-value="1" default="<?= PHP_INT_MAX ?>" topic="list">
		Lists the ip ranges that are absent from the local whois database.
	</unsigned>

	<unsigned name="next, n" min-value="1" default="1" topic="update">
		Extract the specified number of whois ip ranges from the remote whois databases.
	</unsigned>

	<flag name="rebuild_unscanned_ips" hidden="true">
		Rebuilds the whois_unscanned_ips table, from the whois_information table.
	</flag>
	
	<string name="server_path, sp" default="/server/data/whois" topic="config">
		Path on the remote server where the files containing whois data are stored.
	</string>

	<string name="servers, server, s" default="*" arguments="0..*" topic="config">
		Server name(s) on which collected random data is to be retrieved.
		Wildcard characters are authorized, and search is performed on every server alias.
	</string>

	<string name="sort_by, sb" topic="list">
		Defines sort options by field name, optionally followed by "ASC" or "DESC".
		Field names depend on the -list_xxx option specified.
	</string>

	<ip-address name="start_ip, si" topic="update">
		Ip address that serves as a starting point for range extraction (-next option).
	</ip-address>

	<file name="whois_data_file, wdf, wd" topic="update">
		A data file containing one or more whois data outputs, preceded by the whois command that extracted 
		the information.
	</file>

	<file name="whois_ip_file, wif" topic="update">
		A data file containing ip addresses. The whois command will be run for each address specified.
	</file>

	<ip-address name="whois_ips, whois_ip, wi" address-type="ipv4" arguments="1..*" topic="update">
		A list of ip addresses. The whois command will be run for each address specified.
	</ip-address>

</command>
END;

	/*==============================================================================================================
	
	        Helper functions.
	
	  ==============================================================================================================*/

	// dbadd_whois_entry -
	//	Adds a new whois entry to the database.
	function  dbadd_whois_entry ( $ip_range, $buffer, $whois_data, $whois_block )
	   {
		global		$Database, $WhoisStringStore ;

		$flags		=  $whois_data -> Flags ;
		$country	=  $whois_block -> GetCountry ( ) ;
		$update_time	=  $whois_block -> GetUpdateTime ( ) ;
		$data		=  $Database -> Escape ( $whois_data -> Contents ) ;

		if  ( $update_time )
			$last_update	=  "'" . date ( 'Y-m-d H:i:s', $update_time ) . "'" ;
		else
			$last_update	=  'NOW()' ; 

		$query		=  "
					INSERT INTO whois_information
					SET
						whoi_last_update	=  NOW(),
						whoi_last_whois_update	=  $last_update,
						whoi_ip_low		=  '{$ip_range [0]}',
						whoi_ip_high		=  '{$ip_range [1]}',
						whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
						whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
						whoi_flags		=  $flags,
						whoi_country		=  '$country',
						whoi_text		=  '$data'
				   " ;
		$Database -> Execute ( $query ) ;
		$id	=  $Database -> GetLastInsertId ( ) ;

		// Insert records into the whois_information_blocks table
		foreach  ( $whois_block  as  $block )
		   {
			$query	=  "
					INSERT INTO " . RsAdmin::TABLE_WHOIS_INFORMATION_BLOCKS . "
					SET
						whoib_information_id	=  $id,
						whoib_type		=  {$block -> Type}
				   " ;

			$Database -> Execute ( $query ) ;
			$block_id	=  $Database -> GetLastInsertId ( ) ;

			foreach  ( $block  as  $entry )
			   {
				$keyword_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_KEYWORD	, $entry -> Keyword ) ;
				$text_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_TEXT	, $entry -> Text ) ;
				$value_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_VALUE, 
											serialize ( $entry -> Value ) ) ;

				// Insert records into the whois_information_block_entries table
				$status = $buffer -> Add
				   ([
					'columns' =>
					   [
						'whoibe_information_id'	=>  $id,
						'whoibe_block_id'	=>  $block_id,
						'whoibe_type'		=>  $entry -> Type,
						'whoibe_common_type'	=>  $entry -> CommonType,
						'whoibe_keyword_id'	=>  $keyword_id,
						'whoibe_text_id'	=>  $text_id,
						'whoibe_value_id'	=>  $value_id
					    ]
				     ]) ;
			    }
		    }
	    }


	// dbdelete_whois_entry -
	//	Deletes a whois entry.
	function  dbdelete_whois_entry ( $id )
	   {
		global		$Database ;

		$Database -> Execute ( "DELETE FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . " WHERE whoi_id = $id" ) ;
		$Database -> Execute ( "DELETE FROM " . RsAdmin::TABLE_WHOIS_INFORMATION_BLOCKS . " WHERE whoib_information_id = $id" ) ;
		$Database -> Execute ( "DELETE FROM " . RsAdmin::TABLE_WHOIS_INFORMATION_BLOCK_ENTRIES . " WHERE whoibe_information_id = $id" ) ;
	    }


	// dbreplace_whois_entry -
	//	Adds a new whois entry to the database.
	function  dbreplace_whois_entry ( $ip_range, $buffer, $whois_data, $whois_block, $row )
	   {
		global		$Database ;

		$whois_time		=  $whois_block -> GetUpdateTime ( ) ;
		$db_time		=  strtotime ( $row [ 'whoi_last_whois_update' ] ) ;
		$id			=  $row [ 'whoi_id' ] ;


		if  ( $whois_time  >  $db_time )
		   {
			dbdelete_whois_entry ( $id ) ;
			dbadd_whois_entry ( $ip_range, $buffer, $whois_data, $whois_block ) ;

			return ( true ) ;
		    }
		else
		   {
			$query		=  "
						UPDATE " . RsAdmin::TABLE_WHOIS_INFORMATION . "
						SET whoi_last_update = NOW()
						WHERE 
							whoi_id = $id
					   " ;
			$Database -> Execute ( $query ) ;

			return ( false ) ;
		    }
	    }


	// find_missing_ranges -
	//	Finds the missing ranges in the local whois database.
	function  __create_range ( $ipv4_low, $ipv4_high )
	   {
		$ip_low		=  Convert::IntegerToIpString ( $ipv4_low ) ;
		$ip_high	=  Convert::IntegerToIpString ( $ipv4_high ) ;

		$range	=
		   [
			'whoi_ip_low'		=>  $ip_low,
			'whoi_ip_high'		=>  $ip_high,
			'whoi_ipv4_low'		=>  $ipv4_low,
			'whoi_ipv4_high'	=>  $ipv4_high
		    ] ;

		return ( $range ) ;
	    }


	function  find_missing_ranges ( $count = PHP_INT_MAX )
	   {
		global		$Database ;
		exit ;

		// All done, return
		return ( $missing_ranges ) ;
	    }


	// get_list_options -
	//	Returns an ORDER BY and a LIMIT clauses, depending on the -sort_by and -limit options
	function  get_list_options ( $option, $sort_fields )
	   {
		global		$SortBy, $Limit ;

		$limit		=  '' ;
		$sort_by	=  '' ;

		if  ( $Limit )
			$limit	=  "LIMIT $limit" ;

		if  ( $SortBy )
		   {
			$field_strings		=  explode ( ',', $SortBy ) ;
			$fields			=  [] ;

			foreach  ( $field_strings  as  $field_string )
			   {
				if  ( preg_match ( '/^ (?P<field> [^\s]) \s+ ASC $/imsx', $field_string, $match ) )
				   {
					$fields []	=  $match [ 'field' ] . ' ASC' ;
					$field_name	=  $match [ 'field' ] ;
				    }
				else if  ( preg_match ( '/^ (?P<field> [^\s]) \s+ DESC $/imsx', $field_string, $match ) )
				   {
					$fields []	=  $match [ 'field' ] . ' DESC' ;
					$field_name	=  $match [ 'field' ] ;
				    }
				else
				   {
					$fields []	=  $field_string ;
					$field_name	=  $field_string ;
				    }

				$found	=  false ;

				foreach ( $sort_fields  as  $sort_field ) 
				   {
					if  ( ! strcasecmp ( $sort_field, $field_name ) )
					   {
						$found		=  true ; 
						break ;
					    }
				    }

				if  ( ! $found )
					error ( "Field \"$field_name\" is not defined for option $option." ) ;
			    }

			$sort_by	=  'ORDER BY ' . implode ( ', ', $fields ) ;
		    }

		return ( [ $sort_by, $limit ] ) ;
	    }


	// get_whois_information -
	//	Gets whois information for the specified ip and returns a WhoisInformation object.
	function  get_whois_information ( $ip )
	   {
		static		$error_results	=
		   [
			'connect: Connection timed out',
			'fgets: Connection reset by peer',
			'Timeout.',
			'Timeout!!',
			'Cannot currently process your search request',
			'Query rate limit exceeded',
			'Connection reset by peer'
		    ] ;

		$data		=  null ;
		$output		=  Path::GetVolatileTempFilename ( 'whois.www', '%f.%p.%s.txt' ) ;	
		$real_output	=  Path::ToUnix ( Path::RealPath ( $output ) ) ;
		$command	=  "whois $ip >$real_output 2>&1" ;

ShootAgain:
		system ( $command ) ;

		$data		=  trim ( file_get_contents ( $output ) ) ;
		$referral_index	=  stripos ( $data, 'Found a referral to' ) ;
		$shootagain	=  false ;

		if  ( stripos ( $data, 'NetRange:' )  ===  false  &&  stripos ( $data, 'inetnum:' )  ===  false ) 
		   {
			foreach  ( $error_results  as  $error_result )
			   {
				$index	=  stripos ( $data, $error_result ) ;

				if  ( $index  !==  false )
				   {
					if  ( $referral_index  !==  false )
					   {
						if  ( $index  <  $referral_index )
						   {
							$shootagain	=  true ;
							break ;
						    }
					    }
					else
					   {
						$shootagain	=  true ;
						break ;
					    }
				    }
			    }
		    }

		if  ( $shootagain )
		   {
			sleep ( 3 ) ;
			echo ( '.' ) ;
			goto  ShootAgain ;
		    }

		if  ( $referral_index )
			$data	=  substr ( $data, 0, $referral_index ) ;

		$whois_data	=  WhoisInformation::GetInstance ( $ip, $data ) ;
		unlink ( $real_output ) ;

		return ( $whois_data ) ;
	    }


	// optimize_tables -
	//	Optimizes whois tables.
	function  optimize_tables ( )
	   {
		global	$Database ;


		$tables		=  
		   [
			RsAdmin::TABLE_WHOIS_INFORMATION,
			RsAdmin::TABLE_WHOIS_INFORMATION_BLOCK_ENTRIES,
			RsAdmin::TABLE_WHOIS_INFORMATION_BLOCKS,
			RsAdmin::TABLE_WHOIS_STRING_STORE
		    ] ;

		foreach  ( $tables  as  $table )
			$Database -> Execute ( "OPTIMIZE TABLE $table" ) ;
	    }


	// rebuild_unscanned_ips -
	//	Rebuilds the whois_unscanned_ips table.
	function  rebuild_unscanned_ips ( )
	   {
		global		$Database ;

		// Reset the whois_unscanned_ips table and inserts a ranage that covers the whole address space
		$Database -> Execute ( "TRUNCATE TABLE " . RsAdmin::TABLE_WHOIS_UNSCANNED_IPS ) ;
		$Database -> Execute ( "INSERT INTO " . RsAdmin::TABLE_WHOIS_UNSCANNED_IPS . " VALUES ( INET_ATON( '0.0.0.0' ), INET_ATON( '255.255.255.255' )" ) ;

		// Retrieve the list of whois entries whose address range is a multiple of 256 but if several entries start with the
		// same ip address, only retain the smallest range
		echo ( "Retrieving address ranges that are a multiple of 256..." ) ;

		$searched_flags		=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
		$query			=  "
						SELECT
							whoi_ipv4_low, 
							MIN( whoi_ipv4_high )
						FROM whois_information
						WHERE
							whoi_flags & $searched_flags <> 0  AND
							( whoi_ipv4_high ) - whoi_ipv4_low + 1  <=  65536
						GROUP BY whoi_ipv4_low
						ORDER BY whoi_ipv4_low
					   " ;
		$Database -> SetQuery ( $query ) ;
		$rows			=  $Database -> LoadAllRows ( ) ;
		$row_count		=  count ( $rows ) ;
		output ( "done ($row_count entries found)" ) ;

		// Merge the address ranges
		echo ( "Merging address ranges..." ) ;
		$ranges			=  [] ;
		$start_ip		=  $rows [0] [0] ;
		$end_ip			=  $rows [0] [1] ;

		for ( $i = 1 ; $i < $row_count ; $i ++ )
		   {
			$row	=  $rows [$i] ;

			if  ( $end_ip + 1  ==  $row [0] )
			   {
				$end_ip		=  $row [1] ;
			    }
			else
			   {
				$ranges []	=  [ $start_ip, $end_ip ] ;
				$start_ip	=  $row [0] ;
				$end_ip		=  $row [1] ;
			    }
		    }

		$ranges []	=  [ $start_ip, $end_ip ] ;
		$range_count	=  count ( $ranges ) ;

		output ( "done ($range_count ranges found)" ) ;

		// Create the 
	    }


	// report_ips -
	//	Provides a standardized way to report an ip range list.
	function  report_ips ( $rows, $title, $summary = null )
	   {
		$report		=  new AsciiReport 
		   (
			[ 'member' => 'iplow'	, 'title' => 'Low ip'	, 'align' => 'left'	],
			[ 'member' => 'iphigh'	, 'title' => 'High ip'	, 'align' => 'left'	],
			[ 'member' => 'country'	, 'title' => 'Country'				],
			[ 'member' => 'provider', 'title' => 'P'				],
			[ 'member' => 'type'	, 'title' => 'Type'				],
			[ 'member' => 'status'	, 'title' => 'Status'				],
			[ 'member' => 'wupdate'	, 'title' => 'Whois update'			],
			[ 'member' => 'lupdate'	, 'title' => 'Local update'			]
		    ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$flags		=  $row [ 'whoi_flags' ] ;
			$provider	=  ( $flags & WhoisInformation::WHOIS_FLAGS_PROVIDER ) ?  '*' : '' ;
			$type		=  '?' ;
			$server		=  '?' ;

			switch ( $flags & WhoisInformation::WHOIS_FLAGS_TYPE_MASK )
			   {
				case	WhoisInformation::WHOIS_FLAGS_IS_IPV4			: $type = 'Ip v4'  ; break ;
				case	WhoisInformation::WHOIS_FLAGS_IS_IPV6			: $type = 'Ip v6'  ; break ;
				case	WhoisInformation::WHOIS_FLAGS_ISDOMAIN			: $type = 'Domain' ; break ;
			    }

			switch ( $flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )
			   {
				case	WhoisInformation::WHOIS_FLAGS_SERVER_FOUND		:  $server =  'Ok'	    ; break ;
				case	WhoisInformation::WHOIS_FLAGS_SERVER_NOT_FOUND		:  $server =  'Not found'   ; break ;
				case	WhoisInformation::WHOIS_FLAGS_SERVER_REFUSED_QUERY	:  $server =  'Query later' ; break ;
				case	WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE		:  $server =  'Unallocated' ; break ;
			    }

			$data []	=
			   [
				'iplow'		=>  $row [ 'whoi_ip_low' ],
				'iphigh'	=>  $row [ 'whoi_ip_high' ],
				'country'	=>  $row [ 'whoi_country' ],
				'provider'	=>  $provider,
				'type'		=>  $type,
				'status'	=>  $server,
				'wupdate'	=>  $row [ 'whoi_last_whois_update' ],
				'lupdate'	=>  $row [ 'whoi_last_update' ]
			    ] ;
		   }

		$result		=  "$title\n" .
				   $report -> Generate ( $data ) ;

		if  ( $summary ) 
			$result		.=  $report -> Summary ( $summary ) ;

		return ( $result ) ;
	    }


	// try_predefined_ips -
	//	When a scan for unallocated ranges starts with an ip address ending with 0, this function is called
	//	to check specific addresses such as xx.xx.xx.128, .160, .190 etc.
	//	If none of those addresses are allocated, then we can assume without too many risk that the whole
	//	range 0..255 is unallocated
	function  try_predefined_ips ( $ip )
	   {
		global		$TryAddresses ;


		$ip	=  (double ) $ip ;

		foreach  ( $TryAddresses  as  $try_ip )
		   {
			echo ( "$try_ip " ) ;

			$try_ip		=  round ( ( double ) ( ( $ip / 256 ) * 256 ) ) + ( double ) $try_ip ;
			$try_ip_string	=  Convert::IntegerToIpString ( $try_ip ) ;

			$whois_data	=  get_whois_information ( $try_ip_string ) ;

			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK ) ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
				return ( true ) ;
		    }

		return ( false ) ;
	    }


	// scan_unallocated_ips - 
	//	Finds the first unallocated ip range. Tries by blocks of 256 addresses.
	function  scan_unallocated_ips ( $low, $high, $separator )
	   {
		global		$Database ;

		output ( "\n\tScan from " . Convert::IntegerToIpString ( $low ) . " to " . Convert::IntegerToIpString ( $high ) . ' (' .
				number_format ( $high - $low + 1, 0, '.', ' ' ) . ' addresses)' ) ;

		$low			=  ( double ) $low ;
		$high			=  ( double ) $high ;
		$current		=  $low ;
		$count			=  $low & 0xFF ;


		while  ( $current  <=  $high  &&  $count  <  256 )
		   {
			$ip		=  Convert::IntegerToIpString ( $current ) ;
			echo ( "\t\tTrying $ip.." ) ;

			$whois_data	=  get_whois_information ( $ip ) ;

	
			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK ) !=  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
			   {
				if  ( ! ( $current & 0xFF ) )
				   {
					echo ( "trying predefined ips : " ) ;
					$found_data		=  try_predefined_ips ( $current ) ;

					if  ( ! $found_data )
					   {
						$current	 =  round ( ( $current / 256 ) * 256 ) + 256 ;
						$last		 =  $current ;
						output ( '-> unallocated' ) ;
						break ;
					    }
				    }
			    }
			else
			   {
				add_whois_data_for_ip ( $ip, $whois_data, $separator ) ;
				output ( "done" ) ;

				if  ( $current  !=  $low )
				   {
					$last		=  $current - 1 ;

					if  ( $last  <  $low )
						$last	=  $low ;

					$low_ip		=  Convert::IntegerToIpString ( $low ) ;
					$high_ip	=  Convert::IntegerToIpString ( $last ) ;
					$flags		=  $whois_data -> Flags | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
					$query		=  "
								INSERT INTO whois_information
								SET
									whoi_last_update	=  NOW(),
									whoi_last_whois_update  =  NOW(),
									whoi_ip_low		=  '$low_ip',
									whoi_ip_high		=  '$high_ip',
									whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
									whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
									whoi_flags		=  $flags,
									whoi_country		=  ''
							   " ;
					
					$Database -> Execute ( $query ) ;
					output ( "\t\tUnallocated range : $low_ip - $high_ip" ) ;
				    }


				break ;
			    }
			
			output ( "unallocated" ) ;

			$current ++ ;
			$count ++ ;
		    }

		if  ( $current  >  $low )
		   {
			$last		=  $current - 1 ;
			$low_ip		=  Convert::IntegerToIpString ( $low ) ;
			$high_ip	=  Convert::IntegerToIpString ( $last ) ;
			$flags		=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
			$query		=  "
						INSERT IGNORE INTO whois_information
						SET
							whoi_last_update	=  NOW(),
							whoi_last_whois_update  =  NOW(),
							whoi_ip_low		=  '$low_ip',
							whoi_ip_high		=  '$high_ip',
							whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
							whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
							whoi_flags		=  $flags,
							whoi_country		=  ''
					   " ;
					
			$Database -> Execute ( $query ) ;
			output ( "\tUnallocated range : $low_ip - $high_ip" ) ;
		    }
		else
			$last	=  $current ; 

		return ( $last ) ;
	    }


	/*==============================================================================================================
	
	    AddUnallocatedRange -
	        Add an unallocated IP range.
	
	  ==============================================================================================================*/
	function  AddUnallocatedRange ( $range )
	   {
		global		$Database ;


		$iplow		=  $range [0] [ 'ip' ] ;
		$iphigh		=  $range [1] [ 'ip' ] ;

		// Check that ip high >=  ip low
		if  ( $iplow  >  $iphigh )
			error ( "Low ip is greater than high ip." ) ;

		// Ask for a confirmation if range is wider that 256 addresses
		$width		=  $iphigh - $iplow + 1 ;

		if  ( $width  >  256 )
		   {
			$answer		=  Console::Prompt ( "Warning: address range covers $width addresses ; do you want to continue ? ", 
								[ 'y', 'n' ], 'y' ) ;

			if  ( strtolower ( $answer )  !=  'y' ) 
			   {
				output ( "cancelled." ) ;
				return ;
			    }
		    }

		// Retrieve all the rows that may include one of the ips
		$query	=  "
				SELECT *
				FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				WHERE
					$iplow  BETWEEN whoi_ipv4_low AND whoi_ipv4_high OR
					$iphigh BETWEEN whoi_ipv4_low AND whoi_ipv4_high 
			   " ;
		
		$Database -> SetSimpleQuery ( $query ) ;
		$Database -> Query ( ) ;
		$rows	=  $Database -> LoadRows ( ) ;

		// If existing ranges are found, exit
		if  ( count ( $rows ) )
		   {
			echo report_ips ( $rows,
				"The following ranges already cover ip range {$range [0] [ 'ip-address' ]} - {$range [1] [ 'ip-address' ]} :" ) ;
			output ( "Operation cancelled." ) ;

		    }

		// Range does not exist ; add it as an unallocated ip range
		$flags	=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
		$query	=  "
				INSERT INTO " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				SET
					whoi_ip_low		=  '{$range [0] [ 'ip-address' ]}',
					whoi_ip_high		=  '{$range [1] [ 'ip-address' ]}',
					whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
					whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
					whoi_last_update	=  NOW(),
					whoi_last_whois_update	=  NOW(),
					whoi_flags		=  $flags
			   " ;
		$Database -> Execute ( $query ) ;
	    }


	/*==================================================================================================

	    CollectFiles -
		Collects data from the specified server list.

	  ==================================================================================================*/
	function  CollectFiles ( $hosts, $server_path, $keepfiles )
	   {
		global		$RsAdmin, $Separator ;
		

		output ( "Collecting and checking whois data..." ) ;
		$total_host_files_processed	=  0 ;
		$total_whois_entries		=  0 ;
		$saved_file_id			=  0 ;
		
		// Process each server
		foreach  ( $hosts  as  $host )
		   {
			output ( "\tServer $host :" ) ;
			
			// Connect
			$server			=  $RsAdmin -> FindServer ( $host ) ;
			$server -> Connect ( false, true, true ) ;
			
			$fs			=  $server -> GetFileSystem ( ) ;

			// The remote path specifiedby the -server_path option must exist
			try
			   {
				$rs			=  @$fs -> opendir ( $server_path ) ;
			    }
			catch ( Exception $e )
			   {
				$rs	=  null ;
			    }

			if  ( ! $rs ) 
				continue ;

			// Process each file on the remote server
			$host_files_processed	=  0 ;
			$server_whois_entries	=  0 ;
				
			while  ( $path = $fs -> readdir ( $rs ) )
			   {
				$server_file		=  "$server_path/$path" ;
				$keep_this_file		=  $keepfiles ;

				// Well, remote file mask is hardcoded ("whois.*.gz")...
				if  ( $fs -> is_file ( $server_file )  &&  StringUtilities::Matches ( $path, 'whois.*.gz' ) )
				   {
					output ( "\t\t$server_file..." ) ;
				
					$host_files_processed ++ ;
					$total_host_files_processed ++ ;

					// Unzip remote file contents
					$fp				=  $fs -> gzopen ( $server_file, 'r' ) ;
					$contents			=  $fs -> gzread ( $fp ) ;
					gzclose ( $fp ) ;

					// Extract downloaded whois data
					try
					   {
						list ( $count, $total )		=  ExtractWhoisDataFromString ( explode ( "\n", $contents ), $Separator, true, "\t\t" ) ;
					    }
					// If an exception occurred, save current downloaded file and don't remove the original on the server
					catch ( Exception $e )
					   {
						$count		=  
						$total		=  0 ;
						$message	=  $e -> getMessage ( ) ;
						$keep_this_file	=  true ;

						$saved_file_id ++ ;
						$output_file	=  Path::RealPath ( "tmp://whois.$saved_file_id.txt" ) ;
						file_put_contents ( $output_file, $contents ) ;

						warning ( "\n$message\nOutput saved to $output_file (original file " .
								( ( $keep_this_file ) ?  "kept" : "removed" ) . ')' ) ;
					    }

					// Remove remote file if needed
					if  ( ! $keep_this_file )
						$fs -> unlink ( $server_file ) ;

					output ( "\n\t\t--> $count whois queries processed, $total total whois entries" ) ;
					$server_whois_entries	+=  $count ;
					$total_whois_entries	+=  $count ;
				    }
			    }
			
			$fs -> closedir ( $rs ) ;

			// Perform some housekeeping if files have been processed 
			if  ( $host_files_processed )
			   {
				// Join unallocated ranges
				JoinUnallocatedRanges ( ) ;

				// Optimize tables
				echo ( "\tOptimizing tables..." ) ;
				optimize_tables ( ) ;
				output ( "done" ) ;
			    }

			output ( "\t--> $server_whois_entries whois entries processed in $host_files_processed files." ) ;
		    }

		output ( "--> $total_whois_entries total whois entries processed in $total_host_files_processed files on " . count ( $hosts ) . " servers." ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisDataFromWWW -
	        Extracts the next local unassigned whois ip ranges from the web.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromWWW ( $count, $separator, $start_ip ) 
	   {
		global		$Database ;


		$ranges		=  find_missing_ranges ( ) ;

		// Find $count missing ranges
		while  ( $count -- )
		   {
			// Extract current missing ranges
			if  ( $start_ip )
			   {
				$range		=  null ;

				foreach  ( $ranges  as  $item )
				   {
					if  ( $start_ip [ 'ip' ]  >=  $item [ 'whoi_ipv4_low' ]  &&  $start_ip [ 'ip' ]  <=  $item [ 'whoi_ipv4_high' ] )
					   {
						$range				=  $item ;
						$range [ 'whoi_ipv4_low' ]	=  $start_ip [ 'ip' ] ;
						$range [ 'whoi_ip_low' ]	=  Convert::IntegerToIpString ( $start_ip [ 'ip' ] ) ;
						break ;
					    }
				    }

				if  ( ! $range )
				   {
					foreach  ( $ranges  as  $item )
					   {
						if  ( $start_ip [ 'ip' ]  <=  $item [ 'whoi_ipv4_low' ] )
						   {
							$range				=  $item ;
							$range [ 'whoi_ipv4_low' ]	=  $start_ip [ 'ip' ] ;
							$range [ 'whoi_ip_low' ]	=  Convert::IntegerToIpString ( $start_ip [ 'ip' ] ) ;
							break ;
						    }
					    }
				    }

				if  ( ! $range )
					error ( "Could not find a free range for ip address {$start_ip [ 'ip-address' ]}" ) ;
			    }
			else
			   {
				$range		=  $ranges [0] ;
			    }

			echo ( "Retrieving {$range [ 'whoi_ip_low' ]} : " ) ;

			$whois_data	=  get_whois_information ( $range [ 'whoi_ip_low' ] ) ;

			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )  ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
			   {
				ExtractWhoisData ( $whois_data, true ) ;
				$ip_range	=  $whois_data [0] -> GetIpRange ( ) ;
				$next_ip	=  ( double ) Convert::IpStringToInteger ( $ip_range [1] ) + 1 ;
				output ( " -> {$ip_range [1]}" ) ;

			    }
			else
			   {
				$next_ip	= scan_unallocated_ips ( ( double ) $range [ 'whoi_ipv4_low' ], 
									 ( double ) $range [ 'whoi_ipv4_high' ], $separator ) + 1 ;
			    }

			$start_ip [ 'ip' ]		=  $next_ip ;
			$start_ip [ 'ip-address' ]	=  Convert::IntegerToIpString ( $next_ip ) ;
		    }
	    }


	/*==============================================================================================================
	
	    ExtractNewIps -
	        Extracts whois data from the ip addresses that have been retrieved by the rslogs script since last run.
	
	  ==============================================================================================================*/
	function  ExtractNewIps ( $separator )
	   {
		global	$Database ;

		// The fastest way to extract new ips is :
		// - to have a subquery that searches every ip in the server_string_store table that have a matching range
		//   in the whois_information table
		// - and an outer query that selects the ips in the server_string_store_table that are NOT in the subquery results
		$query	=  "
				SELECT value
				FROM " . RsAdmin::TABLE_SERVER_STRING_STORE . "
				WHERE
					type = " . LogStringStore::LOGSTORE_IP . " AND 
					value  <>  '::1' AND
					value  <>  'unknown' AND
					value NOT LIKE '127.%' AND
					id NOT IN
					   (
						SELECT id
						FROM  " . RsAdmin::TABLE_SERVER_STRING_STORE . "
						INNER JOIN whois_information ON
							INET_ATON(value) BETWEEN whoi_ipv4_low AND whoi_ipv4_high
						WHERE
							type = " . LogStringStore::LOGSTORE_IP . " AND 
							value  <>  '::1' AND
							value  <>  'unknown' AND
							value NOT LIKE '127.%'
					     ) 
			   " ;
		$Database -> Execute ( $query ) ;
		$ips	=  $Database -> LoadValues ( ) ;

		if  ( $ips )
			ExtractWhoisDataFromIpList ( $ips, $separator ) ;
		else
			output ( "No new ip address to extract." ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisDataFromIpFile -
	        Extracts whois data from a file.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromIpFile ( $file, $separator ) 
	   {
		$lines		=  file ( $file ) ;
		$ips		=  [] ;
		$index		=  0 ;

		foreach  ( $lines  as  $line )
		   {
			$line	=  trim ( $line ) ;
			$index ++ ;

			if  ( ! $line )
				continue ;

			if  ( ! StringUtilities::IsIPAddress ( $line ) )
				error ( "File $file, line #$index : Invalid ip address \"$line\"." ) ;

			$ips []		=  $line ;
		    }

		if  ( ! count ( $ips ) )
			error ( "No ip found in file \"$file\"." ) ;

		ExtractWhoisDataFromIpList ( $ips, $separator ) ;
	    }




	/*==============================================================================================================
	
	    ExtractWhoisDataFromIpList -
	        Extracts whois data from an array of ips.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromIpList ( $ips, $separator ) 
	   {
		$output_file	=  Path::GetVolatileTempFilename ( 'whois.ip', '%f.%p.%s.txt' ) ;
		$file		=  Path::RealPath ( $output_file ) ;
		$whois_lines	=  [] ;
		
		output ( "Retrieving ip information :" ) ;

		foreach  ( $ips  as  $ip )
		   {
			echo ( "$ip..." ) ;

			$whois_lines []		=  "whois $ip\r\n" . WhoisInformation::Get ( $ip ) ;
			output ( "ok" ) ;
		    }

		$text	=  implode ( "\n", $whois_lines ) ;
		
		file_put_contents ( $output_file, $text ) ;
		ExtractWhoisDataFromFile ( $file, $separator ) ;
		unlink ( $file ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisDataFromFile -
	        Extracts whois data from a file.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromFile ( $file, $separator, $verbose = true, $indent = '' ) 
	   {
		if  ( $verbose )
			output ( "{$indent}Getting whois entries from file \"$file\" : " ) ;

		list ( $count, $total )	=  ExtractWhoisDataFromString ( $file, file ( $file ), $separator, $verbose, $indent ) ;

		if  ( $verbose )
			output ( "\n{$indent}--> $count whois queries processed, $total total whois entries" ) ;
	    }


	function  ExtractWhoisDataFromString ( $contents, $separator, $verbose = true, $indent = '' ) 
	   {
		global		$Database, $WhoisStringStore ;

		$parts	=  SplitWhoisData ( $contents, $separator ) ;
		$total	=  0 ;

		foreach  ( $parts  as  $part )
		   {
			try 
			   {
				$whois_data	 =  WhoisInformation::GetInstance ( $part [ 'ip' ], $part [ 'data' ] ) ;
				$total		+=  ExtractWhoisData ( $whois_data, $verbose ) ;
			    }
			// Ignore exceptions thrown when empty contents are retrieved - it may happen that whois returns nothing
			// (maybe because of a netwrok error at the time the command was run)
			catch ( Exception  $e )
			   {
				$message	=  $e -> getMessage ( ) ;

				if  ( strpos ( $message, 'Empty whois information retrieved' )  ===  false )
					throw ( $e ) ;
				else
					warning ( "\n$message" ) ;
			    }
		    }

		return ( [ count ( $parts ), $total ] ) ;
	    }


	function  ExtractWhoisData ( $whois_data, $verbose = true )
	   {
		global		$Database, $WhoisStringStore ;

		// Parse whois data information
		$queried_ip		=  $whois_data -> QueriedIp ;

		// Get buffered table for whois block entries
		$buffer		=  new BufferedInsert
		   (
			'whois_information_block_entries',
			[
				'whoibe_information_id',
				'whoibe_block_id',
				'whoibe_type',
				'whoibe_common_type',
				'whoibe_keyword_id',
				'whoibe_text_id',
				'whoibe_value_id'
			 ],
			8192
		    ) ;

		// No data entry - either 'not found' or something like 'query limit exceeded'
		// Just add this entry, which relates to a single ip, not an ip range.
		// Of course, individual records will have to be joined using the -join_unallocated_ranges option
		// Note that this one-ip range will only be added if no other range contains it
		if  ( ! count ( $whois_data ) )
		   {
			$ip	=  $whois_data -> QueriedIp ;
			$flags	=  WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE | WhoisInformation::WHOIS_FLAGS_PROVIDER ;
			$ipv4	=  Convert::IpStringToInteger ( $ip ) ;

			$query	=  "
					SELECT 1 FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . "
					WHERE
						$ipv4 BETWEEN whoi_ipv4_low AND whoi_ipv4_high
					LIMIT 1
				   " ;
			$Database -> SetSimpleQuery ( $query ) ;
			$status	=  $Database -> LoadValue ( ) ;

			if  ( $status )
				$char	= '?' ;
			else
			   {
				$query	=  "
						INSERT INTO " . RsAdmin::TABLE_WHOIS_INFORMATION . "
						SET
							whoi_ip_low		=  '$ip',
							whoi_ip_high		=  '$ip',
							whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
							whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
							whoi_last_update	=  NOW(),
							whoi_last_whois_update	=  NOW(),
							whoi_flags		=  $flags
					   " ;
				$Database -> Execute ( $query ) ;
				$char	=  '!' ;
			    }

			if  ( $verbose )
			   {
				echo ( $char ) ;
				flush ( ) ;
			    }

			return ( 1 ) ;
		    }

		// Escape whois data for insertion in the database
		$data		=  $Database -> Escape ( $whois_data -> Contents ) ;

		// Add an IPV6 flag if needed 
		if  ( StringUtilities::IsIPV6Address ( $whois_data -> QueriedIp ) )
			$whois_data -> Flags	|=  WhoisInformation::WHOIS_FLAGS_IS_IPV6 ;

		// Loop through ip ranges
		$result		=  0 ;
		$searched_ip	=  $whois_data -> QueriedIp ;

		foreach  ( $whois_data  as  $whois_range )
		   {
			$ip_range	=  $whois_range -> GetIpRange ( ) ;

			// Some fucking AfriNIC entries return the whole address space !
			// In this case use the searched address and make the end address finish with .255
			if  ( $ip_range [0]  ==  '0.0.0.0'  &&  $ip_range [1]  ==  '255.255.255.255' ) 
			   {
				$ipv4_low	=  Convert::IpStringToInteger ( $searched_ip ) ;
				$ipv4_high	=  ( round ( ( ( double ) $ipv4_low ) / 256, 0 ) * 256 ) + 255 ;
				$end_ip		=  Convert::IntegerToIpString ( $ipv4_high ) ;

				$whois_range -> SetIpRange ( $searched_ip, $end_ip ) ;
				$ip_range	=  $whois_range -> GetIpRange ( ) ;
			    }

			// Retrieve all ranges that intersect with this one
			$ip_low		=  Convert::IpStringToInteger ( $ip_range [0] ) ;
			$ip_high	=  Convert::IpStringToInteger ( $ip_range [1] ) ;
			$query		=  "
						SELECT 
							whoi_id,
							whoi_last_update,
							whoi_ip_low,
							whoi_ip_high,
							whoi_ipv4_low,
							whoi_ipv4_high,
							whoi_flags,
							whoi_last_whois_update
						FROM whois_information
						WHERE
							whoi_flags & 1 = 1 AND
							whoi_ipv4_low	=  $ip_low AND
							whoi_ipv4_high	=  $ip_high
						ORDER BY whoi_ipv4_low, whoi_ipv4_high	
						" ;
			$Database -> SetSimpleQuery ( $query ) ;
			$db_range		=  $Database -> LoadRow ( ) ;

			if  ( $db_range )
			   {
				$db_range_flags		=  $db_range [ 'whoi_flags' ] ;
				$this_ip_range		=  [ Convert::IpStringToInteger ( $ip_range [0] ), Convert::IpStringToInteger ( $ip_range [1] ) ] ;
				$db_ip_range		=  [ ( double ) $db_range [ 'whoi_ipv4_low' ], ( double ) $db_range [ 'whoi_ipv4_high' ] ] ;


				if  ( ( $db_range_flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )  ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
				   {
					if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )  ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
					   {
						if  ( $this_ip_range [0]  ==  $db_ip_range [0]  &&  $this_ip_range [1]  ==  $db_ip_range [1] ) 
						   {
							$status		=  dbreplace_whois_entry ( $ip_range, $buffer, $whois_data, $whois_range, $db_range ) ;
							$char		=  ( $status ) ?  'u' : 'U' ;
						    }
						else
						   {
							dbadd_whois_entry ( $ip_range, $buffer, $whois_data, $whois_range ) ;
							$char	=  'A' ;
						    }
					    }
					else
					   {
						dump ( $this_ip_range ) ;
						dump ( $db_ip_range ) ;
						dump ( $db_ranges ) ;
						error ( "UNHANDLED CASE : searched whois entry does not exist" ) ;
					    }
				    }
				else
				   {
					dump ( $this_ip_range ) ;
					dump ( $db_ip_range ) ;
					dump ( $db_ranges ) ;
					error ( "UNHANDLED CASE : found whois entry is marked as non-existent in the local database" ) ;
				    }
			    }
			else
			   {
				dbadd_whois_entry ( $ip_range, $buffer, $whois_data, $whois_range ) ;
				$char	=  'a' ;
			    }

			if  ( $verbose )
			   {
				echo ( $char ) ;
				flush ( ) ;
			    }

			$result ++ ;
		    }

		return ( $result ) ;
	    }




	/*==============================================================================================================
	
	    JoinUnallocatedRanges -
	        Joins unallocated consecutive ranges.
	
	  ==============================================================================================================*/
	function  JoinUnallocatedRanges ( )
	   {
		global		$Database ;

		$table				=  RsAdmin::TABLE_WHOIS_INFORMATION ;
		$flags				=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
		$query				=  "
							SELECT 
								whoi_id		AS 'id', 
								whoi_ipv4_low	AS 'low', 
								whoi_ipv4_high  AS 'high' 
							FROM $table
							WHERE
								whoi_flags & $flags = $flags
							ORDER BY whoi_ipv4_low, whoi_ipv4_high
						   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$unallocated_ranges		=  $Database -> LoadAllRows ( true ) ;
		$unallocated_range_count	=  count ( $unallocated_ranges ) ;
		$joined_ranges			=  [] ;
		
		// Collect consecutive ranges to be merged
		for ( $i = 1 ; $i  <  $unallocated_range_count ; $i ++ )
		   {
			$joined		=  false ;
			$joined_range	=
			   [
				'ids'		=>  [ $unallocated_ranges [$i-1] [ 'id' ] ],
				'low'		=>  $unallocated_ranges [$i-1] [ 'low' ],
				'high'		=>  $unallocated_ranges [$i-1] [ 'high' ],
			    ] ;

			while  ( $i  <  $unallocated_range_count  &&  $unallocated_ranges [$i] [ 'low' ]  ==  $joined_range [ 'high' ] + 1 )
			   {
				$joined_range [ 'high' ]	=  $unallocated_ranges [$i] [ 'high' ] ;
				$joined_range [ 'ids' ] []	=  $unallocated_ranges [$i] [ 'id' ] ;
				$joined				=  true ;
				$i ++ ;
			    }

			if  ( $joined )
				$joined_ranges []	=  $joined_range ;
		    }

		// Loop through collected ranges
		$report		=  new AsciiReport
		   (
			[ 'member' => 'low'  , 'title' => 'Low'    ],
			[ 'member' => 'high' , 'title' => 'High'   ],
			[ 'member' => 'count', 'title' => 'Merged' ]
		    ) ;
		$data		=  [] ;

		foreach  ( $joined_ranges  as  $joined_range )
		   {
			// Insert first the new range before deleting the existing ones
			$query		=  "
						INSERT INTO $table
						SET
							whoi_last_update	=  NOW(),
							whoi_ip_low		=  INET_NTOA( '{$joined_range [ 'low' ]}'  ),
							whoi_ip_high		=  INET_NTOA( '{$joined_range [ 'high' ]}' ),
							whoi_flags		=  $flags,
							whoi_ipv4_low		=  {$joined_range [ 'low' ]},
							whoi_ipv4_high		=  {$joined_range [ 'high' ]}
					   " ;
			$Database -> Execute ( $query ) ;

			// Then delete the merged ranges
			$query		=  "
						DELETE FROM $table
						WHERE
							whoi_id IN 
							   (" .
								implode ( ', ', $joined_range [ 'ids' ] ) .
							    ")
					   " ;
			$Database -> Execute ( $query ) ;

			$data []	=  
			   [ 
				'low'	=>  Convert::IntegerToIpString ( $joined_range [ 'low' ] ),
				'high'	=>  Convert::IntegerToIpString ( $joined_range [ 'high' ] ),
				'count'	=>  count ( $joined_range [ 'ids' ] )
			    ] ;
		    }

		output ( "Merged ranges summary :" ) ;
		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'joined range' ) ;
	    }


	/*==============================================================================================================
	
	    ListMissingRanges -
	        Lists the missing ip ranges from the local whois database.
	
	  ==============================================================================================================*/
	function  ListMissingRanges ( $count )
	   {
		$missing	=  find_missing_ranges ( $count ) ;
		$report		=  new AsciiReport
		   (
			[ 'member' => 'whoi_ip_low'	, 'title' => 'Low'	, 'align' => 'left'	],
			[ 'member' => 'whoi_ip_high'	, 'title' => 'High'	, 'align' => 'left'	],
			[ 'member' => 'count'		, 'title' => 'Count'	, 'align' => 'right'	]
		    ) ;
		 $data		=  [] ;
		 $total		=  0 ;

		 foreach  ( $missing  as  $item )
		    {
			$range		=  $item [ 'whoi_ipv4_high' ] - $item [ 'whoi_ipv4_low' ] + 1 ;
			$total         +=  $range ;
			$data []	= 
			   [
				'whoi_ip_low'	=> $item [ 'whoi_ip_low' ],
				'whoi_ip_high'	=> $item [ 'whoi_ip_high' ],
				'count'		=> number_format ( $range, 0, '.', ' ' )
			    ] ;
		     }

		$data []	=  '!=' ;
		$data []	=  [ 'whoi_ip_low' => 'Total :', 'whoi_ip_high' => '', 'count' => number_format ( $total, 0, '.', ' ' ) ] ;

		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'ip range', false, false, 1 ) ;
	    }


	/*==============================================================================================================
	
	    ListAllocationStatistics -
	        Lists ip allocation statistics.
	
	  ==============================================================================================================*/
	function  ListAllocationStatistics ( )
	   {
		global		$Database ;

		$query		=  "
					SELECT
						(
							SELECT COUNT(*)
							FROM whois_information
							WHERE
								whoi_flags = 1
						 ) AS 'allocated_ranges',
						(
							SELECT COUNT(*)
							FROM whois_information
							WHERE
								whoi_flags <> 1
						 ) AS 'unallocated_ranges',
						(
							SELECT SUM(whoi_ipv4_high - whoi_ipv4_low + 1)
							FROM whois_information
							WHERE
								whoi_flags = 1
						 ) AS 'allocated_ips',
						(
							SELECT SUM(whoi_ipv4_high - whoi_ipv4_low + 1)
							FROM whois_information
							WHERE
								whoi_flags <>  1
						 ) AS 'unallocated_ips'
				   " ;
		$Database -> SetSimpleQuery ( $query ) ;
		$row		=  $Database -> LoadRow ( ) ;

		$report		=  new AsciiReport
		   (
			[ 'member' => 'type'	, 'title' => 'Type'				],
			[ 'member' => 'ranges'	, 'title' => 'Ranges'	, 'align' => 'right'	],
			[ 'member' => 'ips'	, 'title' => 'Ips'	, 'align' => 'right'	]
		    ) ;

		$data		=
		   [
			[ 
				'type'		=> 'Allocated', 
				'ranges'	=>  number_format ( $row [ 'allocated_ranges' ], 0, '.', ' ' ),
				'ips'		=>  number_format ( $row [ 'allocated_ips' ], 0, '.', ' ' )
			 ],
			[ 
				'type'		=> 'Unallocated', 
				'ranges'	=>  number_format ( $row [ 'unallocated_ranges' ], 0, '.', ' ' ),
				'ips'		=>  number_format ( $row [ 'unallocated_ips' ], 0, '.', ' ' )
			 ]
		    ] ;

		echo $report -> Generate ( $data ) ;
	    }


	/*==============================================================================================================
	
	    ListCountries -
	        Lists the countries referenced in the whois databases, together with the number of assigned address
		ranges and ip addresses
	
	  ==============================================================================================================*/
	function  ListCountries ( )
	   {
		global		$Database, $TLDList ;

		$query		=  "
					SELECT 
						whoi_country AS 'country',
						COUNT(*) AS 'ranges',
						SUM( whoi_ipv4_high - whoi_ipv4_low + 1 ) AS 'count'	
					FROM whois_information
					WHERE
						whoi_country  <>  '' AND
						whoi_flags & " . WhoisInformation::WHOIS_FLAGS_SERVER_MASK . ' = ' . WhoisInformation::WHOIS_FLAGS_SERVER_FOUND . "
					GROUP BY whoi_country
					ORDER BY whoi_country
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;
		$report		=  new AsciiReport
		   (
			[ 'member' => 'country', 'title' => 'CC'				],
			[ 'member' => 'name'   , 'title' => 'Country'				],
			[ 'member' => 'ranges' , 'title' => '#Ranges'	, 'align' => 'right'	],
			[ 'member' => 'count'  , 'title' => '#Ips'	, 'align' => 'right'	]
		    ) ;

		foreach  ( $rows  as  $row )
		   {
			$data []	=
			   [
				'country'		=>  $row [ 'country' ],
				'name'			=>  $TLDList [ $row [ 'country' ] ] -> Entity,
				'ranges'		=>  number_format ( $row [ 'ranges' ], 0, '.', ' ' ),
				'count'			=>  number_format ( $row [ 'count' ], 0, '.', ' ' )
			    ] ;
		    }

		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'country' ) ;
	    }


	/*==============================================================================================================
	
	    ListKeywords -
	        Lists the keywords found in the supplied file, together with their number of occurrences.
	
	  ==============================================================================================================*/
	function  ListKeywords ( )
	   {
		global		$Database ;

		$query		=  "
					SELECT value, COUNT(*) AS 'count'
					FROM whois_information_block_entries
					LEFT JOIN whois_string_store ON
						id = whoibe_keyword_id 
					GROUP BY whoibe_keyword_id
					ORDER BY value				
				   " ;
		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;

		$report		=  new AsciiReport
		   (
			[ 'member'	=>  'value' , 'title' => 'Keyword' ],
			[ 'member'	=>  'count', 'count' => 'Count' ] 
		    ) ;

		echo $report -> Generate ( $rows ) ;
		echo $report -> Summary ( 'keyword' ) ;
	    }


	/*==============================================================================================================
	
	    ListIpReferences -
	        Lists all the rows that include the specified ip.
	
	  ==============================================================================================================*/
	function  ListIpReferences ( $ip )
	   {
		global		$Database ;

		// Retrieve all the rows that may include one of the ips
		$query	=  "
				SELECT 
					whoi_last_update,
					whoi_ip_low,
					whoi_ip_high,
					whoi_flags,
					whoi_country,
					whoi_last_whois_update
				FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				WHERE
					{$ip [ 'ip' ]} BETWEEN whoi_ipv4_low AND whoi_ipv4_high
			   " ;
		$Database -> SetSimpleQuery ( $query ) ;
		$rows	=  $Database -> LoadRows ( ) ;

		if  ( count ( $rows ) )
			echo report_ips ( $rows, "Ip ranges for {$ip [ 'ip-address' ]} :", 'ip range' ) ;
		else
			output ( "Ip {$ip [ 'ip-address' ]} is not referenced in the local database." ) ;
	   }


	/*==============================================================================================================
	
	    Split -
	        Splits whois information.
	
	  ==============================================================================================================*/
	function  SplitWhoisData ( $lines, $separator )
	   {
		$line_count	=  count ( $lines ) ;
		$parts		=  [] ;
		$part		=  [] ;
		$ip		=  '' ;
		$index		=  0 ;

		for  ( $i = 0 ; $i  <  $line_count ; $i ++ )
		   {
			$line	=  $lines [$i] ;

			if  ( preg_match ( $separator, $line ) )
			   {
				$index	=  $i ;
				break ;
			    }
		    }

		for  ( $i = $index ; $i  <  $line_count ; $i ++ )
		   {
			$line	=  rtrim ( $lines [$i] ) ;

			if  ( preg_match ( $separator, $line, $match ) )
			   {
				if  ( count ( $part ) )
				   {
					$ipv4			=  Convert::IpStringToInteger ( $ip ) ;
					$parts [ $ipv4 ]	=  [ 'ip' => $ip, 'data' => implode ( "\n", $part ) ] ;
					$part			=  [] ;
					$ip			=  $match [ 'ip' ] ;
				    }
				else
					$ip			=  $match [ 'ip' ] ;
			    }
			else
				$part []	=  $line ;
		    }

		if  ( count ( $part ) )
		   {
			$ipv4			=  Convert::IpStringToInteger ( $ip ) ;
			$parts [ $ipv4 ]	=  [ 'ip' => $ip, 'data' => implode ( "\r\n", $part ) ] ;
		    }

		return ( $parts ) ;
	    }


	/*==================================================================================================

		Global constants and variables.

	  ==================================================================================================*/
	define ( 'MIN_IP'	,  0x00000000 ) ;
	define ( 'MAX_IP'	,  0xFFFFFFFF ) ;

	$CL 				=  new CLParser ( $Definitions ) ;
	$AddUnallocatedRange		=  $CL -> add_unallocated_range ;
	$Collect			=  $CL -> collect ;
	$ConfigurationFile		=  $CL -> configuration_file ;
	$ExtractNewIps			=  $CL -> extract_new_ips ;
	$JoinUnallocatedRanges		=  $CL -> join_unallocated_ranges ;
	$KeepFiles			=  $CL -> keep_files ;
	$Limit				=  $CL -> limit ;
	$ListAllocationStatistics	=  $CL -> list_allocation_statistics ;
	$ListConfiguredServers		=  $CL -> list_configured_servers ;
	$ListCountries			=  $CL -> list_countries ;
	$ListKeywords			=  $CL -> list_keywords ;
	$ListMissingRanges		=  $CL -> list_missing_ranges ;
	$ListIpReferences		=  $CL -> list_ip_references ;
	$Next				=  $CL -> next ;
	$ServerPath			=  $CL -> server_path ;
	$Servers			=  $CL -> servers ;
	$SortBy				=  $CL -> sort_by ; 
	$StartIp			=  $CL -> start_ip ;
	$WhoisDataFile			=  $CL -> whois_data_file ;
	$WhoisIpFile			=  $CL -> whois_ip_file ;
	$WhoisIps			=  $CL -> whois_ips ;

	$RsAdmin			=  new RsAdmin ( $ConfigurationFile ) ;
	$ServerList			=  $RsAdmin -> FindServers ( $Servers ) ;
	$HadOption			=  false ;
	$Separator			=  '/^whois \s+ (?P<ip> [0-9a-f:\-.]+)/imsx' ;
	$WhoisStringStore		=  new  StringStore ( 'whois_string_store', 'String store for whois data information', 16384, 32 ) ;
	$TLDList			=  new  TLDList ( ) ;
	$TryAddresses			=  [ 8, 16, 32, 48, 64, 96, 128, 160, 192, 224, 240 ] ;


	// -whois_data_file option :
	//	Extracts whois data from the specified file.
	if  ( ! $HadOption  &&  $WhoisDataFile )
	   {
		ExtractWhoisDataFromFile ( $WhoisDataFile, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -whois_ip_file option :
	//	Extracts whois data from the ip addresses in the specified file.
	if  ( ! $HadOption  &&  $WhoisIpFile )
	   {
		ExtractWhoisDataFromIpFile ( $WhoisIpFile, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -whois_ips option :
	//	Extracts whois data from the specified ip addresses.
	if  ( ! $HadOption  &&  $WhoisIps )
	   {
		$ips		=  ArrayHelpers::ExtractValues ( $WhoisIps, 'ip-address' ) ;
		ExtractWhoisDataFromIpList ( $ips, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -collect option :
	//	Retrieves whois data collected by remote servers.
	if  ( ! $HadOption  &&  $Collect )
	   {
		CollectFiles ( $ServerList, $ServerPath, $KeepFiles ) ;	
		$HadOption	=  true ;
	    }


	// -add_unallocated_range :
	//	Add an unallocated IP range to the database.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'add_unallocated_range' ) )
	   {
		AddUnallocatedRange ( $AddUnallocatedRange ) ;
		$HadOption	=  true ;
	    }

	// -extract_new_ips :
	//	Extracts whois data for the ips that have been retrieved by rslogs since the last run.
	if  ( ! $HadOption  &&  $ExtractNewIps )
	   {
		ExtractNewIps ( $Separator ) ;
		$HadOption	=  true ;
	    }

	// -next :
	//	Extracts the specified number of whois entries from the remote whois databases.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'next' ) )
	   {
		ExtractWhoisDataFromWWW ( $Next, $Separator, $StartIp ) ;
		$HadOption	=  true ;
	    }

	// -join_unallocated_ranges :
	//	Joins unallocated ranges.
	if  ( ! $HadOption  &&  $JoinUnallocatedRanges )
	   {
		JoinUnallocatedRanges ( ) ;
		$HadOption	=  true ;
	    }

	// -list_allocation_statistics option :
	//	Lists Ip allocation statistics.
	if  ( ! $HadOption  &&  $ListAllocationStatistics )
	   {
		ListAllocationStatistics ( ) ;
		$HadOption	=  true ;
	    }

	// -list_countries option :
	//	Lists the countries defined in the whois database, together with their number of assigned ranges and ip addresses.
	if  ( ! $HadOption  &&  $ListCountries )
	   {
		ListCountries ( ) ;
		$HadOption	=  true ;
	    }

	// -list_keywords option :
	//	Lists all the available keywords found in the supplied input file, together with their occurrence count.
	if  ( ! $HadOption  &&  $ListKeywords )
	   {
		ListKeywords ( ) ;
		$HadOption	=  true ;
	    }

	// -list_missing_ranges :
	//	Lists the ip ranges that are missing from the local whois database.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'list_missing_ranges' ) )
	   {
		ListMissingRanges ( $ListMissingRanges ) ;
		$HadOption	=  true ;
	    }

	// -list_ip_references :
	//	Lists all the rows that include the specified ip.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'list_ip_references' ) )
	   {
		ListIpReferences ( $ListIpReferences ) ;
		$HadOption	=  true ;
	    }

	// -list_configured_servers :
	//	Lists the servers configured for this command.
	if  ( ! $HadOption  &&  $ListConfiguredServers ) 
	   {
		$RsAdmin -> ListServers ( ) ;
		$HadOption	=  true ;
	    }

	// Reset whois tables
	if  ( $CL -> rebuild_unscanned_ips )
	   {
		rebuild_unscanned_ips ( ) ;	
		$HadOption	=  true ;
		exit ;
	    }
	
	// Provide a default option if nothing specified
	if  ( ! $HadOption )
		ListMissingRanges ( PHP_INT_MAX ) ;
