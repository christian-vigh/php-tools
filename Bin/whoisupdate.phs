<?php
	//!phpcmd(Administration, 1.0, production) : Collects whois information.
	/**************************************************************************************************************
	
	    NAME
	        whoisupdate.phs
	
	    DESCRIPTION
	        Collects whois information.
	
	    AUTHOR
	        Christian Vigh, 07/2015.
	
	    HISTORY
	    [Version : 1.0]	[Date : 2015/07/31]     [Author : CV]
	        Initial version.

	    (... a bunch of intermediate versions)

	    [Version : 1.1]	[Date : 2015/09/24]     [Author : CV]
		. When searching for an ip address whose LSB is zero, if a range of 0.0.0.0 - 255.255.255.255 is found,
		  then only a 256-addresses range will be allocated.

	    [Version : 1.1.0]	[Date : 2015/09/26]     [Author : CV]
		. Added the whois_missing_ranges table, that holds the last computed missing ranges
		. Added the whois_variables table, which hold the following 
		. Added the following parameters

	 **************************************************************************************************************/
	require ( "tools.phpinclude" ) ;

	use  Thrak\Processors\CL\CLParser ;
	use  Thrak\Types\String ;
	use  Thrak\Types\String\Convert ;
	use  Thrak\Types\ArrayHelpers ;
	use  Thrak\IO\Console ;
	use  Thrak\IO\Path ;
	use  Thrak\IO\AsciiReport ;
	use  Thrak\Processors\WhoisInformation ;
	use  Thrak\Database\BufferedInsert ;
	use  Thrak\Database\Tables\StringStore ;
	use  Thrak\Internet\TLDList ;
	use  Thrak\System\Timer ;


	require ( "RsAdmin.phpclass" ) ;


	/*==============================================================================================================
	
	        Command-line definition.
	
	  ==============================================================================================================*/
	$Definitions = <<<END
<command>

	<usage>
		Collects whois information.
	</usage>

	<ip-address name="add_unallocated_range, aur" arguments="2..2">
		Adds an unallocated ip range.
	</ip-address>

	<flag name="benchmark, b">
		Benchmarks some functions used internally.
	</flag> 

	<flag name="extract_new_ips, eni, x">
		Updates the whois database with the new ips coming from the server_string_store table.
	</flag>

	<unsigned name="limit, l" min-value="1">
		Defines the maximum number of records to be displayed.
		To be used with the -list_xxx options.
	</unsigned>

	<flag name="find_parents, fp">
		For each record in the local whois database, searches for a parent entry that includes this ip range,
		and updates the parent id column accordingly.
	</flag>
		
	<flag name="list_allocation_statistics, las">
		Lists statistics about ip address allocations (allocated/unallocated, range count, ip count).
	</flag>

	<flag name="list_countries, lc">
		Lists the countries referenced in the whois database, together with the number of ip ranges
		allocated, and the number of ip addresses.
	</flag>

	<ip-address name="list_ip_references, lir">
		Lists all the rows that include the specified ip address.
	</ip-address>

	<flag name="list_keywords, lk">
		Lists all the possible keywords found in the input file.
	</flag>

	<unsigned name="list_missing_ranges, lmr" min-value="1" default="<?= PHP_INT_MAX ?>">
		Lists the ip ranges that are absent from the local whois database.
	</unsigned>

	<unsigned name="next, n" min-value="1" default="1">
		Extract the specified number of whois ip ranges from the remote whois databases.
	</unsigned>

	<string name="sort_by, sb">
		Defines sort options by field name, optionally followed by "ASC" or "DESC".
		Field names depend on the -list_xxx option specified.
	</string>

	<ip-address name="start_ip, si">
		Ip address that serves as a starting point for range extraction (-next option).
	</ip-address>

	<flag name="use_missing_ranges, umr">
		Use the whois_missing_ranges tables, which is updated after each run, instead of recomputing
		the missing ranges upon each invocation.
		This option can be used if no other instance of whoisupdate is running, or when the range to
		process is known to be unaffected.
	</flag>

	<file name="whois_data_file, wdf, wd">
		A data file containing one or more whois data outputs, preceded by the whois command that extracted 
		the information.
	</file>

	<file name="whois_ip_file, wif">
		A data file containing ip addresses. The whois command will be run for each address specified.
	</file>

	<ip-address name="whois_ips, whois_ip, wi" address-type="ipv4" arguments="1..*">
		A list of ip addresses. The whois command will be run for each address specified.
	</ip-address>

</command>
END;

	/*==============================================================================================================
	
	        Helper functions.
	
	  ==============================================================================================================*/

	// add_whois_data -
	//	Adds whois data to the database.
	function  add_whois_data ( $ip, $whois_data, $separator )
	   {
		$command	=  "whois $ip" ;
		$output		=  Path::GetVolatileTempFilename ( 'whois', '%f.%p.%s.txt' ) ;
		file_put_contents ( $output, "$command\n{$whois_data -> Contents}" ) ;
		ExtractWhoisData ( $output, $separator, false ) ;
		unlink ( $output ) ;
	    }


	// find_missing_ranges -
	//	Finds the missing ranges in the local whois database.
	//	The naive implementation (a nested loop to collect input ranges after having checked that they are not included
	//	in the existing collected range array) has been abandoned : with a count of 20000 input ranges, this could yield
	//	to 400M loop cycles.
	//	Finding the missing ranges has been divided into 4 steps (the numbers given below have been extracted from a
	//	22000-rows data set) :
	//	1) Query the rows, eliminating those having the same low boundary, and keeping only the highest max boundary.
	//	   This eliminates 10% of the rows coming from the database (from 22000 to 20000).
	//	2) Merge adjacent ranges, ie when high boundary + 1 of range #1 is equal to low boundary of range #n+1.
	//	   This allows for reducing range count from 20000 to 1350 in the example data set.
	//	3) In the remaining ranges, only retain those that are not subranges of anybody. This is the most expensive part
	//	   of the process (complexity is O(n2)).
	//	   In the example data set, this reduced the number of ranges from 1350 to 320.
	//	4) Find disjoint intervals in the remaining ranges. Note that at this step, adjacent ranges may still be found !
	function  __create_range ( $ipv4_low, $ipv4_high )
	   {
		$ip_low		=  Convert::IntegerToIpString ( $ipv4_low ) ;
		$ip_high	=  Convert::IntegerToIpString ( $ipv4_high ) ;

		$range	=
		   [
			'whoi_ip_low'		=>  $ip_low,
			'whoi_ip_high'		=>  $ip_high,
			'whoi_ipv4_low'		=>  $ipv4_low,
			'whoi_ipv4_high'	=>  $ipv4_high
		    ] ;

		return ( $range ) ;
	    }


	function  find_missing_ranges ( $count = PHP_INT_MAX )
	   {
		global		$Database, $Benchmark, $UseMissingRanges ;


		// Use the whois_missing_ranges table, instead of recomputing the missing ranges, if the
		// -use_missing_ranges option has been specified.
		if  ( $UseMissingRanges )
		   {
			$query		=  "
						SELECT
							whomr_ip_low			AS 'whoi_ipv4_low',
							whomr_ip_high			AS 'whoi_ipv4_high',
							INET_NTOA( whomr_ip_low )	AS 'whoi_ip_low',
							INET_NTOA( whomr_ip_high )	AS 'whoi_ip_high'
						FROM " . RsAdmin::TABLE_WHOIS_MISSING_RANGES . "
						ORDER BY whomr_ip_low
					   " ;

			$Database -> SetQuery ( $query ) ;
			$missing_ranges		=  $Database -> LoadRows ( ) ;

			return ( $missing_ranges ) ;
		    }

		$timer = new Timer ( ) ;
		$timer -> AddCustomColumn ( [ 'member' => 'count', 'title' => 'Count', 'align' => 'right' ] ) ;

		$timer -> Start ( 'find_missing_ranges()', [ 'count' => '-' ] ) ;

		// Retrieve all ranges. Eliminate ranges that have the same low boundary, keeping only the one having the
		// maximum high boundary ; for example, [1,100], [1,200] and [1,20] will yield to [1,200]
		// On the example data set, this reduced the row count from 22000 records to 20000 (10%).
		$query		=  "
					SELECT 
						whoi_ipv4_low AS 'low',
						MAX(whoi_ipv4_high) AS 'high'
					FROM whois_information
					WHERE
						whoi_parent_id = 0
					GROUP BY whoi_ipv4_low
					ORDER BY whoi_ipv4_low, whoi_ipv4_high
				   " ;

		// We will directly use direct mysqli calls since the $Database methods are not performant on thousand of rows
		$Database -> SetQuery ( $query ) ;
	
		$sql_ranges		=  $Database -> LoadAllRows ( ) ;
		$sql_range_count	=  count ( $sql_ranges ) ;

		$timer -> Step ( 'Load ip ranges', [ 'count' => number_format ( $sql_range_count, 0, '.', ' ' ) ] ) ;

		// Now reduce range count by merging adjacent ranges.
		// On the example data set, this reduced the range count from 20000 to 1350.
		$joined_ranges		=  array_fill ( 0, $sql_range_count, 0 ) ;

		$last_range		=  $sql_ranges [0] ;
		$last_range		=  [ 'low' => ( double ) $last_range [0], 'high' => ( double ) $last_range [0] ] ;

		$joined_ranges [0]	=  $last_range ;
		$current_index		=  0 ;

		for  ( $i = 1 ; $i  <  $sql_range_count ; $i ++ )
		   {
			$low	=  ( double ) $sql_ranges [$i] [0] ;
			$high	=  ( double ) $sql_ranges [$i] [1] ;

			if  ( $last_range [ 'high' ] + 1  ==  $low )
			   {
				$joined_ranges [ $current_index ] [ 'high' ]	=  
				$last_range [ 'high' ]				=  $high ;
			    }
			else
			   {
				$last_range					=  [ 'low' => $low, 'high' => $high ] ;
				$joined_ranges [ ++ $current_index ]		=  $last_range ;
			    }
		    }

		$timer -> Step ( 'Join adjacent ranges', [ 'count' => number_format ( $current_index + 1, 0, '.', ' ' ) ] ) ;

		// In the remaining ranges, keep only the ranges that are not subranges of anybody.
		// This is the most expensive step and its performance is O(n2).
		// On the test data set, this reduced the number of ranges from 1350 to 320.
		$reduced_ranges		=  [] ;

		for  ( $i = 0 ; $i  <=  $current_index ; $i ++ )
		   {
			$joined_range	=  $joined_ranges [$i] ;
			$add_range	=  true ;

			foreach  ( $reduced_ranges  as  $reduced_range )
			   {
				if  ( $joined_range [ 'low' ]   >=  $reduced_range [ 'low' ]  &&  $joined_range [ 'low' ]   <=  $reduced_range [ 'high' ]  &&
				      $joined_range [ 'high' ]  >=  $reduced_range [ 'low' ]  &&  $joined_range [ 'high' ]  <=  $reduced_range [ 'high' ] )
				   {
					$add_range	=  false ;
					break ;
				    }
			    }

			if  ( $add_range )
				$reduced_ranges []	=  $joined_range ;
		    }

		$timer -> Step ( 'Remove subranges', [ 'count' => number_format ( count ( $reduced_ranges ), 0, '.', ' ' ) ] ) ;

		// The final step is to extract the intervals between two consecutive ranges.
		$missing_ranges		=  [] ;
		$reduced_count		=  count ( $reduced_ranges ) ;

		// Check if there is a first empty range
		if  ( $reduced_ranges [0] [ 'low' ]  >  MIN_IP )
			$missing_ranges []	=  __create_range ( MIN_IP, $reduced_ranges [0] [ 'low' ] - 1 ) ;

		// Loop through all the ranges that have been reduced
		for  ( $i = 1 ; $i  <  $reduced_count ; $i ++ )
		   {
			$reduced_range_1  =  $reduced_ranges [$i-1] ;
			$reduced_range_2  =  $reduced_ranges [$i] ;

			// Keep in mind that there may still remain adjacent ranges
			if  ( $reduced_range_1 [ 'high' ] + 1  <  $reduced_range_2 [ 'low' ] )
				$missing_ranges []	=  __create_range ( $reduced_range_1 [ 'high' ] + 1, $reduced_range_2 [ 'low' ] - 1 ) ;
		    }

		// Check if there is a last range to add
		$start  =  $reduced_ranges [ count ( $reduced_ranges ) - 1 ] [ 'high' ] + 1 ;

		if  ( $start  <  MAX_IP )
			$missing_ranges []	=  __create_range ( $start, MAX_IP ) ;

		$timer -> Step ( 'Find missing ranges', [ 'count' => number_format ( count ( $missing_ranges ), 0, '.', ' ' ) ] ) ;
		$timer -> Stop ( 'Stop', [ 'count' => '-' ] ) ;

		if  ( $Benchmark )
			echo $timer -> Report ( ) ;

		// Save missing ranges
		$Database -> Execute ( "TRUNCATE TABLE " . RsAdmin::TABLE_WHOIS_MISSING_RANGES ) ;

		foreach (  $missing_ranges  as  $missing_range )
		   {
			$query	=  "
					INSERT INTO " . RsAdmin::TABLE_WHOIS_MISSING_RANGES . "
					SET
						whomr_ip_low	=  {$missing_range [ 'whoi_ipv4_low' ]},
						whomr_ip_high	=  {$missing_range [ 'whoi_ipv4_high' ]}
				   " ;

			$Database -> Execute ( $query ) ;
		    }

		// All done, return
		return ( $missing_ranges ) ;
	    }


	// get_list_options -
	//	Returns an ORDER BY and a LIMIT clauses, depending on the -sort_by and -limit options
	function  get_list_options ( $option, $sort_fields )
	   {
		global		$SortBy, $Limit ;

		$limit		=  '' ;
		$sort_by	=  '' ;

		if  ( $Limit )
			$limit	=  "LIMIT $limit" ;

		if  ( $SortBy )
		   {
			$field_strings		=  explode ( ',', $SortBy ) ;
			$fields			=  [] ;

			foreach  ( $field_strings  as  $field_string )
			   {
				if  ( preg_match ( '/^ (?P<field> [^\s]) \s+ ASC $/imsx', $field_string, $match ) )
				   {
					$fields []	=  $match [ 'field' ] . ' ASC' ;
					$field_name	=  $match [ 'field' ] ;
				    }
				else if  ( preg_match ( '/^ (?P<field> [^\s]) \s+ DESC $/imsx', $field_string, $match ) )
				   {
					$fields []	=  $match [ 'field' ] . ' DESC' ;
					$field_name	=  $match [ 'field' ] ;
				    }
				else
				   {
					$fields []	=  $field_string ;
					$field_name	=  $field_string ;
				    }

				$found	=  false ;

				foreach ( $sort_fields  as  $sort_field ) 
				   {
					if  ( ! strcasecmp ( $sort_field, $field_name ) )
					   {
						$found		=  true ; 
						break ;
					    }
				    }

				if  ( ! $found )
					error ( "Field \"$field_name\" is not defined for option $option." ) ;
			    }

			$sort_by	=  'ORDER BY ' . implode ( ', ', $fields ) ;
		    }

		return ( [ $sort_by, $limit ] ) ;
	    }


	// get_whois_information -
	//	Gets whois information for the specified ip and returns a WhoisInformation object.
	function  get_whois_information ( $ip )
	   {
		static		$error_results	=
		   [
			'connect: Connection timed out',
			'fgets: Connection reset by peer',
			'Timeout.',
			'Timeout!!',
			'Cannot currently process your search request',
			'Query rate limit exceeded',
			'Connection reset by peer'
		    ] ;

		$data		=  null ;
		$output		=  Path::GetVolatileTempFilename ( 'whois.www', '%f.%p.%s.txt' ) ;	
		$real_output	=  Path::ToUnix ( Path::RealPath ( $output ) ) ;
		$command	=  "whois $ip >$real_output 2>&1" ;

ShootAgain:
		system ( $command ) ;

		$data		=  trim ( file_get_contents ( $output ) ) ;
		$referral_index	=  stripos ( $data, 'Found a referral to' ) ;
		$shootagain	=  false ;

		if  ( stripos ( $data, 'NetRange:' )  ===  false  &&  stripos ( $data, 'inetnum:' )  ===  false ) 
		   {
			foreach  ( $error_results  as  $error_result )
			   {
				$index	=  stripos ( $data, $error_result ) ;

				if  ( $index  !==  false )
				   {
					if  ( $referral_index  !==  false )
					   {
						if  ( $index  <  $referral_index )
						   {
							$shootagain	=  true ;
							break ;
						    }
					    }
					else
					   {
						$shootagain	=  true ;
						break ;
					    }
				    }
			    }
		    }

		if  ( $shootagain )
		   {
			sleep ( 3 ) ;
			echo ( '.' ) ;
			goto  ShootAgain ;
		    }

		if  ( $referral_index )
			$data	=  substr ( $data, 0, $referral_index ) ;

		$whois_data	=  WhoisInformation::GetInstance ( $ip, $data ) ;
		unlink ( $real_output ) ;

		return ( $whois_data ) ;
	    }


	// report_ips -
	//	Provides a standardized way to report an ip range list.
	function  report_ips ( $rows, $title, $summary = null )
	   {
		$report		=  new AsciiReport 
		   (
			[ 'member' => 'iplow'	, 'title' => 'Low ip'	, 'align' => 'left'	],
			[ 'member' => 'iphigh'	, 'title' => 'High ip'	, 'align' => 'left'	],
			[ 'member' => 'country'	, 'title' => 'Country'				],
			[ 'member' => 'provider', 'title' => 'P'				],
			[ 'member' => 'type'	, 'title' => 'Type'				],
			[ 'member' => 'status'	, 'title' => 'Status'				],
			[ 'member' => 'wupdate'	, 'title' => 'Whois update'			],
			[ 'member' => 'lupdate'	, 'title' => 'Local update'			]
		    ) ;
		$data		=  [] ;

		foreach  ( $rows  as  $row )
		   {
			$flags		=  $row [ 'whoi_flags' ] ;
			$provider	=  ( $flags & WhoisInformation::WHOIS_FLAGS_PROVIDER ) ?  '*' : '' ;
			$type		=  '?' ;
			$server		=  '?' ;

			switch ( $flags & WhoisInformation::WHOIS_FLAGS_TYPE_MASK )
			   {
				case	WhoisInformation::WHOIS_FLAGS_IS_IPV4			: $type = 'Ip v4'  ; break ;
				case	WhoisInformation::WHOIS_FLAGS_IS_IPV6			: $type = 'Ip v6'  ; break ;
				case	WhoisInformation::WHOIS_FLAGS_ISDOMAIN			: $type = 'Domain' ; break ;
			    }

			switch ( $flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )
			   {
				case	WhoisInformation::WHOIS_FLAGS_SERVER_FOUND		:  $server =  'Ok'	    ; break ;
				case	WhoisInformation::WHOIS_FLAGS_SERVER_NOT_FOUND		:  $server =  'Not found'   ; break ;
				case	WhoisInformation::WHOIS_FLAGS_SERVER_REFUSED_QUERY	:  $server =  'Query later' ; break ;
				case	WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE		:  $server =  'Unallocated' ; break ;
			    }

			$data []	=
			   [
				'iplow'		=>  $row [ 'whoi_ip_low' ],
				'iphigh'	=>  $row [ 'whoi_ip_high' ],
				'country'	=>  $row [ 'whoi_country' ],
				'provider'	=>  $provider,
				'type'		=>  $type,
				'status'	=>  $server,
				'wupdate'	=>  $row [ 'whoi_last_whois_update' ],
				'lupdate'	=>  $row [ 'whoi_last_update' ]
			    ] ;
		   }

		$result		=  "$title\n" .
				   $report -> Generate ( $data ) ;

		if  ( $summary ) 
			$result		.=  $report -> Summary ( $summary ) ;

		return ( $result ) ;
	    }


	// try_predefined_ips -
	//	When a scan for unallocated ranges starts with an ip address ending with 0, this function is called
	//	to check specific addresses such as xx.xx.xx.128, .160, .190 etc.
	//	If none of those addresses are allocated, then we can assume without too many risk that the whole
	//	range 0..255 is unallocated
	function  try_predefined_ips ( $ip )
	   {
		global		$TryAddresses ;


		$ip	=  (double ) $ip ;

		foreach  ( $TryAddresses  as  $try_ip )
		   {
			echo ( "$try_ip " ) ;

			$try_ip		=  round ( ( double ) ( ( $ip / 256 ) * 256 ) ) + ( double ) $try_ip ;
			$try_ip_string	=  Convert::IntegerToIpString ( $try_ip ) ;

			$whois_data	=  get_whois_information ( $try_ip_string ) ;

			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK ) ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
				return ( true ) ;
		    }

		return ( false ) ;
	    }


	// scan_unallocated_ips - 
	//	Finds the first unallocated ip range. Tries by blocks of 256 addresses.
	function  scan_unallocated_ips ( $low, $high, $separator )
	   {
		global		$Database ;

		output ( "\n\tScan from " . Convert::IntegerToIpString ( $low ) . " to " . Convert::IntegerToIpString ( $high ) . ' (' .
				number_format ( $high - $low + 1, 0, '.', ' ' ) . ' addresses)' ) ;

		$low			=  ( double ) $low ;
		$high			=  ( double ) $high ;
		$current		=  $low ;
		$count			=  $low & 0xFF ;


		while  ( $current  <=  $high  &&  $count  <  256 )
		   {
			$ip		=  Convert::IntegerToIpString ( $current ) ;
			echo ( "\t\tTrying $ip.." ) ;

			$whois_data	=  get_whois_information ( $ip ) ;

	
			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK ) !=  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
			   {
				if  ( ! ( $current & 0xFF ) )
				   {
					echo ( "trying predefined ips : " ) ;
					$found_data		=  try_predefined_ips ( $current ) ;

					if  ( ! $found_data )
					   {
						$current	 =  round ( ( $current / 256 ) * 256 ) + 256 ;
						$last		 =  $current ;
						output ( '-> unallocated' ) ;
						break ;
					    }
				    }
			    }
			else
			   {
				add_whois_data ( $ip, $whois_data, $separator ) ;
				output ( "done" ) ;

				if  ( $current  !=  $low )
				   {
					$last		=  $current - 1 ;

					if  ( $last  <  $low )
						$last	=  $low ;

					$low_ip		=  Convert::IntegerToIpString ( $low ) ;
					$high_ip	=  Convert::IntegerToIpString ( $last ) ;
					$flags		=  $whois_data -> Flags | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
					$query		=  "
								INSERT INTO whois_information
								SET
									whoi_last_update	=  NOW(),
									whoi_last_whois_update  =  NOW(),
									whoi_ip_low		=  '$low_ip',
									whoi_ip_high		=  '$high_ip',
									whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
									whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
									whoi_flags		=  $flags,
									whoi_country		=  ''
							   " ;
					
					$Database -> Execute ( $query ) ;
					output ( "\t\tUnallocated range : $low_ip - $high_ip" ) ;
				    }


				break ;
			    }
			
			output ( "unallocated" ) ;

			$current ++ ;
			$count ++ ;
		    }

		if  ( $current  >  $low )
		   {
			$last		=  $current - 1 ;
			$low_ip		=  Convert::IntegerToIpString ( $low ) ;
			$high_ip	=  Convert::IntegerToIpString ( $last ) ;
			$flags		=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
			$query		=  "
						INSERT IGNORE INTO whois_information
						SET
							whoi_last_update	=  NOW(),
							whoi_last_whois_update  =  NOW(),
							whoi_ip_low		=  '$low_ip',
							whoi_ip_high		=  '$high_ip',
							whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
							whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
							whoi_flags		=  $flags,
							whoi_country		=  ''
					   " ;
					
			$Database -> Execute ( $query ) ;
			output ( "\tUnallocated range : $low_ip - $high_ip" ) ;
		    }
		else
			$last	=  $current ; 

		return ( $last ) ;
	    }


	/*==============================================================================================================
	
	    AddUnallocatedRange -
	        Add an unallocated IP range.
	
	  ==============================================================================================================*/
	function  AddUnallocatedRange ( $range )
	   {
		global		$Database ;


		$iplow		=  $range [0] [ 'ip' ] ;
		$iphigh		=  $range [1] [ 'ip' ] ;

		// Check that ip high >=  ip low
		if  ( $iplow  >  $iphigh )
			error ( "Low ip is greater than high ip." ) ;

		// Ask for a confirmation if range is wider that 256 addresses
		$width		=  $iphigh - $iplow + 1 ;

		if  ( $width  >  256 )
		   {
			$answer		=  Console::Prompt ( "Warning: address range covers $width addresses ; do you want to continue ? ", 
								[ 'y', 'n' ], 'y' ) ;

			if  ( strtolower ( $answer )  !=  'y' ) 
			   {
				output ( "cancelled." ) ;
				return ;
			    }
		    }

		// Retrieve all the rows that may include one of the ips
		$query	=  "
				SELECT *
				FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				WHERE
					$iplow  BETWEEN whoi_ipv4_low AND whoi_ipv4_high OR
					$iphigh BETWEEN whoi_ipv4_low AND whoi_ipv4_high 
			   " ;
		
		$Database -> SetQuery ( $query ) ;
		$Database -> Query ( ) ;
		$rows	=  $Database -> LoadRows ( ) ;

		// If existing ranges are found, exit
		if  ( count ( $rows ) )
		   {
			echo report_ips ( $rows,
				"The following ranges already cover ip range {$range [0] [ 'ip-address' ]} - {$range [1] [ 'ip-address' ]} :" ) ;
			output ( "Operation cancelled." ) ;

		    }

		// Range does not exist ; add it as an unallocated ip range
		$flags	=  WhoisInformation::WHOIS_FLAGS_PROVIDER | WhoisInformation::WHOIS_FLAGS_UNALLOCATED_RANGE ;
		$query	=  "
				INSERT INTO " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				SET
					whoi_ip_low		=  '{$range [0] [ 'ip-address' ]}',
					whoi_ip_high		=  '{$range [1] [ 'ip-address' ]}',
					whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
					whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
					whoi_last_update	=  NOW(),
					whoi_last_whois_update	=  NOW(),
					whoi_flags		=  $flags
			   " ;
		$Database -> Execute ( $query ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisDataFromWWW -
	        Extracts the next local unassigned whois ip ranges from the web.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromWWW ( $count, $separator, $start_ip ) 
	   {
		global		$Database ;


		$ranges		=  find_missing_ranges ( ) ;

		// Find $count missing ranges
		while  ( $count -- )
		   {
			// Extract current missing ranges
			if  ( $start_ip )
			   {
				$range		=  null ;

				foreach  ( $ranges  as  $item )
				   {
					if  ( $start_ip [ 'ip' ]  >=  $item [ 'whoi_ipv4_low' ]  &&  $start_ip [ 'ip' ]  <=  $item [ 'whoi_ipv4_high' ] )
					   {
						$range				=  $item ;
						$range [ 'whoi_ipv4_low' ]	=  $start_ip [ 'ip' ] ;
						$range [ 'whoi_ip_low' ]	=  Convert::IntegerToIpString ( $start_ip [ 'ip' ] ) ;
						break ;
					    }
				    }

				if  ( ! $range )
				   {
					foreach  ( $ranges  as  $item )
					   {
						if  ( $start_ip [ 'ip' ]  <=  $item [ 'whoi_ipv4_low' ] )
						   {
							$range				=  $item ;
							$range [ 'whoi_ipv4_low' ]	=  $start_ip [ 'ip' ] ;
							$range [ 'whoi_ip_low' ]	=  Convert::IntegerToIpString ( $start_ip [ 'ip' ] ) ;
							break ;
						    }
					    }
				    }

				if  ( ! $range )
					error ( "Could not find a free range for ip address {$start_ip [ 'ip-address' ]}" ) ;
			    }
			else
			   {
				$range		=  $ranges [0] ;
			    }

			echo ( "Retrieving {$range [ 'whoi_ip_low' ]} : " ) ;

			$whois_data	=  get_whois_information ( $range [ 'whoi_ip_low' ] ) ;

			if  ( ( $whois_data -> Flags & WhoisInformation::WHOIS_FLAGS_SERVER_MASK )  ==  WhoisInformation::WHOIS_FLAGS_SERVER_FOUND )
			   {
				$command	=  'whois ' . $range [ 'whoi_ip_low' ] ;
				$output		=  Path::GetVolatileTempFilename ( 'whois.www', '%f.%p.%s.txt' ) ;
				file_put_contents ( $output, "$command\n{$whois_data -> Contents}" ) ;

				$next_ip	=  ExtractWhoisData ( $output, $separator, true, $start_ip [ 'ip-address' ] ) ;
				unlink ( $output ) ;

				$ip_range	=  $whois_data [0] -> GetIpRange ( ) ;

				// Some fucking AfriNIC entries return the whole address space !
				// In this case use the specified start address and make the end address finish with .255
				if  ( $ip_range [0]  ==  '0.0.0.0'  &&  $ip_range [1]  ==  '255.255.255.255' ) 
				   {
					$ipv4_low	=  Convert::IpStringToInteger ( $start_ip [ 'ip-address' ] ) ;
					$ipv4_high	=  ( round ( ( ( double ) $ipv4_low ) / 256, 0 ) * 256 ) + 255 ;
					$ip_range [1]	=  Convert::IntegerToIpString ( $ipv4_high ) ;
				    }

				$next_ip	=  ( double ) Convert::IpStringToInteger ( $ip_range [1] ) + 1 ;
				output ( " -> {$ip_range [1]}" ) ;

			    }
			else
			   {
				$next_ip	= scan_unallocated_ips ( ( double ) $range [ 'whoi_ipv4_low' ], 
									 ( double ) $range [ 'whoi_ipv4_high' ], $separator ) + 1 ;
			    }

			$start_ip [ 'ip' ]		=  $next_ip ;
			$start_ip [ 'ip-address' ]	=  Convert::IntegerToIpString ( $next_ip ) ;
		    }
	    }


	/*==============================================================================================================
	
	    ExtractNewIps -
	        Extracts whois data from the ip addresses that have been retrieved by the rslogs script since last run.
	
	  ==============================================================================================================*/
	function  ExtractNewIps ( $separator )
	   {
		global	$Database ;

		// The fastest way to extract new ips is :
		// - to have a subquery that searches every ip in the server_string_store table that have a matching range
		//   in the whois_information table
		// - and an outer query that selects the ips in the server_string_store_table that are NOT in the subquery results
		$query	=  "
				SELECT value
				FROM " . RsAdmin::TABLE_SERVER_STRING_STORE . "
				WHERE
					type = " . LogStringStore::LOGSTORE_IP . " AND 
					value  <>  '::1' AND
					value  <>  'unknown' AND
					value NOT LIKE '127.%' AND
					id NOT IN
					   (
						SELECT id
						FROM  " . RsAdmin::TABLE_SERVER_STRING_STORE . "
						INNER JOIN whois_information ON
							INET_ATON(value) BETWEEN whoi_ipv4_low AND whoi_ipv4_high
						WHERE
							type = " . LogStringStore::LOGSTORE_IP . " AND 
							value  <>  '::1' AND
							value  <>  'unknown' AND
							value NOT LIKE '127.%'
					     ) 
			   " ;
		$Database -> Execute ( $query ) ;
		$ips	=  $Database -> LoadValues ( ) ;

		if  ( $ips )
			ExtractWhoisDataFromIpList ( $ips, $separator ) ;
		else
			output ( "No new ip address to extract." ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisDataFromIpFile -
	        Extracts whois data from a file.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromIpFile ( $file, $separator ) 
	   {
		$lines		=  file ( $file ) ;
		$ips		=  [] ;
		$index		=  0 ;

		foreach  ( $lines  as  $line )
		   {
			$line	=  trim ( $line ) ;
			$index ++ ;

			if  ( ! $line )
				continue ;

			if  ( ! String::IsIPAddress ( $line ) )
				error ( "File $file, line #$index : Invalid ip address \"$line\"." ) ;

			$ips []		=  $line ;
		    }

		if  ( ! count ( $ips ) )
			error ( "No ip found in file \"$file\"." ) ;

		ExtractWhoisDataFromIpList ( $ips, $separator ) ;
	    }




	/*==============================================================================================================
	
	    ExtractWhoisDataFromIpList -
	        Extracts whois data from an array of ips.
	
	  ==============================================================================================================*/
	function  ExtractWhoisDataFromIpList ( $ips, $separator ) 
	   {
		$output_file	=  Path::GetVolatileTempFilename ( 'whois.ip', '%f.%p.%s.txt' ) ;
		$file		=  Path::RealPath ( $output_file ) ;
		$whois_lines	=  [] ;
		
		output ( "Retrieving ip information :" ) ;

		foreach  ( $ips  as  $ip )
		   {
			echo ( "$ip..." ) ;

			$whois_lines []		=  "whois $ip\r\n" . WhoisInformation::Get ( $ip ) ;
			output ( "ok" ) ;
		    }

		$text	=  implode ( "\n", $whois_lines ) ;
		
		file_put_contents ( $output_file, $text ) ;
		ExtractWhoisData ( $file, $separator ) ;
		unlink ( $file ) ;
	    }


	/*==============================================================================================================
	
	    ExtractWhoisData -
	        Extracts whois data from a file.
	
	  ==============================================================================================================*/
	function  ExtractWhoisData ( $file, $separator, $verbose = true, $start_ip = null ) 
	   {
		global		$Database, $WhoisStringStore ;


		$parts			=  SplitWhoisData ( file ( $file ), $separator ) ;
		$entry_buffer		=  new BufferedInsert
		   (
			'whois_information_block_entries',
			[
				'whoibe_information_id',
				'whoibe_block_id',
				'whoibe_type',
				'whoibe_common_type',
				'whoibe_keyword_id',
				'whoibe_text_id',
				'whoibe_value_id'
			 ],
			8192
		    ) ;

		// Loop through whois data input
		foreach  ( $parts  as  $part )
		   {
			// Parse whois data information
			$whois_data	=  WhoisInformation::GetInstance ( $part [ 'ip' ], $part [ 'data' ] ) ;

			$data		=  $Database -> Escape ( $part [ 'data' ] ) ;
			$flags		=  $whois_data -> Flags ;

			if  ( String::IsIPV6Address ( $part [ 'ip' ] ) )
				$flags	|=  WhoisInformation::WHOIS_FLAGS_IS_IPV6 ;

			// No data entry - either 'not found' or something like 'query limit exceeded'
			if  ( ! count ( $whois_data ) )
				continue ;

			// Loop through ip ranges
			foreach  ( $whois_data  as  $range )
			   {
				$ip_range	=  $range -> GetIpRange ( ) ;

				// Some fucking AfriNIC entries return the whole address space !
				// In this case use the specified start address and make the end address finish with .255
				if  ( $ip_range [0]  ==  '0.0.0.0'  &&  $ip_range [1]  ==  '255.255.255.255' ) 
				   {
					if  ( $start_ip )
					   {
						$ipv4_low	=  Convert::IpStringToInteger ( $start_ip ) ;
						$ipv4_high	=  ( round ( ( ( double ) $ipv4_low ) / 256, 0 ) * 256 ) + 255 ;
						$end_ip		=  Convert::IntegerToIpString ( $ipv4_high ) ;

						$range -> SetIpRange ( $start_ip, $end_ip ) ;
					   }
					else
						error ( "Found range 0.0.0.0 - 255.255.255.255 but not substitute ip specified !" ) ;
				    }

				$ip_range	=  $range -> GetIpRange ( ) ;

				// Check if this range already exists
				$query		=  "
							SELECT  
								whoi_id, 
								whoi_last_update
							FROM whois_information
							WHERE 
								whoi_ipv4_low	=  INET_ATON( '{$ip_range [0]}' ) AND
								whoi_ipv4_high	=  INET_ATON( '{$ip_range [1]}' )
						   " ;
				$Database -> SetSimpleQuery ( $query ) ;
				$row		=  $Database -> LoadRow ( ) ;

				// Update database if no such ip range has been found or if its last update time is older than the time
				// specified with the -update_time parameter is older than the entry
				if  ( ! $row )
				   {
					$id	=  $row [ 'whoi_id' ] ;

					// If a row has been found, it must be outdated, so delete it
					if  ( $row ) 
					    {
						$Database -> Execute ( "DELETE FROM whois_information WHERE whoi_id = $id" ) ;
						$Database -> Execute ( "DELETE FROM whois_information_blocks WHERE whoib_information_id = $id" ) ;
						$Database -> Execute ( "DELETE FROM whois_information_block_entries WHERE whoibe_information_id = $id" ) ;

						$char	=  'D' ;
					     }
					else
						$char	=  '.' ;
					

					// Insert record into the whois_information table
					$country	=  $range -> GetCountry ( ) ;
					$update_time	=  $range -> GetUpdateTime ( ) ;

					if  ( $update_time )
						$last_update	=  "'" . date ( 'Y-m-d H:i:s', $update_time ) . "'" ;
					else
						$last_update	=  'NOW()' ; 

					$query		=  "
								INSERT INTO whois_information
								SET
									whoi_last_update	=  NOW(),
									whoi_last_whois_update	=  $last_update,
									whoi_ip_low		=  '{$ip_range [0]}',
									whoi_ip_high		=  '{$ip_range [1]}',
									whoi_ipv4_low		=  INET_ATON( whoi_ip_low ),
									whoi_ipv4_high		=  INET_ATON( whoi_ip_high ),
									whoi_flags		=  $flags,
									whoi_country		=  '$country',
									whoi_text		=  '$data'
							   " ;
					$Database -> Execute ( $query ) ;
					$information_id			=  $Database -> GetLastInsertId ( ) ;

					// Find if this range has a whois parent entry
					$query	=  "
							SELECT whoi_id
							FROM whois_information
							WHERE
								INET_ATON( '{$ip_range [0]}' ) > whoi_ipv4_low AND INET_ATON( '{$ip_range [0]}' ) < whoi_ipv4_high AND
								INET_ATON( '{$ip_range [1]}' ) > whoi_ipv4_low AND INET_ATON( '{$ip_range [1]}' ) < whoi_ipv4_high
							ORDER BY whoi_ipv4_low, whoi_ipv4_high
							LIMIT 1
						   " ;

					$Database -> SetSimpleQuery ( $query ) ;
					$outer	=  $Database -> LoadRow ( ) ;

					if  ( $outer )
					   {
						$query	=  "
								UPDATE whois_information
								SET
									whoi_parent_id = {$outer [ 'whoi_id' ]}
								WHERE
									whoi_id = $information_id
							   " ;
						$Database -> Execute ( $query ) ;
					     }


					// Insert records into the whois_information_blocks table
					foreach  ( $range  as  $block )
					   {
						$query	=  "
								INSERT INTO whois_information_blocks
								SET
									whoib_information_id	=  $information_id,
									whoib_type		=  {$block -> Type}
							   " ;

						$Database -> Execute ( $query ) ;
						$block_id	=  $Database -> GetLastInsertId ( ) ;

						foreach  ( $block  as  $entry )
						   {
							$keyword_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_KEYWORD, $entry -> Keyword ) ;
							$text_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_TEXT, $entry -> Text ) ;
							$value_id	=  $WhoisStringStore -> Insert ( WhoisInformation::WHOIS_STRING_STORE_VALUE, 
											serialize ( $entry -> Value ) ) ;

							// Insert records into the whois_information_block_entries table
							$status = $entry_buffer -> Add
							   ([
									'whoibe_information_id'	=>  $information_id,
									'whoibe_block_id'	=>  $block_id,
									'whoibe_type'		=>  $entry -> Type,
									'whoibe_common_type'	=>  $entry -> CommonType,
									'whoibe_keyword_id'	=>  $keyword_id,
									'whoibe_text_id'	=>  $text_id,
									'whoibe_value_id'	=>  $value_id
							     ]) ;

							if  ( $status  &&  $verbose )
								echo ( '!' ) ;
						    }
					    }
			
					if  ( $verbose ) 
						echo ( $char ) ;
				    }
				else
				   {
					if  ( $verbose )
						echo ( 'x' ) ;
				    }
			    }

			$entry_buffer -> Flush ( ) ;
		    }
	    }


	/*==============================================================================================================
	
	    FindParents -
	        For each row in the local whois database, tries to find if there is a parent row, ie a row whose ip range
		englobes the ip range of the current row.
	
	  ==============================================================================================================*/
	function  FindParents ( )
	   {
		global	$Database ;

		// Reset the parent id column
		$Database -> Execute (  "UPDATE whois_information SET whoi_parent_id = 0" ) ;

		// Select all rows from the local database
		$query	=  "
				SELECT 
					whoi_id,
					whoi_ip_low,
					whoi_ip_high,
					whoi_ipv4_low AS 'low',
					whoi_ipv4_high AS 'high'
				FROM whois_information
				WHERE
					whoi_flags = 1
			   " ;
		$Database -> SetQuery ( $query ) ;
		$rows  =  $Database -> LoadRows ( ) ;

		// Loop through the retrieved rows
		foreach  ( $rows  as  $row )
		   {
			$low	=  $row [ 'low' ] ;
			$high	=  $row [ 'high' ] ;

			// Search for an englobing ip range
			$query	=  "
					SELECT whoi_id
					FROM whois_information
					WHERE
						$low > whoi_ipv4_low AND $low < whoi_ipv4_high AND
						$high > whoi_ipv4_low AND $high < whoi_ipv4_high
					ORDER BY whoi_ipv4_low, whoi_ipv4_high
					LIMIT 1
				   " ;

			$Database -> SetSimpleQuery ( $query ) ;
			$outer	=  $Database -> LoadRow ( ) ;

			// If found, then set the parent id column for this row
			if  ( $outer )
			   {
				$query	=  "
						UPDATE whois_information
						SET
							whoi_parent_id = {$outer [ 'whoi_id' ]}
						WHERE
							whoi_id = {$row [ 'whoi_id' ]}
					   " ;
				$Database -> Execute ( $query ) ;
				echo '.' ;
			    }
			else
				echo 'x' ;
		     }

	    }


	/*==============================================================================================================
	
	    ListMissingRanges -
	        Lists the missing ip ranges from the local whois database.
	
	  ==============================================================================================================*/
	function  ListMissingRanges ( $count )
	   {
		$missing	=  find_missing_ranges ( $count ) ;
		$report		=  new AsciiReport
		   (
			[ 'member' => 'whoi_ip_low'	, 'title' => 'Low'	, 'align' => 'left'	],
			[ 'member' => 'whoi_ip_high'	, 'title' => 'High'	, 'align' => 'left'	],
			[ 'member' => 'count'		, 'title' => 'Count'	, 'align' => 'right'	]
		    ) ;
		 $data		=  [] ;
		 $total		=  0 ;

		 foreach  ( $missing  as  $item )
		    {
			$range		=  $item [ 'whoi_ipv4_high' ] - $item [ 'whoi_ipv4_low' ] + 1 ;
			$total         +=  $range ;
			$data []	= 
			   [
				'whoi_ip_low'	=> $item [ 'whoi_ip_low' ],
				'whoi_ip_high'	=> $item [ 'whoi_ip_high' ],
				'count'		=> number_format ( $range, 0, '.', ' ' )
			    ] ;
		     }

		$data []	=  '!=' ;
		$data []	=  [ 'whoi_ip_low' => 'Total :', 'whoi_ip_high' => '', 'count' => number_format ( $total, 0, '.', ' ' ) ] ;

		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'ip range', false, false, 1 ) ;
	    }


	/*==============================================================================================================
	
	    ListAllocationStatistics -
	        Lists ip allocation statistics.
	
	  ==============================================================================================================*/
	function  ListAllocationStatistics ( )
	   {
		global		$Database ;

		$query		=  "
					SELECT
						(
							SELECT COUNT(*)
							FROM whois_information
							WHERE
								whoi_flags = 1 AND
								whoi_parent_id = 0
						 ) AS 'allocated_ranges',
						(
							SELECT COUNT(*)
							FROM whois_information
							WHERE
								whoi_flags <> 1
						 ) AS 'unallocated_ranges',
						(
							SELECT SUM(whoi_ipv4_high - whoi_ipv4_low + 1)
							FROM whois_information
							WHERE
								whoi_flags = 1 AND
								whoi_parent_id = 0
						 ) AS 'allocated_ips',
						(
							SELECT SUM(whoi_ipv4_high - whoi_ipv4_low + 1)
							FROM whois_information
							WHERE
								whoi_flags <>  1
						 ) AS 'unallocated_ips'
				   " ;
		$Database -> SetSimpleQuery ( $query ) ;
		$row		=  $Database -> LoadRow ( ) ;

		$report		=  new AsciiReport
		   (
			[ 'member' => 'type'	, 'title' => 'Type'				],
			[ 'member' => 'ranges'	, 'title' => 'Ranges'	, 'align' => 'right'	],
			[ 'member' => 'ips'	, 'title' => 'Ips'	, 'align' => 'right'	]
		    ) ;

		$data		=
		   [
			[ 
				'type'		=> 'Allocated', 
				'ranges'	=>  number_format ( $row [ 'allocated_ranges' ], 0, '.', ' ' ),
				'ips'		=>  number_format ( $row [ 'allocated_ips' ], 0, '.', ' ' )
			 ],
			[ 
				'type'		=> 'Unallocated', 
				'ranges'	=>  number_format ( $row [ 'unallocated_ranges' ], 0, '.', ' ' ),
				'ips'		=>  number_format ( $row [ 'unallocated_ips' ], 0, '.', ' ' )
			 ]
		    ] ;

		echo $report -> Generate ( $data ) ;
	    }


	/*==============================================================================================================
	
	    ListCountries -
	        Lists the countries referenced in the whois databases, together with the number of assigned address
		ranges and ip addresses
	
	  ==============================================================================================================*/
	function  ListCountries ( )
	   {
		global		$Database, $TLDList ;

		$query		=  "
					SELECT 
						whoi_country AS 'country',
						COUNT(*) AS 'ranges',
						SUM( whoi_ipv4_high - whoi_ipv4_low + 1 ) AS 'count'	
					FROM whois_information
					WHERE
						whoi_country  <>  '' AND
						whoi_flags & " . WhoisInformation::WHOIS_FLAGS_SERVER_MASK . ' = ' . WhoisInformation::WHOIS_FLAGS_SERVER_FOUND . "
					GROUP BY whoi_country
					ORDER BY whoi_country
				   " ;

		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;
		$data		=  [] ;
		$report		=  new AsciiReport
		   (
			[ 'member' => 'country', 'title' => 'CC'				],
			[ 'member' => 'name'   , 'title' => 'Country'				],
			[ 'member' => 'ranges' , 'title' => '#Ranges'	, 'align' => 'right'	],
			[ 'member' => 'count'  , 'title' => '#Ips'	, 'align' => 'right'	]
		    ) ;

		foreach  ( $rows  as  $row )
		   {
			$data []	=
			   [
				'country'		=>  $row [ 'country' ],
				'name'			=>  $TLDList [ $row [ 'country' ] ] -> Entity,
				'ranges'		=>  number_format ( $row [ 'ranges' ], 0, '.', ' ' ),
				'count'			=>  number_format ( $row [ 'count' ], 0, '.', ' ' )
			    ] ;
		    }

		echo $report -> Generate ( $data ) ;
		echo $report -> Summary ( 'country' ) ;
	    }


	/*==============================================================================================================
	
	    ListKeywords -
	        Lists the keywords found in the supplied file, together with their number of occurrences.
	
	  ==============================================================================================================*/
	function  ListKeywords ( )
	   {
		global		$Database ;

		$query		=  "
					SELECT value, COUNT(*) AS 'count'
					FROM whois_information_block_entries
					LEFT JOIN whois_string_store ON
						id = whoibe_keyword_id 
					GROUP BY whoibe_keyword_id
					ORDER BY value				
				   " ;
		$Database -> SetSimpleQuery ( $query ) ;
		$rows		=  $Database -> LoadRows ( ) ;

		$report		=  new AsciiReport
		   (
			[ 'member'	=>  'value' , 'title' => 'Keyword' ],
			[ 'member'	=>  'count', 'count' => 'Count' ] 
		    ) ;

		echo $report -> Generate ( $rows ) ;
		echo $report -> Summary ( 'keyword' ) ;
	    }


	/*==============================================================================================================
	
	    ListIpReferences -
	        Lists all the rows that include the specified ip.
	
	  ==============================================================================================================*/
	function  ListIpReferences ( $ip )
	   {
		global		$Database ;

		// Retrieve all the rows that may include one of the ips
		$query	=  "
				SELECT 
					whoi_last_update,
					whoi_ip_low,
					whoi_ip_high,
					whoi_flags,
					whoi_country,
					whoi_last_whois_update
				FROM " . RsAdmin::TABLE_WHOIS_INFORMATION . "
				WHERE
					{$ip [ 'ip' ]} BETWEEN whoi_ipv4_low AND whoi_ipv4_high
			   " ;
		$Database -> SetQuery ( $query ) ;
		$rows	=  $Database -> LoadRows ( ) ;

		if  ( count ( $rows ) )
			echo report_ips ( $rows, "Ip ranges for {$ip [ 'ip-address' ]} :", 'ip range' ) ;
		else
			output ( "Ip {$ip [ 'ip-address' ]} is not referenced in the local database." ) ;
	   }


	/*==============================================================================================================
	
	    Split -
	        Splits whois information.
	
	  ==============================================================================================================*/
	function  SplitWhoisData ( $lines, $separator )
	   {
		$line_count	=  count ( $lines ) ;
		$parts		=  [] ;
		$part		=  [] ;
		$ip		=  '' ;
		$index		=  0 ;

		for  ( $i = 0 ; $i  <  $line_count ; $i ++ )
		   {
			$line	=  $lines [$i] ;

			if  ( preg_match ( $separator, $line ) )
			   {
				$index	=  $i ;
				break ;
			    }
		    }

		for  ( $i = $index ; $i  <  $line_count ; $i ++ )
		   {
			$line	=  rtrim ( $lines [$i] ) ;

			if  ( preg_match ( $separator, $line, $match ) )
			   {
				if  ( count ( $part ) )
				   {
					$parts []	=  [ 'ip' => $ip, 'data' => implode ( "\n", $part ) ] ;
					$part		=  [] ;
					$ip		=  $match [ 'ip' ] ;
				    }
				else
					$ip		=  $match [ 'ip' ] ;
			    }
			else
				$part []	=  $line ;
		    }

		if  ( count ( $part ) )
			$parts []	=  [ 'ip' => $ip, 'data' => implode ( "\r\n", $part ) ] ;

		return ( $parts ) ;
	    }


	/*==================================================================================================

		Global constants and variables.

	  ==================================================================================================*/
	define ( 'MIN_IP'	,  0x00000000 ) ;
	define ( 'MAX_IP'	,  0xFFFFFFFF ) ;

	$CL 				=  new CLParser ( $Definitions ) ;
	$AddUnallocatedRange		=  $CL -> add_unallocated_range ;
	$Benchmark			=  $CL -> benchmark ;
	$ExtractNewIps			=  $CL -> extract_new_ips ;
	$FindParents			=  $CL -> find_parents ;
	$Limit				=  $CL -> Limit ;
	$ListAllocationStatistics	=  $CL -> list_allocation_statistics ;
	$ListCountries			=  $CL -> list_countries ;
	$ListKeywords			=  $CL -> list_keywords ;
	$ListMissingRanges		=  $CL -> list_missing_ranges ;
	$ListIpReferences		=  $CL -> list_ip_references ;
	$Next				=  $CL -> next ;
	$SortBy				=  $CL -> sort_by ; 
	$StartIp			=  $CL -> start_ip ;
	$UseMissingRanges		=  $CL -> use_missing_ranges ;
	$WhoisDataFile			=  $CL -> whois_data_file ;
	$WhoisIpFile			=  $CL -> whois_ip_file ;
	$WhoisIps			=  $CL -> whois_ips ;

	$HadOption			=  false ;
	$Separator			=  '/^whois \s+ (?P<ip> [0-9a-f:\-.]+)/imsx' ;
	$WhoisStringStore		=  new  StringStore ( 'whois_string_store', 'String store for whois data information', 16384, 32 ) ;
	$TLDList			=  new  TLDList ( ) ;
	$TryAddresses			=  [ 8, 16, 32, 64, 128, 160, 192, 224, 240 ] ;


	// -whois_data_file option :
	//	Extracts whois data from the specified file.
	if  ( ! $HadOption  &&  $WhoisDataFile )
	   {
		ExtractWhoisData ( $WhoisDataFile, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -whois_ip_file option :
	//	Extracts whois data from the ip addresses in the specified file.
	if  ( ! $HadOption  &&  $WhoisIpFile )
	   {
		ExtractWhoisDataFromIpFile ( $WhoisIpFile, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -whois_ips option :
	//	Extracts whois data from the specified ip addresses.
	if  ( ! $HadOption  &&  $WhoisIps )
	   {
		$ips		=  ArrayHelpers::ExtractValues ( $WhoisIps, 'ip-address' ) ;
		ExtractWhoisDataFromIpList ( $ips, $Separator ) ;
		$HadOption	=  true ;
	    }

	// -add_unallocated_range :
	//	Add an unallocated IP range to the database.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'add_unallocated_range' ) )
	   {
		AddUnallocatedRange ( $AddUnallocatedRange ) ;
		$HadOption	=  true ;
	    }

	// -extract_new_ips :
	//	Extracts whois data for the ips that have been retrieved by rslogs since the last run.
	if  ( ! $HadOption  &&  $ExtractNewIps )
	   {
		ExtractNewIps ( $Separator ) ;
		$HadOption	=  true ;
	    }

	// -find_parents :
	//	For each record in the local whois database, searches for a parent entry that includes this ip range,
	//	and updates the parent id column accordingly.
	if  ( ! $HadOption  &&  $FindParents )
	   {
		FindParents ( ) ;
		$HadOption	=  true ;
	    }

	// -next :
	//	Extracts the specified number of whois entries from the remote whois databases.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'next' ) )
	   {
		ExtractWhoisDataFromWWW ( $Next, $Separator, $StartIp ) ;
		$HadOption	=  true ;
	    }

	// -list_allocation_statistics option :
	//	Lists Ip allocation statistics.
	if  ( ! $HadOption  &&  $ListAllocationStatistics )
	   {
		ListAllocationStatistics ( ) ;
		$HadOption	=  true ;
	    }

	// -list_countries option :
	//	Lists the countries defined in the whois database, together with their number of assigned ranges and ip addresses.
	if  ( ! $HadOption  &&  $ListCountries )
	   {
		ListCountries ( ) ;
		$HadOption	=  true ;
	    }

	// -list_keywords option :
	//	Lists all the available keywords found in the supplied input file, together with their occurrence count.
	if  ( ! $HadOption  &&  $ListKeywords )
	   {
		ListKeywords ( ) ;
		$HadOption	=  true ;
	    }

	// -list_missing_ranges :
	//	Lists the ip ranges that are missing from the local whois database.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'list_missing_ranges' ) )
	   {
		ListMissingRanges ( $ListMissingRanges ) ;
		$HadOption	=  true ;
	    }

	// -list_ip_references :
	//	Lists all the rows that include the specified ip.
	if  ( ! $HadOption  &&  $CL -> IsSpecified ( 'list_ip_references' ) )
	   {
		ListIpReferences ( $ListIpReferences ) ;
		$HadOption	=  true ;
	    }

	// Provide a default option if nothing specified
	if  ( ! $HadOption )
		ListMissingRanges ( PHP_INT_MAX ) ;
