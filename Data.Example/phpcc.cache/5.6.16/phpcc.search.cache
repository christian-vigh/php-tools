0:1:Minor changes
0:2:1:1:[core]
1:2:	repositoryformatversion = 0
1:3:	filemode = true
1:4:	bare = false
1:5:	logallrefupdates = true
1:6:	ignorecase = true
1:7:[branch "master"]
1:8:[credential]
1:9:	helper = store
1:10:[remote "vroom"]
1:11:	url = https://github.com/christian-vigh/vroom
1:12:	fetch = +refs/heads/*:refs/remotes/vroom/*
1:13:2:1:Unnamed repository; edit this file 'description' to name the repository.
2:2:3:1:ref: refs/heads/master
3:2:4:1:#!/bin/sh
4:2:#
4:3:# An example hook script to check the commit log message taken by
4:4:# applypatch from an e-mail message.
4:5:#
4:6:# The hook should exit with non-zero status after issuing an
4:7:# appropriate message if it wants to stop the commit.  The hook is
4:8:# allowed to edit the commit message file.
4:9:#
4:10:# To enable this hook, rename this file to "applypatch-msg".
4:11:
4:12:. git-sh-setup
4:13:test -x "$GIT_DIR/hooks/commit-msg" &&
4:14:	exec "$GIT_DIR/hooks/commit-msg" ${1+"$@"}
4:15::
4:16:5:1:#!/bin/sh
5:2:#
5:3:# An example hook script to check the commit log message.
5:4:# Called by "git commit" with one argument, the name of the file
5:5:# that has the commit message.  The hook should exit with non-zero
5:6:# status after issuing an appropriate message if it wants to stop the
5:7:# commit.  The hook is allowed to edit the commit message file.
5:8:#
5:9:# To enable this hook, rename this file to "commit-msg".
5:10:
5:11:# Uncomment the below to add a Signed-off-by line to the message.
5:12:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
5:13:# hook is more suited to it.
5:14:#
5:15:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
5:16:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
5:17:
5:18:# This example catches duplicate Signed-off-by lines.
5:19:
5:20:test "" = "$(grep '^Signed-off-by: ' "$1" |
5:21:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
5:22:	echo >&2 Duplicate Signed-off-by lines.
5:23:	exit 1
5:24:}
5:25:6:1:#!/bin/sh
6:2:#
6:3:# An example hook script to prepare a packed repository for use over
6:4:# dumb transports.
6:5:#
6:6:# To enable this hook, rename this file to "post-update".
6:7:
6:8:exec git update-server-info
6:9:7:1:#!/bin/sh
7:2:#
7:3:# An example hook script to verify what is about to be committed
7:4:# by applypatch from an e-mail message.
7:5:#
7:6:# The hook should exit with non-zero status after issuing an
7:7:# appropriate message if it wants to stop the commit.
7:8:#
7:9:# To enable this hook, rename this file to "pre-applypatch".
7:10:
7:11:. git-sh-setup
7:12:test -x "$GIT_DIR/hooks/pre-commit" &&
7:13:	exec "$GIT_DIR/hooks/pre-commit" ${1+"$@"}
7:14::
7:15:8:1:#!/bin/sh
8:2:#
8:3:# An example hook script to verify what is about to be committed.
8:4:# Called by "git commit" with no arguments.  The hook should
8:5:# exit with non-zero status after issuing an appropriate message if
8:6:# it wants to stop the commit.
8:7:#
8:8:# To enable this hook, rename this file to "pre-commit".
8:9:
8:10:if git rev-parse --verify HEAD >/dev/null 2>&1
8:11:then
8:12:	against=HEAD
8:13:else
8:14:	# Initial commit: diff against an empty tree object
8:15:	against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
8:16:fi
8:17:
8:18:# If you want to allow non-ASCII filenames set this variable to true.
8:19:allownonascii=$(git config --bool hooks.allownonascii)
8:20:
8:21:# Redirect output to stderr.
8:22:exec 1>&2
8:23:
8:24:# Cross platform projects tend to avoid non-ASCII filenames; prevent
8:25:# them from being added to the repository. We exploit the fact that the
8:26:# printable range starts at the space character and ends with tilde.
8:27:if [ "$allownonascii" != "true" ] &&
8:28:	# Note that the use of brackets around a tr range is ok here, (it's
8:29:	# even required, for portability to Solaris 10's /usr/bin/tr), since
8:30:	# the square bracket bytes happen to fall in the designated range.
8:31:	test $(git diff --cached --name-only --diff-filter=A -z $against |
8:32:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
8:33:then
8:34:	cat <<\EOF
8:35:Error: Attempt to add a non-ASCII file name.
8:36:
8:37:This can cause problems if you want to work with people on other platforms.
8:38:
8:39:To be portable it is advisable to rename the file.
8:40:
8:41:If you know what you are doing you can disable this check using:
8:42:
8:43:  git config hooks.allownonascii true
8:44:EOF
8:45:	exit 1
8:46:fi
8:47:
8:48:# If there are whitespace errors, print the offending file names and fail.
8:49:exec git diff-index --check --cached $against --
8:50:9:1:#!/bin/sh
9:2:
9:3:# An example hook script to verify what is about to be pushed.  Called by "git
9:4:# push" after it has checked the remote status, but before anything has been
9:5:# pushed.  If this script exits with a non-zero status nothing will be pushed.
9:6:#
9:7:# This hook is called with the following parameters:
9:8:#
9:9:# $1 -- Name of the remote to which the push is being done
9:10:# $2 -- URL to which the push is being done
9:11:#
9:12:# If pushing without using a named remote those arguments will be equal.
9:13:#
9:14:# Information about the commits which are being pushed is supplied as lines to
9:15:# the standard input in the form:
9:16:#
9:17:#   <local ref> <local sha1> <remote ref> <remote sha1>
9:18:#
9:19:# This sample shows how to prevent push of commits where the log message starts
9:20:# with "WIP" (work in progress).
9:21:
9:22:remote="$1"
9:23:url="$2"
9:24:
9:25:z40=0000000000000000000000000000000000000000
9:26:
9:27:IFS=' '
9:28:while read local_ref local_sha remote_ref remote_sha
9:29:do
9:30:	if [ "$local_sha" = $z40 ]
9:31:	then
9:32:		# Handle delete
9:33:		:
9:34:	else
9:35:		if [ "$remote_sha" = $z40 ]
9:36:		then
9:37:			# New branch, examine all commits
9:38:			range="$local_sha"
9:39:		else
9:40:			# Update to existing branch, examine new commits
9:41:			range="$remote_sha..$local_sha"
9:42:		fi
9:43:
9:44:		# Check for WIP commit
9:45:		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
9:46:		if [ -n "$commit" ]
9:47:		then
9:48:			echo "Found WIP commit in $local_ref, not pushing"
9:49:			exit 1
9:50:		fi
9:51:	fi
9:52:done
9:53:
9:54:exit 0
9:55:10:1:#!/bin/sh
10:2:#
10:3:# Copyright (c) 2006, 2008 Junio C Hamano
10:4:#
10:5:# The "pre-rebase" hook is run just before "git rebase" starts doing
10:6:# its job, and can prevent the command from running by exiting with
10:7:# non-zero status.
10:8:#
10:9:# The hook is called with the following parameters:
10:10:#
10:11:# $1 -- the upstream the series was forked from.
10:12:# $2 -- the branch being rebased (or empty when rebasing the current branch).
10:13:#
10:14:# This sample shows how to prevent topic branches that are already
10:15:# merged to 'next' branch from getting rebased, because allowing it
10:16:# would result in rebasing already published history.
10:17:
10:18:publish=next
10:19:basebranch="$1"
10:20:if test "$#" = 2
10:21:then
10:22:	topic="refs/heads/$2"
10:23:else
10:24:	topic=`git symbolic-ref HEAD` ||
10:25:	exit 0 ;# we do not interrupt rebasing detached HEAD
10:26:fi
10:27:
10:28:case "$topic" in
10:29:refs/heads/??/*)
10:30:	;;
10:31:*)
10:32:	exit 0 ;# we do not interrupt others.
10:33:	;;
10:34:esac
10:35:
10:36:# Now we are dealing with a topic branch being rebased
10:37:# on top of master.  Is it OK to rebase it?
10:38:
10:39:# Does the topic really exist?
10:40:git show-ref -q "$topic" || {
10:41:	echo >&2 "No such branch $topic"
10:42:	exit 1
10:43:}
10:44:
10:45:# Is topic fully merged to master?
10:46:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
10:47:if test -z "$not_in_master"
10:48:then
10:49:	echo >&2 "$topic is fully merged to master; better remove it."
10:50:	exit 1 ;# we could allow it, but there is no point.
10:51:fi
10:52:
10:53:# Is topic ever merged to next?  If so you should not be rebasing it.
10:54:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
10:55:only_next_2=`git rev-list ^master           ${publish} | sort`
10:56:if test "$only_next_1" = "$only_next_2"
10:57:then
10:58:	not_in_topic=`git rev-list "^$topic" master`
10:59:	if test -z "$not_in_topic"
10:60:	then
10:61:		echo >&2 "$topic is already up-to-date with master"
10:62:		exit 1 ;# we could allow it, but there is no point.
10:63:	else
10:64:		exit 0
10:65:	fi
10:66:else
10:67:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
10:68:	/usr/bin/perl -e '
10:69:		my $topic = $ARGV[0];
10:70:		my $msg = "* $topic has commits already merged to public branch:\n";
10:71:		my (%not_in_next) = map {
10:72:			/^([0-9a-f]+) /;
10:73:			($1 => 1);
10:74:		} split(/\n/, $ARGV[1]);
10:75:		for my $elem (map {
10:76:				/^([0-9a-f]+) (.*)$/;
10:77:				[$1 => $2];
10:78:			} split(/\n/, $ARGV[2])) {
10:79:			if (!exists $not_in_next{$elem->[0]}) {
10:80:				if ($msg) {
10:81:					print STDERR $msg;
10:82:					undef $msg;
10:83:				}
10:84:				print STDERR " $elem->[1]\n";
10:85:			}
10:86:		}
10:87:	' "$topic" "$not_in_next" "$not_in_master"
10:88:	exit 1
10:89:fi
10:90:
10:91:exit 0
10:92:
10:93:################################################################
10:94:
10:95:This sample hook safeguards topic branches that have been
10:96:published from being rewound.
10:97:
10:98:The workflow assumed here is:
10:99:
10:100: * Once a topic branch forks from "master", "master" is never
10:101:   merged into it again (either directly or indirectly).
10:102:
10:103: * Once a topic branch is fully cooked and merged into "master",
10:104:   it is deleted.  If you need to build on top of it to correct
10:105:   earlier mistakes, a new topic branch is created by forking at
10:106:   the tip of the "master".  This is not strictly necessary, but
10:107:   it makes it easier to keep your history simple.
10:108:
10:109: * Whenever you need to test or publish your changes to topic
10:110:   branches, merge them into "next" branch.
10:111:
10:112:The script, being an example, hardcodes the publish branch name
10:113:to be "next", but it is trivial to make it configurable via
10:114:$GIT_DIR/config mechanism.
10:115:
10:116:With this workflow, you would want to know:
10:117:
10:118:(1) ... if a topic branch has ever been merged to "next".  Young
10:119:    topic branches can have stupid mistakes you would rather
10:120:    clean up before publishing, and things that have not been
10:121:    merged into other branches can be easily rebased without
10:122:    affecting other people.  But once it is published, you would
10:123:    not want to rewind it.
10:124:
10:125:(2) ... if a topic branch has been fully merged to "master".
10:126:    Then you can delete it.  More importantly, you should not
10:127:    build on top of it -- other people may already want to
10:128:    change things related to the topic as patches against your
10:129:    "master", so if you need further changes, it is better to
10:130:    fork the topic (perhaps with the same name) afresh from the
10:131:    tip of "master".
10:132:
10:133:Let's look at this example:
10:134:
10:135:		   o---o---o---o---o---o---o---o---o---o "next"
10:136:		  /       /           /           /
10:137:		 /   a---a---b A     /           /
10:138:		/   /               /           /
10:139:	       /   /   c---c---c---c B         /
10:140:	      /   /   /             \         /
10:141:	     /   /   /   b---b C     \       /
10:142:	    /   /   /   /             \     /
10:143:    ---o---o---o---o---o---o---o---o---o---o---o "master"
10:144:
10:145:
10:146:A, B and C are topic branches.
10:147:
10:148: * A has one fix since it was merged up to "next".
10:149:
10:150: * B has finished.  It has been fully merged up to "master" and "next",
10:151:   and is ready to be deleted.
10:152:
10:153: * C has not merged to "next" at all.
10:154:
10:155:We would want to allow C to be rebased, refuse A, and encourage
10:156:B to be deleted.
10:157:
10:158:To compute (1):
10:159:
10:160:	git rev-list ^master ^topic next
10:161:	git rev-list ^master        next
10:162:
10:163:	if these match, topic has not merged in next at all.
10:164:
10:165:To compute (2):
10:166:
10:167:	git rev-list master..topic
10:168:
10:169:	if this is empty, it is fully merged to "master".
10:170:11:1:#!/bin/sh
11:2:#
11:3:# An example hook script to prepare the commit log message.
11:4:# Called by "git commit" with the name of the file that has the
11:5:# commit message, followed by the description of the commit
11:6:# message's source.  The hook's purpose is to edit the commit
11:7:# message file.  If the hook fails with a non-zero status,
11:8:# the commit is aborted.
11:9:#
11:10:# To enable this hook, rename this file to "prepare-commit-msg".
11:11:
11:12:# This hook includes three examples.  The first comments out the
11:13:# "Conflicts:" part of a merge commit.
11:14:#
11:15:# The second includes the output of "git diff --name-status -r"
11:16:# into the message, just before the "git status" output.  It is
11:17:# commented because it doesn't cope with --amend or with squashed
11:18:# commits.
11:19:#
11:20:# The third example adds a Signed-off-by line to the message, that can
11:21:# still be edited.  This is rarely a good idea.
11:22:
11:23:case "$2,$3" in
11:24:  merge,)
11:25:    /usr/bin/perl -i.bak -ne 's/^/# /, s/^# #/#/ if /^Conflicts/ .. /#/; print' "$1" ;;
11:26:
11:27:# ,|template,)
11:28:#   /usr/bin/perl -i.bak -pe '
11:29:#      print "\n" . `git diff --cached --name-status -r`
11:30:#	 if /^#/ && $first++ == 0' "$1" ;;
11:31:
11:32:  *) ;;
11:33:esac
11:34:
11:35:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
11:36:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
11:37:12:1:#!/bin/sh
12:2:#
12:3:# An example hook script to blocks unannotated tags from entering.
12:4:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
12:5:#
12:6:# To enable this hook, rename this file to "update".
12:7:#
12:8:# Config
12:9:# ------
12:10:# hooks.allowunannotated
12:11:#   This boolean sets whether unannotated tags will be allowed into the
12:12:#   repository.  By default they won't be.
12:13:# hooks.allowdeletetag
12:14:#   This boolean sets whether deleting tags will be allowed in the
12:15:#   repository.  By default they won't be.
12:16:# hooks.allowmodifytag
12:17:#   This boolean sets whether a tag may be modified after creation. By default
12:18:#   it won't be.
12:19:# hooks.allowdeletebranch
12:20:#   This boolean sets whether deleting branches will be allowed in the
12:21:#   repository.  By default they won't be.
12:22:# hooks.denycreatebranch
12:23:#   This boolean sets whether remotely creating branches will be denied
12:24:#   in the repository.  By default this is allowed.
12:25:#
12:26:
12:27:# --- Command line
12:28:refname="$1"
12:29:oldrev="$2"
12:30:newrev="$3"
12:31:
12:32:# --- Safety check
12:33:if [ -z "$GIT_DIR" ]; then
12:34:	echo "Don't run this script from the command line." >&2
12:35:	echo " (if you want, you could supply GIT_DIR then run" >&2
12:36:	echo "  $0 <ref> <oldrev> <newrev>)" >&2
12:37:	exit 1
12:38:fi
12:39:
12:40:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
12:41:	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
12:42:	exit 1
12:43:fi
12:44:
12:45:# --- Config
12:46:allowunannotated=$(git config --bool hooks.allowunannotated)
12:47:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
12:48:denycreatebranch=$(git config --bool hooks.denycreatebranch)
12:49:allowdeletetag=$(git config --bool hooks.allowdeletetag)
12:50:allowmodifytag=$(git config --bool hooks.allowmodifytag)
12:51:
12:52:# check for no description
12:53:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
12:54:case "$projectdesc" in
12:55:"Unnamed repository"* | "")
12:56:	echo "*** Project description file hasn't been set" >&2
12:57:	exit 1
12:58:	;;
12:59:esac
12:60:
12:61:# --- Check types
12:62:# if $newrev is 0000...0000, it's a commit to delete a ref.
12:63:zero="0000000000000000000000000000000000000000"
12:64:if [ "$newrev" = "$zero" ]; then
12:65:	newrev_type=delete
12:66:else
12:67:	newrev_type=$(git cat-file -t $newrev)
12:68:fi
12:69:
12:70:case "$refname","$newrev_type" in
12:71:	refs/tags/*,commit)
12:72:		# un-annotated tag
12:73:		short_refname=${refname##refs/tags/}
12:74:		if [ "$allowunannotated" != "true" ]; then
12:75:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
12:76:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
12:77:			exit 1
12:78:		fi
12:79:		;;
12:80:	refs/tags/*,delete)
12:81:		# delete tag
12:82:		if [ "$allowdeletetag" != "true" ]; then
12:83:			echo "*** Deleting a tag is not allowed in this repository" >&2
12:84:			exit 1
12:85:		fi
12:86:		;;
12:87:	refs/tags/*,tag)
12:88:		# annotated tag
12:89:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
12:90:		then
12:91:			echo "*** Tag '$refname' already exists." >&2
12:92:			echo "*** Modifying a tag is not allowed in this repository." >&2
12:93:			exit 1
12:94:		fi
12:95:		;;
12:96:	refs/heads/*,commit)
12:97:		# branch
12:98:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
12:99:			echo "*** Creating a branch is not allowed in this repository" >&2
12:100:			exit 1
12:101:		fi
12:102:		;;
12:103:	refs/heads/*,delete)
12:104:		# delete branch
12:105:		if [ "$allowdeletebranch" != "true" ]; then
12:106:			echo "*** Deleting a branch is not allowed in this repository" >&2
12:107:			exit 1
12:108:		fi
12:109:		;;
12:110:	refs/remotes/*,commit)
12:111:		# tracking branch
12:112:		;;
12:113:	refs/remotes/*,delete)
12:114:		# delete tracking branch
12:115:		if [ "$allowdeletebranch" != "true" ]; then
12:116:			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
12:117:			exit 1
12:118:		fi
12:119:		;;
12:120:	*)
12:121:		# Anything else (is there anything else?)
12:122:		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
12:123:		exit 1
12:124:		;;
12:125:esac
12:126:
12:127:# --- Finished
12:128:exit 0
12:129:13:1:DIRC      !UK/|UK/|隞@ u         VhV ߼3@ 	README.md U#+%=@TtH    隞@ t         & ~*iM4Cj taC array.c   U#+C$Tm    隞@ t         6&Db9d!?)q^ array.h   U#+bGTtH    隞@ t         Q̯IwFP}= array_buffer.c    U#+TtH    隞@ t         !Aȶ	Ǖq<hQE array_helpers.c   U#+PTm    隞@ t         ?,1$s#
13:2:N array_statics.h   U#+մTWr    隞@ t         UDe~|) 	config.m4 U#+ZTtp    隞@ t         P-;G IGcet	Q 
13:3:config.w32        U<"=U<"=隞@ t         ,QXgZk*QK> data.c    U#,
13:4:" Tt    隞@ t         ES({4hf data.h    U#,dTcW    隞@ t         h*zԯRHkb|n data_statics.h    U#,(TtH    隞@ t          &LK`U;)jFy!~v ini_helpers.c     U#,G+TtH    隞@ t         ا΁hR}fUyD{6 memory_helpers.c  U#,VnTtH    隞@ t         X¥
13:5:'5׹G`29 minify.c  U#,e0Tt    隞@ t         7(C/fHeƙH minify.h  U#,6Tf    隞@ t         G+acxJ0GEc minify_statics.h  U#,TtH    隞@ t         ў`r#ZwԔv php_vroom.c       U#,8Tdm    隞@ t         ֔^g4{41< php_vroom.h       UB-a UB-a 隞@ t         <BR__\\cA string.c  U#,Tt    隞@ t         mj2?g
13:6:yGWz:< string.h  U#,dTtH    隞@ t         |2[y4s^o string_helpers.c  U#-HTo
13:7:    隞@ t         
13:8:'wb+C*8 string_statics.h  UpT=$    隞@ t         !uW~oz8y
13:9:ZP tests/001.phpt    U#-ΈTtH    隞@ t         	hخ;C7:r thrak.c   U#-;ST=$    隞@ t         |~4C6 . 	thrak.dsp U#-YشTt6    隞@ u,         0/Ə	Q thrak.h   U#-iTtH    隞@ u-         2(".ѷFO;<- timer.c   U#-ĪTtN    隞@ u.         HX&@H/_L timer.h   U#-q(TcX    隞@ u/         ډYj5j!-^qH2 timer_statics.h   U#.pTtH    隞@ u0         aiծ	!=ߥq vroom.c   U#. 8U#v隞@ u1         5I*V~k"_Ը^% zval.c    U#./{TTdn    隞@ u2         xWz~Mh. zval.h    U#.N 8TcXB    隞@ u3         FǼt#vrwʾ zval_statics.h    TREE   8 33 1
13:10:= f%GhdPetests 1 0
13:11:)뵜ʆ1&ES 6Kf}Ǖo14:1:# git ls-files --others --exclude-from=.git/info/exclude
14:2:# Lines that start with '#' are comments.
14:3:# For a project mostly in C, the following would be a good set of
14:4:# exclude patterns (uncomment them if you want to use them):
14:5:# *.[oa]
14:6:# *~
14:7:15:1:0000000000000000000000000000000000000000 b5088acf0155cd8e06a0c9da8a7180fddee89491 Christian Vigh <christian.vigh@orange.fr> 1441014839 +0200	commit (initial): Initial version
15:2:b5088acf0155cd8e06a0c9da8a7180fddee89491 ae48b61e6dfcc934ce83072aa86df6ba13b36010 Christian Vigh <christian.vigh@orange.fr> 1441024729 +0200	commit: Added README.md
15:3:ae48b61e6dfcc934ce83072aa86df6ba13b36010 6a8d53f28e8b9853fe0daea3432711af59879994 Christian Vigh <christian.vigh@orange.fr> 1441025080 +0200	commit: Updated README.md
15:4:6a8d53f28e8b9853fe0daea3432711af59879994 48b0c2dc58f7cd88ee1cbd0e130173486b11d4f7 Christian Vigh <christian.vigh@orange.fr> 1442996770 +0200	commit: Minor changes
15:5:16:1:0000000000000000000000000000000000000000 b5088acf0155cd8e06a0c9da8a7180fddee89491 Christian Vigh <christian.vigh@orange.fr> 1441014839 +0200	commit (initial): Initial version
16:2:b5088acf0155cd8e06a0c9da8a7180fddee89491 ae48b61e6dfcc934ce83072aa86df6ba13b36010 Christian Vigh <christian.vigh@orange.fr> 1441024729 +0200	commit: Added README.md
16:3:ae48b61e6dfcc934ce83072aa86df6ba13b36010 6a8d53f28e8b9853fe0daea3432711af59879994 Christian Vigh <christian.vigh@orange.fr> 1441025080 +0200	commit: Updated README.md
16:4:6a8d53f28e8b9853fe0daea3432711af59879994 48b0c2dc58f7cd88ee1cbd0e130173486b11d4f7 Christian Vigh <christian.vigh@orange.fr> 1442996770 +0200	commit: Minor changes
16:5:17:1:0000000000000000000000000000000000000000 6a8d53f28e8b9853fe0daea3432711af59879994 Christian Vigh <christian.vigh@orange.fr> 1442996729 +0200	update by push
17:2:6a8d53f28e8b9853fe0daea3432711af59879994 48b0c2dc58f7cd88ee1cbd0e130173486b11d4f7 Christian Vigh <christian.vigh@orange.fr> 1442996791 +0200	update by push
17:3:18:1:xZmoWD]kWQ$C&ĕED&U.IYriQ_Ħyfϓ1/?i_[[^u{{4ٝJoǃ٨^:O54]Ɠ<JlX:x<K,D&</Wvam>Edy;&lg^6ƏjG= CF̨]r:5)]&rnq!f~Lԕ*{5ZN3_i͖y\ŅFp9~fsgrG*ɩ~xz>:ݩ~Nߒ	 /*#d,g?zw|XӓwD6 &=$舦<3T
18:2:rV^;42J~r^|As\w ڃapYg8kqҥ<!˭	 Wa6N	bӥiڔ,!	493Dua\H,K|R^E$||ƦI9Ȫ8@f$  HZYL >My2Id$Y$@zU4HFaKg$Sd8XupQ>ᇷH.?rn+=/tФ)=mӱ.nG$,2wJ+vU'<r
18:3:`BELLQ$bG"ͪXl%!ۉ|a
18:4:!A#5O&`~dy"_LJbOq(d!gSJwdQ袆g	cFoZ]W!j=% 6#X,Hy^yH^Y܏\-wG[~r5$Z,/䒭x_F4I	BY>(9 "KlrgeMzbCYs畴.qD:@pAS%	Hq{8\?Ç WA:3l^j*\sU5$llnhT˟ĨM(PkShIR/V''L\BPQܣwT7A
18:5:fy'~gy&36ctw\z.\Ćq%ā~<D/IҟfJk|21'Q&#=?wL` "f9'b-%P2/p^EU	UUT(bN[SUGN%ѓ'r8r"1;ZߩzU<!ҫ(CeEɛ	kYa"FAGNU6~a4X΁nW~moɹH>DZ&wM.{qS>EG)K}͋jZ?%rcQ4^wqv;yRGytm4PP:Eh`#X]Ҹg`FRXP\E+VYB69zzV	78\yWGQ+82,3nFLNfDUPëM*%11Ax:$&
18:6:]}ǙI"؀&w0a[%Μq
18:7:R.ڎ(KTMh7\p~D孴#w0hO-%F0h͋HմMHVn%4Ml}dK7*;չǊ(t(NÚͿdDeF3	M&WTI]D(0/1YEVgPaj5\y~!mo]seF ERqY'a@/dN7JiN	ΊԢ).B?LHq 9)RKʝCPoRf6x<8]WsxRac6Q3BYi>0n̩S?xv޷]h@AZ6m׊Oa]ե
18:8:o2^wnH9N,D4VdgAۗ/G9﹚]q[<՜(purvdAfWA
18:9:`[@5>nrA}We4]?"Ki痣T}7=82ߠoՁ%(~j@'up23@kn<OJ6V7rb9xeuI7nme	9ʀi2
18:10:܌bGKt3-
18:11:KŲJ䥈Rj!]$ǴK_UUa;"g	 f%sLscI8Ǖ.%E|HT
18:12:+O% Bru\ZQB<UU4!UņI;UWsؕzr"!;8LN3*̺yy|W7Iɘezuu԰tb;B9"*^;>9l=yZyAh]#
18:13:5;ވgi{9<轣Y=3Jeuyys
18:14:z~ 7u+(Wl
18:15:L@).%U`ZX)+aLw"Ѹ)bT]xErPRrWKGSY.k\A<?(XxR֩Lt9U:`-fNLsPfDH"`!=1lRr
18:16:2:6xn'Pi8їX^9`X~o.A|#)c(/aG`=EL7>xv	*ػ@ĎG\He*r}(ʾ1wMWE%	/eֱ^ f*pt"Շ*T62[sFVSU:0TE[lo1;v6A$bn<q͵㘭&		 䄉moRZ f}(+a7}_$y/^=x),9qLy\3*Z19:1:x͔Mo0{~^`m0&nml[Iۓ$̕G>~(I 1˗CYopC)IIHR.mGWRߏ|S	%7BA-TP5-)`nà3VT~0+'((V*47|{7?leQ4J̢NaQz	ҥi4,M'<^+->Qo LwR/K0K?]!tMd`f9B3t}wSw,L^oޞPJF?ºhUŦͧ
19:2:Ƣ,'x5WsPq=KF#s\(Ȱ[Qڛ3?r'1[R@uy4c6i-t';j	2K}n#KQ%ND?\iV1!ً\ΔV=Ѹ.UEh 20:1:xXQ8 FZEZ8BTH$tOV ֥	Jo$ۭ=\xdy}_ڭ>FlXydn?3ű],MrXیQA%ߛ#ǿME	|ftNB /b, vql,
20:2:,Bw!-e	=o6(Y5%8]Ї7Ͻh^)&"KsAEp&%6нuH݂Uf.77ʧv
20:3:j9{kJd}}
20:4:tg/ݳ`ѷ"kPyU}D78r̼Ҽ{a~5>\lKk$o{2[#>ރл3tzVt;g?4Aܞ*ՈOߋIwIXakݙh]Ɍ˿
20:5:ZɯBg}jלs^:ބ)LjjNn7Wb_˷n09j@#a	f|XTrЈ7%.m ߪL+ΆTj%Q|\JD;MхHj?^o4Y
20:6:#<4X"VO5<="+-LIZo. +ll]z@zJۣDxԌ滸Э<fe#1M׌ʿ1U&Di|I#!V+!|CA$b唰$I#q6dSV6!CU46PHz#.ˊ0K2Nt[I޴e	)Jhq@W b}-n92b%0,$^lNίl3ꛊ !5:>úTd-z$>[ͪ\͆Ukd+uyW}Qx̊+5xrUOYO
20:7:iAʗɩD׉$_cʖl=OQ̞(ߞk:a?]L%f{p#{߹eᇎ"O}&21:1:xWo6ޫe8Nt}VuTۨ#b}!hʢNm$G2tC#wyd/@ÃÃ&5f2[9}xh&.nx,KT:E6qr+߻U\˘nrաWo$#ϟ~'КGÃHATZG*#>
21:2:[P@FHըE9Z%C0VYFok\.: V)S)+E8()V*]'5WqWlϿMZ̍HAdNMVq+R(kաfEb}:m50VcL;3X})d$2\Ed@ekp7BӖ.$i:Gxt%8Xm?X9'gI:[pBBh	яHw1	2N ŧ{Jr,L21@5`Y3t9e[{O,c>!f@1	9/e90CC/.^P	K?Fʱ a*/2ђ~cCREQH2wxd^0`
21:3:ECSٝ&%p-ӊ/5
21:4:uXJXf˵7; tJTUCx3D5OqM	t5Z22 P_p;y)ߎB#֔0+6$)+.mBǎO{)<]o,nz3qqF9h6q?1
21:5:z4O'QU+S)U9QY\Ã!U=zkn<V`nY$ș*Nt
21:6:eayFZ3gxDz~)oəaovj5ܵL-џԙy|$N)o7U\NߍРg~<~,"#ϏhMϩ"2jx`Xz1j3|?b?峱C(H86]`cԉ6Wg<#PF=y3$}h=G=b<2oYKm߂ns2nMSኋrfsF`h;nlk&WHษ\I<@kr.
21:7:"_Աsg9\ShmmZY?i]dA$ܒ-K*ZQ h.τe$*|I>ҭFq<dή$IMH#eڞp@íȍ.84jaӲ=PkSѐC:V}k}+{Wv٘?呭<4̕F~{l1~&3ضO/8z⿵.ڿ|t*6#n\22:1:xZyoF amWM"˶PYr%9W (rdqC*'N﾿ uVIf=7GX=yv^OSSakйu=X^$d*&a$$IE>y@^(8s.,Llߒn^5M,X	qtti	y8`BqK8ảA'uiZK>8ݻ	贒#/ǩD6~8	}141OJۑyTdgD^|UxWr#<%Vf]厣X"Q|8pa"o%L֡$(ް$]J	sp >0-xB~TrS@aDQ@m6<fƔ4EfgNt4*=r>O$2Z7q:r/48I{W+|XLhh88ߟ>"FVMxOR!##y&fA0ium;#vFnX?o:=/'>uN;8|ʹcďBgaCb>Eu|4Isb|6h'(,u5*ƹU+X8E@YآL4Eoyq4"5꿗 9YӽqƐW2hixIQYEۿ`ReVyk2Ǫ!msFĒ0I.|&)w7rVI6.?8&XWV@ŐP/s[@a<G-T>|@reE9:Ω9tTfA]J";Jt.
22:2:T);߅-:yWQB]Pmߪ+Pv\ns90OޓlUtpۤTFZ#cł$"AU_)/<@Tʤ^a&uk*Azh	`{@;F}wxf&li}5LTlɓIe^ʴ£{rk-!dj*7"(Q{95(SPdwt'?	t)w]zp4蠣h{Q7rmqe\knHi:$SQcdӫj  ](,"1S%dtz0:PK&!RҼ"̜Z$c%vd$濄bT$nս5z)ڀYpsH6Pc
22:3:w?^{4x{3IGBnmJfޔG(U
22:4:+rIncֲg*`$ DΕX\'aϕbVŇ&Eψߝ87RhI3˙ÄvNϺG::^As4pzÃhd%
22:5:fn{Qec(vv1ԞP=%0$qXˎ<Uяvfn9 T)ot6KZNRW'ѺW=
22:6:>MG qtc=r^L`8YV9J2f_~Je+;.[E&[TNd*c_oElMD#S}ik.$]v%&
22:7:`U o:&˨B^0\vH<J:&^CCtMV`cXOfA56K;̑JyM{iJ}b	ϨW'Mfm֐Ӽ 1۰!&=?|_fEپQhh[D'Ets'{7@׵r/0Mbn~_nnt:_7CBx-LG/JD.[[4>eV;~WsMVr
22:8:(BImk:z*Ec=!Bja`U3G3D6*wvz( +C@Xo1۬(!X}cz>eXutˈmN<R5/	ne񰼰ʭMgmUD]69"/)l-,h-ˤWɨjR/g6sIġdNDs){B,ǈ0`R[081ģx~!yܯsG߰63񂲦M?/cic($oe0[c3cLs^.-"aUr
22:9:͓	ƯBPXy'>vfgr7˖fxՖ49hj0⃡ܜ )lTxrb"M,W)IZ.J#m	jnƛfS,PaEbɴY ;9rZV,	W}łacIfޅT&}}8I"'!P:c^.n'4.C%EN`$ e
22:10:x%jN[baWY['eR՟FlGf%1W_)#3Xd3.|844nХC1NN^yeG纾KKba_eТu_rI*%KX)=jp
22:11:3< Y]OҽzBJ۩[6As/d][(V"P2pR,=kq5Jo]U.)*/-+(9`beMO!j){m04
22:12:eܡFvZ$dIIikqK98oKCzT׹ꭘLJҍʻ4.ښtW⛷;7<23:1:xVKo0kTU[JJKTH$'+$%Nw<m
23:2:o<iLwsn[F	
23:3:ml@g3,IARF0yku}m)8ܱEFMϷݟX1zn @#7ǆKHBX2 Gܛ )gdlI314EjLc
23:4:"
23:5:..yR.`nF/i@yfDy)Ilprsr%jN,+$(I3yD2һTU{cQr$e.:<?_|DUMvqIby(ЊbrMd#!wBzEgmk 뾊Y{냯^[d#^Q'ekrR2sl0.dpDub
23:6:jjxކ.iEg萛՗#Ǎ$T^
23:7:o%"ˊ˨*#xLXTRֆ)XʻjITdk'}Fqd9FOqNjWRȒMNegu3UIF3G<e,Yʙ1<ϪlՅKj7+`bHiĹ|?Vi!b7[l(A{*JQUe~6B]_.G $#ldh<)P~24:1:xYko50MW[]`5bHEXɅ>F{},E9-8_,53{>Ϲ3H_tgy3ϟI6ڢ<L~{q;Nnf+]YYT%yVe^mXI2'Y&50my.s.JCs~~ǳ?+/'"f?Gϟ$Yֱ5Wպߟ-d&<HJ^}8(yϣuXc3γ-<gw4*F/l79$g> ,zhdV!\Z*?d*5}In=ָ5U2Q7)zv1Ř%昖6Z`Ib@gU:@2ۤZc<4e&7l0Y4eݦaie45(`iSQ[6Ksnlj76hyTljgzegP,j \ס*R&; ZjCI:%Y쒸F4?"?6IF[6^WyEr Zhq:4XEȜ5yۦ!gN!?k%YeaJۑށ":`FgW܃gfIV_7Im]5Vn5н,X,° H8:٪ZsPl]̱;1Ie7wNDY1!k)^*-␛sUp}z1^Qwrm&/"ͣ&LB,I$-A2(*fS T/,d	$Dc.*ωl w41~ua <1Gs7y7u\LriH?E\"i#U^L>^ Jc\(!r]bhY?)UGQeX`$^HT7]$Sl=n94%f40~Φ!DULΑo^#Ntg(>P|9>>YQX©7̋n:hi)-/}]dc}X`1+WP{|eX	`!Z۟׍5DB7~|bPÂ<A) h7w 6ţ	oWHIxE}5qY,|*s~K0z	TI\+Ls $`1)	C9DR}+Kzr7i$Ů'5Hmjp%jņKP0Jpk+(df.1L:2	A+l/]a>3<:>Dލ;;)a?CsWϪ$NVXgڭI@PjTP@X$P4`Up	ʽQ)0f4j.-h,}pP|l`3%ֻ-x f1~9z/71x3d#sۤ J9 <r4m'IDx3G9GI"/Yھ|KTA "K"){];4ƚ<)#SHj!eòL=L]z-)pݒ\e8fx)4$n8"d1a.}`ķ$#vS$]6.uDO^}1vT\yõT"\Es_xt\-kRn̦hZ=|C+[@;`yvak	3aƨOtjFG!85$h/F~}8!EȜu2Yz7>]qP=-2nK[%XfM8lY\ j`JqYG0@ԛOC&"TM0N49	.;H<g,aK3Ni.^ocruqg@&Ո9?vkc02Qat>={bs'|m;!n/Ό1$t4H4<9Q{j
24:2:sDQ
24:3:QLC
24:4:_40_ZfmOu(153
24:5:B5FFAtӝ@6Q>䙻/7Pt~F{Cni55|ұo5ؚw~D)zӐaA_N <%AJq~.Awb~cT(q'|$p|HW
24:6:P=iC1+J'7F[9,=?(H}!҇R9c{(fKZ=\Q^d4D>DRKwx'gmawI^8O(w 3;o|sgz@+ҦM}t{l[=t*yW}s/[J0eݑ>S;o5t{T/(sNORgF/2}i2(X)svf8^_5d?UH25:1:xQO0}ݒ#&>Ta¢3&ѧ
25:2:4BG.bf4˲tgmH#pgv2-pѵL#a\1%=ǉJ^=ǹ	<5g
25:3:E  P-;O bޭA(<9:%LlǱ9(x()HӶsS)IH8$!Z5PZݼ<xBJX6+\*,fK2M%V%|]v%}ʔ,OoГ0 x>%z݈/r#Vt˹?_'ao,cjRULp+JhVwnmрoN|>{8^v%?.VDKj		<zeஞٓ}gAkj??RB	126:1:xXKs8ޫS9LJ;.sbCId-122yLn!l:YRu~oj5߾:kxins6:u:r2*	LH8!7R$ՁnߌCb5#89id7_5vA8 jX=n.c4Ҳ28|*F78S>Vxw6<i`XҨ9'ddJBjd@01}:ڧ_=fK6hw:g6{#ߖN?5Iut d02[xVI$<Aa wSOݙ|B<MåS3ˉ'	˧mů ΤFu/R<sM_<i	̢[{x3}	4+17F:ݡmɻoي̉O5&{"M</EAtܐxYgFHMܜR<)sCrGس6RJĻr=X{҂$tJi.NҚfѰ_Cv^6C!
26:2:gEk 5 Z^ xY3%l$^.:`n^!ϥ#iȿbeIGO|`6~] +ԁ,'Aj(
26:3:Ʌ5.&8!!<&W	yOD6G6|A'c!desr:Yr8=1#Eܖ'{7Yf{i}Mntp͖}.hݺ¶!_Kz^bs&!ϝRkk9')xMХEtcƭ"lJjrq-Vuzrct1ݲoLf`[w^6ď%ۘzyA]6~{wenjIAKzkI 2.1YҌYYAS=z8Lp9έsٙeLݽ(5X,P4U]lzU flu78Q6n:z=	`%*C
26:4:#[Jښ>3BէL[:Uń!b|en?z,gj)aCdG%ƶËQŴ*YjDtkGݛqk}=jO׽? Ϋtgm27:1:xV]@+&싚M**iR}0dǁ_ߋt18 ˝!in:F8<lX(.Djx+#g>;pnA`̊X@ȀKn87!	?"3|9\))ak{s΃5axL:f
27:2:x"cE<]o_vdJH[r*fCP钑P`m\xu_n7ƹO%PL,SV,IkALF:\ReyǏPLSJ8#?!7Wy7F;1;dB큲X{UYԚ6R٠)+u/lߵGpceӵ4@ͪʒ}RgHs,OX	GT3¥fRp_c&Ҙմ%p2RYM
27:3:%ҧ¥M*/!jg#7֥=p׈])޸43,`=j|zUJ^nwa3z~^eYR:pĲp<l<28:1:xSM0H鶧P-l'Vٯ_1i93|:g۲-¶HT|UW/Y`bnθBZ6kY9S,z-6wV*hJEy	kdbuwlzǵ\t=)5yY!I޶TmZ0U7L`:!Y<idZ ogP|c&Av89˽(mb?+,.y?ɜfu]׎qCؖ_Edc!`8&Xo5xc^mD!(Ur<C5L=0*c׌=+ml1Cke Hh3az,yEnt+Van(Ig/q?'M~:7|+<Bw߯s	q8V }?29:1:xZo4aɕE(TY%^ȕME|ظ7˗8CdÖܝٙojS:}p=«ߺ7ёwyg6qwFD.Dd'^Gj`c6ĳɻm;|Kԕjpۇ{&/pd,n]ۃꈲ_^,س07]+ȳKfd{Za'pskѦv,,/k'aXՁp_91f^ .\"{~^JB+0N1(cBpxH/v.gkKTUK#8pN>o0ޛK ?oh/'G<qwȰᱭq|HcE⿩Φtkō|)Lmڵ|;NGvl-Sڅl?jg{@6X% ~Ԥn!V,w`Th|eX~wl]Lme^b!f0pD2~qTi$>GeU/;NIpHtܱ4@S`*ߚ>GpH(l l\"uL7_ZA4n qhЛpFF֌aD`GQvKu6^wO/m6oxjVb1C\
29:2:x2ȝsxZoTD"oa⥃w.;&RW%\W m>~ԩJe0؉	˯.i
29:3:yeXp=%rgEeI19OKyEbIz2Q#CWˠ 3N F$2koA0E4${`7i&SEad	>ol<2{#:V4f&sCJBrtL@&Izt-|ENUkp}1w	`^g27#c1<&b\+8o%/iXn8;ę
29:4:{op~9PN硛K7r\A&c0*M^l4$i(;iL{p-	drJ2TjB[_U)ϖ)E5ԡ(֠U0}R_
29:5:a))2a %ujzFDuju2Y"i7;ٿac\HFPMx5.H}2m?,IJ4?伤nh|Bn7wQz3R0yklxx+}e#^oY`6/+u \Vu^^⩓ydg+8U{ABK*;Nu-DG:L&JRN34(/)\gB7Bd/#EՙTR{n+rP+3t]6T->U#=a@2t&NuJ=Y)d]4h5#
29:6:nXY]cB2=qe'ECF"0J(zPwAvSJd[𸅿	"w[	zyk2<nobvlg5?3%)
29:7:Exu(aq1^fh)!G֦%,4jrZfa>.U3O{UʶK8Rb r	5zA۱%V~zmu'̑YNTj?rV\?
29:8:"@55'd%g'_0*`hKt'UUU2Q tSvYqKip=TF?&Y
29:9:|'UPz7ӱK[SlQb=xXG`5VTYs
29:10:|ØF~'Qv\+D7HɔwkV	\x9HE7HvсJ DYָbf~)LHôkQEWҢUTz+]@#+|Yy&htKWrKeʹrKT~eSٞMنr5[[S[S,1۔EZ2,دْ$!:|d~|;/pO(GPVfAHmEQc&P^-"qxb\9|^g8זۘ,L@eU[iOv{X;ضaۤj	-)7Gu0Ҫ9%JG{.!(=^R8	};V&3uR(6͵6s+˔qV`\k*y	pU\ETVF|W|7 Qmrl<6!Փ94n?30꧀R_]Xr>:ٕug:Z݋|mN!A\nY)sR*٧y
29:11:$?rev쳪ϧ}@i7.GU/QξʜQ#]tZ>Z~>f*[򒪯_PRϔ*{OgV|gKUMOZ8YywE30:1:xZmsHJU9coj*\$/*HLt \C\I3==Oi8j_C<G)|:Gηo|rwoOK"DڛZ9lNtp5dxOjދݗȃ0v1{Ǐ~QA8VNm>q͞Oj'NeBγ7Y7t|ӪD-&UVM$iR}LR_Q*rs8pߝvZn	Vw>Ǒѱ-pq#D}~G{@mtO;:OUcס/I'^_Oszt.o݌($)ӷGmKVp;;!kx+^	flwB?ҕ& S2I~aR|H?6ׅ8egeD%W>dfe9z<ppxֱGjNzAwM.84-/T\Ԟ^1rAa:VŃ%s=
30:2:Ɓ<8i~ #_pk|jѲDΉ˖T}PV{iN)ǌ33ixzI|>''|(K#NL!+n0V4E;DLã&yV~ZuUV_ֶRo(yxtkv*/L]V3pOpi4ԮJl.!@`DPyq]5)y0[$(6:;:Mq:¡`fhބh:}WRC=)_pgOw]3=`qu!f=fF`U_i¡SfV`T(jH<`S2q9/؂ &n'' cS/&f;P]ȤNq.^Бed
30:3:Q3ڄ}*Z8F#=gCrp*x>^HܦS:^fțN/ֈBb9	^Ԝ41	ŗ,	f[h5L  \	2,ajCʹ]ɪ9wK7ƺ)Y8RHzT$UViԀCA۝J|QJVخhF;Ҙ(zĖKm|hM./Ȣ(A;بnчSpޜ+pI@V&g
30:4:@BhЃ̡nќh@a߬Y>5CTeA#LCy&FBN:ZQy4=E,]:b$OJh佉	`s]	ar}D~^`d*-33m?w97AH3\`#1zO D3HѥcF\mK1	ηc3t^9}C"e|j_*\0HdDdBo]AkWTBo]A+W4BܸuS	 j%5775UDm^!ޠ&WN+4sR4LTߤ$64^:%ʩ5viilص-9)G|CƧo{tϙÂK/tKA+rQ6ƠeaRA:WeT_thRRoei}7AžH<w9xָ%cHg&ڤOA(@64C&1hcP*᪙vw5nZ3T"0BW%PAŵ[rŞpѴ=AVξ~xudE*Y݀o!*a.cp\KQ`Bpͼ ,vL|s06I7zBR̶(aCȍ)%L^ ^%__[R\(.q=Q[)-2\)Փtˍ|qƬbd5gԹ*FQpXL*A^O)TaoYpB$(2TƐj7*3P0S5Dڬ2M
30:5:9"ҕ!;|'>yH$''Pg2wiuq@H(.KtO=[@RZHMmO+W_!F#^|Dp瓕ɨ4x{<tʆ%86-WK5_%+5	-qșa=O`}6_{*J^@g@N9
30:6:%oP/Y,GPl&I)uz eI(YWڃ5:y\Ćĥv "-	j4ѣ/EؘH)]AnIẙбH+(dMLue>HwG +RDq/
30:7:	U41\k1Hx$q&+A^`) SB3]*'Ju`eБ	PTa/*]u]8:;{(,	XG,(ADf<I(E[Kqq`&xk)
30:8:]p)ocۓrGu?dQ/2b)WBWhZͻH87{4UCbT_X:}C:CmxbIuqzqt4&eV+wI}W ՝LFh Fk67!L:",o+l80977F*k 9	 /vmo',BUϻ/'i1
30:9:嗊eDoI&uc'>Zjr%7z~)<sa+u& :E|m6`a΁S@/y  g5z9f^*#2+O{iۮYeYCbSnFf8$rA{apZd6X^l2۴,Nv2afB#}XF%pE㊮io8Aa˟Zm&~'	;PU
30:10:5.xB}]!;54AUnBŎPwQ߀Dް6$Jk[7s31:1:xSMO@Z$^FK	kk)5Mz,0e!hw<	!0y,BOk0 
31:2:YMc%5"':jm=JPb:"b-C^Nj8wr,DML"͎}\`o:_5q&c4A$*\]l&pwaKZ|@Pn)Pa#hbmQ^MJq5,)&NSg;tk+`eVG悥ܰ1ǿfX0J#>6hDH,+zDIu̽s-J,+OL}Ȅd#+ξ3Płn'.(LK32:1:x+)JMU0425c040075UrutuMa'B==>+PEEEzie8g)r=,35wR۴A06Ҵ"a3Ϭdzr=r'nH)H-**q<݂;dwEQZ\X\`3ņ*+49?/-3]/ׄω.w߽ٟZK"j**76bx!k5LiO3PU)%@wwyjckUL!`qz"A94$ehXue}GY3,CUfe#㤚	֚Y2nSf5@U"]~1aЦڴkSLryXmhj(R6rV1ow	FQd0h8/q䝫B䁢#+5`ruW,y/ڂ\(?qEW,-PtmX&<+n<0ybhX(3/hT?]]*{e)hT5,?f1٧?᪔uAQjjWT
32:2:=7yU([jѦ>{j9$	˴ܵ_k(3Z9,j8!ԬlgXyKgl͗Y]*:$:,fH_auUEQl<1@.0%<iJzt۽cf]%>m&ѰO?~|Dd鳮,EݸCFJa̞?5s͡8;+ݳB[$ʎqNnEV0e݊}7?dPob$Hrs|OɋleE-y: 33:1:xVKo@u#V	jC)'&X٦mrY-x[;	<'{(GpyyMǧZV a
33:2:aIS|ˏۦr	)( N`OZ,=]C;p5MD*LYfrsxW|m7#A K:&x("^>VBM26tCNJYިߣ8w0ƔHeiI<X@6Vp]E\M͙
33:3:VtCeR5M-3^oԵLꚞgQߦ=T%mc{^%"ۣsէ4mHgzEDszdQۮKjgo NYQ$,b\<pU!y)/,XP'g$aM{o(.!bl%O"#KoӦyaϤ׽A6k	N	i,0Tn@D$,j\
33:4:[pP",s)-|S˟4&q.=	9>(@9M،O!PֹZsUY(f).2$*dXb{,QΰRk3.1''.,ϱĻOɩXLzbjG/n,D+9շ<nɺm4~kn
33:5:AȤ
33:6:86|7䞼J1hyu*`KO_^ @8234:1:xVQo0k'@iO%S*rXNe;۲_KB
34:2:0ibYo3n3ˤqR`p#"}:|;Y}kg4a̊X@ 0Ɛɴ_~sWJhBJxF90($As"1&0x2V
34:3:
34:4:N2KdaEOp	c2AFsȈLW|Ґls)W5)M!Ea:pNe KRnw?O{oFB3ov7r>@`X}FУt;X
34:5:Vpk4ʞ.vFͦ)w+hxAI~婍!CH&/W*o[}`a$}<Xf+Xw.*
34:6:u2M^mMԆ	"^NUd|d[kò$xpɅPM+QM1h:TtN%ROemD٬8NODnGc;\rjY)wE*&w7?X[[P%qu[<gثMu+ܩ7uʘor@q8/|"35:1:xUo0+H'}KIH݋ekĮtibE}}KJlr1x۱O}@KR+xZxY<
35:2:n`݆V&%ATA]Ȧ a@Rv»?Ekũg0*Ī$k<"!cױO"c9}}%؋,	FM\0dv쒊mC$L)ath-*.jPس{\a?fjcwP3OG/e}! $^tMpBg0iSay=.^AwM#l\_Q5n3PP3eFAO
35:3:c@LZ&
35:4:հ}~a/ϫp	4Ġj1E;%D?X6Ldsqv[37[ 36:1:x;0}
36:2:HBg	HMfҺ,s7"1Gɨ*		J[mGaШvnFғEtBѠwYxym:*iemN4̅:ojNح=#M~37:1:x]Sƶ3	SBɽHvNG#l~-#ɐ4>ծ$4[/gϞ=_Vg?:'GٷϾy_k+s?Si5l}YЍ>ͭn6qs5QwU2(%+[yxzi/{P;9mO֟%_oV(u9zezN܍U`t:
37:2:$|u~`/#q]Q?6'a¼n|w?7ý[m X[QDv5%tco؍w~7Yjme_.zJ*VAS-'}^ݒҟ)]wv­va5b!,"~ƮinnU+1ħ]to* jJ S-J7LMYLen2<Qdx:<N3p(,Oǝ\%on(UXA4>@@7i>Q-G|˴Y',Q	ynx$}Ԋe]*XRBSLhր
37:3:FZ4}\k؏':o772kV,G0J߅5S!n̩[YKс56S~è*xؽ3yG:Q50uvPlB3[ȏ	Ĳ2/zFH:;:RU;W_呩?K$</CKָaJGVն4V$wVs4OI'b̥vIn7[FlWv@ibЭac(_~lBaWɶnU?hl6g5]pOqoOMJuQjv-:\i P*`h! ,Q*46xo050(i?,JAh4~o*xa,Vժij6TfRu]{ưE{|3K-MfU&J.i_BCM;uq4Etw!$DVy<dFA$XA}xS(X+xs&ܳ1|dQy++rR9Jmmm+ǋGŋӟ!AOר&ᄉ"o)|ؠZYXп`z^Gv 4zA6<pώU;Tk/!:Dı^EU4UDaJ}(5zd Zxx C%qХ%0d0VSXCЌ]T*~?G\APǺk٫	'\_򖯲zCzJ%vj%]@) ɢO[{H.sHlvԿ=	%ae],rx//\nllybLQڝB3Y&E/b?m{$,(HLe}vs'WVML(dwh~s-f+awN	daN \s!Oښ4II$w<66j+nm^5ԃV2\ZSl7HG(כo>-AqLUնMz؊wF
37:4:WiBdH=yKh%RߒlC,Lbv_Ki
37:5:uk ّ˰8ٙEat7`@")셚7gޅ_ۨ+mMy
37:6:8ᭂ
37:7:vv*L]+|3X"ؙW]|EvEswjJ'M-YMYj+VDv[f-3ڼ4u-38J:/iJSٺѡ?Plޡڕx[3XٳE6/+"V&;Ex0uLM79vOˡTmzCſ7%\9/la.l"tpa."LN"̪v}%f|64TKO;SZ-2$iaΝVsrH}T+IY)%LUsOMRon G̉礝`W4QY3<Q7Q;[8*eᑮ8Gez$YuܾIƆ&)KRLڬd PT7@fGL+Jn¸w\ۜ&\]<FQlvF?29.?&(emY}iT\"·עn7"[礐@}"h//=>ivJǤqፑH:+`.%SM'uİ$D-wC>!ȯ1M+dW&ܯS^lg=
37:8:[RmctRmmƫ+YLvڤ+'Yi!pD!RZHdi/\:i'4!/\O+ŁfAxQKfbi0qCRw3cog0q{gnåJ
37:9:CTU0(UUjrZA<%5cWS\=1}ߕjS7ӛY[b#-0rD.!ԋ'W$vVZ0Q 5d%S꯯QՕ__pqFTW|v&,r	n8>#OBu1uY}"{I(q[qVIGo1 郳tK'8N-䘯}Z)Ƥz;^(3`$; P8-h։v,%Aix[V@PGq<T({qmkt
37:10:Ƨ΅ O|I0&؜ y8q1:+BNTT`IQ2`O+NRoT5d+GEԇ aIg-bgg<b;+fS)y}F}̘SİPm!a0Ъ.ٝ{e eGO4lAWy:d	y'`B'0P `zU'9)YP𐥐_LK(*Qr ="hKP$_:#Ei4	m0΁$XZ' )1a E?4)K>
37:11:<xy@-C=u%KYUj@$HOcݥQfJHPJbeI?B@6,,*mFuI0Tݵl`gfP7	2ћH\{F?HZoY:k	%bL)<Ɩԗ {zEPP_ʃ h&	SN-I=%iLϦ'hFf,6|=E)v}9	 / cx2u6|'bWO;r8ԜxiZcά	5~^ªsb@9џ̅W "/ m@8txU-Twe1MB"0H3w%Cw'rI[
37:12:!
37:13:U*-6OK2RC,¶n?;ьt\$N58MZ=c5L;o 蛁]$9v5_h{p\ZSO|141čz	\IS:8lKI?7!*M7#yx&ԔG+Oq1P1J:y@gL싇|A<HRg׼!q{HCN1RpJ1rv$zNQ ߒ_`p"|pU.^=8u*O{
37:14:(k"Oac/-(zǟ>JK%~5kes{簽S46!LlH!qa3Z'FM"biXL8Xd0X|
37:15: ;Lbloc/~(-1=vaL3nHOhD#ďޠqc?8M&Ԑ
37:16:@<Y
37:17:>N
37:18:@jΙM/NӖDؗyҜoz~^# C_[n d\{(uԬHN]%Y6=\^1yd	]czhqr_TB');%.9.dxs/)h.|n
37:19:sW .;݅M+y뾇zbzĘw׺svUW[luVwų'n~~ëk}a*ynqԻX{v4+1ne#v?_SP)c~:OH@D#%T\z1̹α	^4ws
37:20:g{hNV8ZDZlzéI,@ϔ)mi\N)pSٜٳeKyy)"?YPgq)Er.mqO@2f]ʷ%R++'\Z2I2I8dߕJ
37:21:^|$J@J4$$JTiDʭ1yS$2Kh w[&Nx~n^ih2J~T)=KhV3I]i=
37:22:8=̘Y XhLGOg#ߘd>ɡ3^RUʠ]'&0^^Yi7&h~-I"fׅ.pXi։Y=eO1$9۔ugwp7	'`9uiUthQn.[Hڝs8iq҉O;q:!ݸtP 8ধ}CM.C\LѾT. h^6JPwyIyv9y$΁?<_YEc{rD]EPSu~aﭪ% 7c ƣG@r;6p<;bxG)GL&ԬiL&tvS<8PxGPٸl#G>l2{0aI	R#yu}8q쀠ho	p9u&iԁޞrP3^A@8U~C]'9%,3BV"|e	NA^Pи]P.>TX׍H+j0uU=za
37:23:*`dQ K,HƓ*p4ДOrbe|  aB)4≐'xOƥaW1&pʽ@ic3蕀*i/>gܒLFL,Bq?sx1WPѴCe7h*>uQNuipNJW*++:Y
37:24:j/)̒KUۥNїK鱊=Z\hjm"R ϑDET֚Y<-TUKO:`>iS| cyMъFڎvJG㸋'ıN$Ŋ.2P+j/Mj6#ݙJlb2)m`yŠuS1nLc*q5[ad LzVĵF\S7` t/;^ ӈl%q	Oܑ/$*N?:tu^XJ94_љ%6: kresi+:QjW.ZVeg$?U=:#^F5jFϧ]_Y|A P*q57!nJQL(6(X"-"ǉ!~bE#KA%MaŪG
37:25:i	 -Pt1FA@uMn[_`=/cwvx
37:26:#n
37:27:b!2Vc( g;ZF<7뾸KBt,:XiXz+zvvr\Wv7	t@`K]SJF_U+Áe#(-	4RN8LfsـkEX#,xZڤw8LHHvvip>HQFczɝ/x5Ek`j	F!׫W&"pb	:bj97D4qU8#^vE	"\δi8K`
37:28:qOMQ+5uER'?~дLa9}^/:J!%HsqǅzN'd`0_C;#X7XLm[8Ť,0Vbn)QAM;7ٽ=@Bݑb7d݇C 	"OgLt0#tsnVM(#Υt3eHKbr(m݌6f~Xq29.	u9- oq	Ԣx녧2Ե3(K*&sٰuqEFO:+/ju0 ^?9S`Wf/VG .:w10Y̎$b߫<	'P9#][oMķ|)G|׋4E:VI ڍV^::^\֩s$=ZrCwoϚ6OabCNsS9g8oŊeA'9viŸ~ޝfIDF
37:29:]Q=cl<^cԒmJ,7άsJW=#bɷۀņG43y1!cô؊.X	/F^6'=,7Z̉YߨjY,<Lz7o4X統TOaLb(?PE׉<Eٹ!{nh*k1Xg 5wN:c \%~A$-.Q/X23vM0VxЖD]>5VS?~^1Íʈ(dR'^])yBMF!>s]=0='v4 |ʬT߸kkAee^k<|$
37:30:f+-!^~g^p%YVKˢ9Po?5-Ԅ.ƾ`ԇ)>X$yB6438:1:x+)JMU042d040075UH,*JKf`}N+9KdxgQd0$nߦq'yf'?<;qEeFjNAjQ1P`mǧ,&#+Ēb{ig_/6VxXM\~Pyiz&NuԺ\yTUQ ]kfJ{'p	lJI,I+S<X_Z`ZYE\kߔ`ʙd0 G8\,CĪ+<J%a23/3'|WL̒qX70757Is6զ]djo0@S@z)O0܌&Ay43%\M:tl&5HѾ\u{뜾gAdė'F]e(+ʷ2eikSf4YqC"Pe%Ey@5^y5ZERKϘ/KE``ɝ1>	W{xPWcRɫGq'GU6S'MX]Z,L@$a:͕a/Tfd%f>ƺ+_:mgkR1%)ԙ`q6;wE
38:2:̭z(2of9vN)9MKUһg0(`lӇ5	}} t?'"Lue)7 U
38:3:eDk]]1_BT% }ol%sWv/uRu+)V%!˴U|3#@r۞{J^Pf++*?o ;x39:1:x
39:2:0 =+.ͣi
39:3:"E&ٴ=A~"gÄeʸM̠+kPAmXɷ5do(2V)VNcXOR{mQg!2`~\>|X2=W)A#QE+"nk|)7O40:1:xmMO@bp	`4hҘ%YlǯRԋeZ]Z'x%X(g[ JZ%X+VB1.`66 m ]x2o?W d׀Wl|p~x^,!3Y,y ),e<O)ߦũҘSTƵ_4 _~X1|T4jFj) ͎!k/41:1:x}ysǝT;LRIjMQ4%ErANP 0 uX;(JeW#3=}O|?ݵ_o|ߴf`N?;G;{xv(7հ;a<`<݉l=o׭`6tGp<|sx{@I_&+.|o0*nL&ٍk_z pc6NegUӋQ/5M*J8zkggoxo~tVހ:իpܯVVCws8Gk۝Gãͽnl`wV'@wOA<n;RG'G#yay|Z\+۝<?>Axq]N?~t5kokdHB]v;O^8vayv]Co=icϮoo_3oɳkbWDʱלMn$n|/;O;őw崠lEZaދs ,Ǹ6p-R4I_.|9.C u./k\"I=U܇&	KVQiJ8RꚨQBC/KM?hvv1_W؋ռo&sPR;Kvaʀ?;Tp6l.io<!n0A~|%ܺ;Ý;wkB7j:fa|38c'Uop:@HmD>7Vj3ygմb67 nr~+WU>j4C(
41:2:j	;s՞N%in#%Gg@Op:Ք#dɃp0hFmPU8!?]q@AgηgKQ4{|pc=<?̻?;g¿i`"p>@㩻
41:3:s3 vJ8R<	?':'0#`kv
41:4:k!ho I%w֝5:fù6v"+wuNyZ8dVkƸRUuڻ{Q|BƆx _w|r10
41:5:NFUWr>Aátkwd0_{Kk_n"8[.58wCanl&cmwfso	Ĭ	9µ-|lFӬ/i]G	(?p8&j4x~Ϋ|
41:6:N+Zb-/XWiu	{2t@
41:7:# :!d$
41:8:Ԑ(G9knW xZ/#vZSbci Z&ІPBKa]T#ɺ $
41:9: ?Ұ驯6 "]ǳjXfbEnW/5;hhBYCVw%EUMxYPn59Tƈ81rƤI7D@? 6TִZ9	 TߙD\W2GM|5tH9S*ۋ}w+ם'M::l?=lm?ކ{+J0ۿ=͝vNgt7<L^U8=rH4bjl'@!%#ID0kYG=S%/Q%Q'*j	*> ۂ-BէO(HRpFY?=tZUU9}?|f|<Q	7Ȫ.0񒥖fP
41:10:Jț`xB0wse`:~1Ӿec%91m1K5Ff9	٨Exz?=֤~o^6z x4~\Y4|&v7N}V'꾴P9ֹBy򼚚sfVʥd<C&`Ɦ}v 	`^ ӕ9,`iqdb;h\/ans3t0]e>ozt\vn_ʤ#S<Ud.Q2$ULUCK U>qD`v1^/ R*C~o"ΰIF;\	:z&S6_~QԑO$?Z{	l9i{9qh8b$um(62b2rUfP+Py!|)?$DЦ;Lpatի耿{-#:/.̮ hH:QW	e(wh+F'd|2),Zpjz繡T`:{k&B<B$<Jd_}f*z6b!61No٪
41:11: `V$wVKsSLk0s^.n`Lg|"ИMTZSafT +0g(@rkSc  E>Povv6qzª {.|ezbef(vfe!9#¸I¢*Yon>ϙOp7ġ &Wzʋ" Ԭd)R MzZX
41:12:1TuGfHxk>e1[',0׆+E"g CQBE-)9MJC%j(y HvQG8$Z|B{Ua9v'}欂M.VRhavGD.փPSx,~ybglDwZȗiﰭ `8ߚ
41:13:νkR66.;sˬSB]2JQR@3:ͬe9o6AC 
41:14:qgNh1HCz0RjwŲ
41:15:ځ餰^Py "@{ׇQ!f}⼻ϬЅZ W:ysVQ̙	0iVs7#g~?I=^wwW[Em$IYtTgЗ3r31ߝFdaN(͊pZB"W1{_VJSzcXqMW.]Y	Ѧ06Ma3
41:16:]#%=VIwGa<bJاh.UwF 2x2iűDko,Y+XN)0h!0H_x{+ `<vrnKI;|}/m
41:17:A:8.BlWX)J5̰' F<kK(4y})Fed}nX -,bl%JɺݾK,T0DNN1yjAԽ&;0XX+&Q/P$9A>oX{ˣcH"-kQ	_VT-d<J%ĨVa_[ZCVSEkVv%4tN9f+)`Fu#>&/):_;"%AtƼT{ˠ~/uQ5i)Yh]1$[i}|tl4NP9&Ҁ<'<S^6ȰBe/!k\FJ/qbed};)5tCDCa`~H:x%̐r**'\*0R9DXT%+ԋfʊd~z,704Eg¥d8󖔝5N`HHQZE>>H?җeF:< ɲ)(s* ?|j,s$*Dqej 6+x@Fl !,y(ci\Yނpi{ R|ZG@y;XKdtY ڪp]dԛ屬"O,`>tCq4gt|Q88PExhG:=Xk%lQsŘZmQJd%P	&U12=#,%'/yTʃ~h9G2@HÀ=Vxjj>+Ȣ+YP3xP \-R@o8Fc[Ĺj1R6MNrSœ1PZ|`h9Y	p5XW&;2">eZ>Vs[|]VLk~Uuf<l>k~`s믭ͣj$,\ܐŨdtۖ[_Kkw1C;HgHD%@A"( *A! ٴue_ŘIRnhdvMjD|Ǌ%	5L}5k1'(pI+ie/Ror-&A 7xk$cc(=V!eCI,G}s$`HB?JaMdfٔ``RXCǅ"Ϋ~(4^fO8" A;)l'm!_+ ~ʲluy
41:18:T1(cl/frttm1-+iQBҲ3 ,n_<T'yDC3aZE^o!$oٹbY還!1cE%B<^nHY_<|c%J*L[ #jBUE4RrD|ZUFn$| v|@]XmIc3}9:t/ "rZ൐16p0!&MCKTGw>V?EpX Y`viR̉m L>FL3dmm Ciŧi hq+b"5K>RRH3mMh7G8ҠzUPA1򫙾q݆Htsn[tiJY0x x=8Y~Iws54C,UsSb?G	J $?*ic,&TRJWFCT^ z3Lbqt%/s&9_X2וrf(J-NML|RM>C8!DҤNGƻL}NO
41:19:je㒖=K>-̍E.:O!iNGٙ<ę2+du
41:20:YzUb,T2?/Ҕ:jzu$cBu*WV$J2(|#y<p6D PMB%N{pmny|oo՟nۛ- "_?MSLJaΝv{bw(n4qqpÉvVP(ŠSE&d(${`	ii`$@ҘD"NHoS`VNxE`p>)ύtj@@|%ZLaad-CFfehEXQa.Kl-I%>[6nVAl\u/M [<eh`/d_r<5#&My	匧]('_tpZaLr)`	z$E̽ry`x[¨(jA <A6籏I91^-Q˃)!fJ(FXO*RPDQcܢ+?T(ml'::.;WW_ia3´kXNiabJ#-R)gfsHk9bCsQ&43M	h]lY5|AH'CH"HL|ʁ&MB f`Nκ:SW+^0a򇳬-Xk
41:21:̬Enh,G+)<
41:22:y<i	W+W.RiyL>w7I7^mDmV}(=	#?>Ƨj]*@3z^떟θ,|&5<
41:23:2EѪEpB9;0'!EϢS6zmRTNSݳ%edG<Dփ%|Zòk}EL/H	c &*d<^onl_%:.>֞u;(tAƖ	2ɢ.{NtiviHK&T{nXfAx	3̦;ïDX≓NF$)'J)#_[U]-]16^pݹgn&pc,Rە[$ JDPhWA߰#Ubwuـ9$_id+dD"+Q{@Jw-Ըmqw?Rc
41:24:;kj;+r1lKuGy]v6o0R to	$zSOf5y2iF\hBjW(DZXm>?L :{ /LK9+~?+Q@s},|sj]Np;5oDlz,J.sט%g"@n9]-.QpB874.΀xinpWiSLUϔp9GL!L	N+DS2O<a|rm<䤒cT;)&P9!+e trpSP`Onm@?r[W6M%Oj*nX]aS)m9+g3^cYl%P_vEgcN0iXȖ `eZkiG9o,mX<\fE)HrQo~Xz@L_#~{K. %J90qV)S=ONuH&KkIpBܬ/Q
41:25:`9!Cu5- 3BF\5<8AKƻqi$tK̗oA%QaQi5o,ucrXQUa&eyu
41:26:kkd]CRS<HqRP{F5HbP=ʉB.L2rTRѦg#W+u2L)Q-%:fԎ}/ǦM$zT%9<k$aݙ3bwh\TS=	%A$+~`N"E^߫x>@3!Kb3^{gLAH4u	4	yD_WJN9&2Prgk?!B&
41:27:'^vn'c@e6	n	RAA@pq΂0z>zwV%}Sƿ>s!3[.IGv=gM9)=OxD%0INȁԘ1kwJR#iթt!	uĝYpġ"f|1U)HX-+AeTvL닧4 b2
41:28:7zO<a%{%MpWs+"n_E!GapYØKVw$1#M:H7E}A~ﬂ0$Z_
41:29:D,*
41:30:2j\e2᧟`CwupFǫP<ύ+}e:@ 	rjg0`[709NTcCj @?ylXvy:`+uxXo8<0-frl!EesW	ߊOYj^JCdaĬTNu:!C"εބ޻^n°4l8l1$FQ9*Q㣔lУvl\.78P$d0PC5ɩ56R\Wc,USȔG
41:31:q
41:32:~sy`徧VbZkQK
41:33:FxTe9p't%5xU6Eail8^9	/ 
41:34:F;+qt|jzOj?r\pUEp)vR\{"qm,dJ6d[XIB ydf`mNyo޾%oE`5Yҡ㣹%]e4=4pmId4;͕DC+T^ƪL=Q/Tj%utE'\ڃOˌtUOx(nD0j@G7Ӆ"`Uq(J	
41:35:+icP%|\D"͂r䐂,Bk,!LpSA$2N#1֏WQQ6q3fgA C!|Tb!<Y Ln=@U'WVIE`BwRъc~G0a	i$j#%	ΕCb.2$JCI6i|i@o? UkPиF,~ٱ=;Nq!kŜ>U)J]b#JپBoI<Ri% ;yԹ=?<MYKqV&d"-NRN[	h_
41:36:YP}"HuCqQRa,0ncJtyPnso4m]QXK_y8]aS-A4Si
41:37:`:cS1[q:('Hᩉ.!VN|}KҊV)xZæ
41:38:FWW&)WԲ9XB*%±ISq^mQE<@8*YeJM\Pzfm!$(aah""ߨlʸɲ	Tk0`IٰuS:4(mF/d/|[5(䫤.Ǹ$U@ԅm@ !fঋTLb\SĴt̼/ZGEpYRƖoiCf/9WЦ^ 0D{_7}}J
41:39:̀a kN:F7$i<Ԥ)<Mđ*Lӝ|v~z-W ff{g4(MMFb I\؈ z8>r\!4IJj#~A|JssH3#H\YفۯX Q1θE/f)/k	`? GAnDcDՏ$ڐv?w!\Ue1*kTdjIz*xB)Xns֭6n>uocu%ʮ;̂\4P@ r[Bo}̸-l|߼3nvzR˻G,/(W$,`f~%r^wɋp,ic]Q1&OFF.?f>f/ ?fj/T/xLKZЋ4_rmU$ϸDЁYI-kb,T׋dkݰ!!äOi/5A*J LgN<5uҚZue_+ f!ة,ErO1C/Vv#ZT,jN@EbI(>%}3,a^DX#dr).]/(.xkkەV1G罡9̡%]Za):,2_x&t{Uph4ݦt5;5rOo뗓SRSK8םSi}:xS<mW^
41:40:m$P(kT("keUJ4"Y	P-Vl15X~\! GKc0k|q[z=ah/!	c9vL\Bg ;-w߀3`;}޺tXZc<B 4)Ɨ	,^ij4xV.4quVF0?Hu)֣
41:41: A2p:7}3n}}Խoi2D9
41:42:RqNn~S-5GqS$HGYb*Kua/Jѽ,/GT>[%ŋ.́T'Gؔ׸(<0iKMLldJ t;QR7D!j~V	h-(zBJn	@eHTه̪x=߅eJR~.*;Vx^f}}yTf)X%@ÖU照/1]pӌ(uvSfֆByZ\䋀Akc9\o|x6՜y. 5 WVT7j-쾴bR6g@T69^y=)ڒU.MGu;2w7+kؕ*r=ܿ/c+GxKt -&tgkT;+zB,,j¡euʸH7t8,P+;hy9x\ܞ]~{ȕ5/YVQ
41:43:H,T*wz5}h:=[cxǹ/9եHHIJ,7M"j4ֲh)@؎pi-IС^CҵgVXWQKTmϯv 1OGt4՗}Њ*Isj[#ph ^Z GX$CO6#H
41:44:	,.cVs"
41:45:jݪ@$
41:46:܀(l۾)bB/xݰ蓏R~_pzU"1e$sTo<6]w:q#aFn:ƝSPvJ2Ip<cIBtҺ%&i<OB$plPXh2k*bp%C?,:stŅ:N9t䁞Bѳz	El)9&0 P4Ct2* 0#HU U|1/:؇GJ}D*J*dYڲ@<>u| dQ-h0
41:47:?̯xYxQή?r.sH~:Sb>|Ӿ%psgqE6߽> uW"{eW @np"!}eil]-S= 4~xo̩8>oSDO)4ШJq (ѯ
41:48:s.[~F1O	Ja{3EeKo0zDv K鯬R_MbᔄT<hk!Br4%q4a
41:49:,kF, xףjNbfAGwOjC
41:50:lb(ȹX|%LiC =;r_`lܵ&ȝp4FTZCJ{s聧ш}ЂT`#S5fxݧS3&'K"Z7)yN6<c*?Ev"pqߦixk j\s\&Ms
41:51:
41:52:|&+-t,.L4չ7\$AoICEO<ۈQ~<g5{ ؔɀpؑg-(.1hNV{!?R: WV؂( Pu'>Xx>"DngU#:efo3-W(G:MskC<sSϕS4pp539@(/A=A ܴy5%C6%̜<ɴ,b\qL1
41:53:ZU-wZM_]U\ZykeVjD6:px^y1}l=5HX4RC%VSW1M4[)	4w|;FPY#q'X+o*QB,U`$r/%K'm+ċk8s=ʻDP~[z_wV
41:54:-ZY)#Zi )AM*c%K+Kr`%Tl7E	>EH1TD -UvB33YK~5Ղ
41:55:V*$(`1XIS,VU}Vh/ᷦJ9n͖OALkˣF)KU&kOeL᲼LO>F)%Saiݢ8QJcQJuYufF42:1:xUMo0$H$Q7$z)mnɊQ{Ī+۬JIs(j7̛POt幞6\ib,<7U%џ4ZĸL0vC-T1[Nf()tHu S7g07<ZkES2=x)VCH݆	YA͖dNH;rއ=WP隑L0!\4[C纖JbbٞrJWXi	
42:2:j81U6	G^$l0f3'/rD1	vg0i!Fʿ_fF)-#xW]`EGё;|0{eJ˕,̧vFKz[=$j{Z;I*c
42:3:^{SC6v^kWAB_1Y~
42:4:qp h!43:1:x+)JMU0425c040075UrutuMazCl|sB;PEEEzie8g)r=,35wR۴A06Ҵ"a3Ϭdzr=r'nH)H-**q<݂;dwEQZ\X\`3ņ*+49?/-3]/ׄω.w߽ٟZK"j**76bx!k5LiO3PU)%@wwyjckUL!`qz"A94$ehXue}GY3,CUfe#㤚	֚Y2nSf5@U"]~1aЦڴkSLryXmhj(R6rV1ow	FQd0h8/q䝫B䁢#+5`ruW,y/ڂ\(?qEW,-PtmX&<+n<0ybhX(3/hT?]]*{e)hT5,?f1٧?᪔uAQjjWT
43:2:=7yU([jѦ>{j9$	˴ܵ_k(3Z9,j8!ԬlgXyKgl͗Y]*:$:,fH_auUEQl<1@.0%<iJzt۽cf]%>m&ѰO?~|Dd鳮,EݸCFJa̞?5s͡8;+ݳB[$ʎqNnEV0e݊}7?dPob$Hrs|OɋleE-y: /*44:1:xSN@$$(mO ˆlKK~6Z{bN/o;YgFitk õfv(NgwSN(FB"A	$y9hX|y+8Kz	9Z?5{Ե ++Iq
44:2:h5w4{}eX|t'jF:-zkhSʣMIɊK*l˷爏=AWp,wID}6~nsF=8[UmߺÎ`˟?S˴$mb`/é&%ނO%m45:1:x\moHУ]>If3Ɩalِ坛 -Qw%GRq{_)ڱcWL,z몧XOW;
45:2:?q()&Xfi7{?Nǃ!WtuRgE&")T)z'#|ݟYUgI]λWz?ݓg
45:3:S&WY>Y:WCY˽y'՗/^>$zICRf"5~N:HTҫu\LWT]2MA7'G3%֡Lm%35TiUI*&YRSusZE߉q}sT}̢-WU٧Ȩ' L_i$&<2^&cHGlPyQ0X?C-H_j.FpcfZdˬ^'E,gezR'1~x;iZjRMRT*qچ}*R<9y!Ն4r>4.r/bxGhwG9g㣳`>s%0%W*zeCUU]։`Z0o0nx~t+uINLL9ZY=(٦I?YB16R5{\'O/`+FXZ'E 0_*G6.ظ-5~?h\n<4mO3`[}M@"3`8Ǉ7zw `.biX/9}+j%4>^=~tbuF%vf
45:4:h6Eao	&;eYe;Wǆ<GjFx?;9cg]-8_-/s<Pr8P:Dg"֞!"]X1CFs>nUGD܋;?F"p]&2ds,+)$Q]uo	'>ҏ`1yL3(
45:5:WJ*64uZgABQzvtK˲(i1)Sr];*hd<؇~:|Re:øP
45:6:~;]Vp{e\MVBV`vcuCmxN5,Ym6C)YoW29NhųnND󰚭	eD0칑]Kpv||pl|=2/BړE|٧߄u*ot::0o%6L5Ϻ=TYNfF_VnOj7D]F19S2mj|4	{޳VW`[MieuNYЖWZ#[R*UpUL!`]c/A&{-
45:7:0p>XzBVQDy|En	~3HmȽ'0	2
45:8:()/WTl_' $
45:9:LK	ŀ1ŭmNGъ-aopt>2WeЧ#A6VȤ?o1lB|vBrjM74jH>eh00)r -YxhP#'u{=,S>ғkL0iB`Oѐ!]gZH˹TFiFvIť>g䢐U!<^BK'P.;iS8<N,Y8}DX8$i1Cf61µu"F"IʞZ\A)qM!hR޺D\P%a*ӄ<{$T|79NFow&x`qq:vC>]'ғ71!'W񙢪)(MUJ@:C΅D5A BLQ3BoJ}E:I[]*̣q$(庞"X$
45:10:!U'\ݚCg(+082,ڿpKƓ^|ɨ&
45:11:A>tTigE^˴l(HI]7{j0S'SZ]QP`AsEmu DLz)Mz&^_>Hgj!h둍~zX !~Sc 6Ԋ*CqC[$(c	XI+֧XK4)R)j
45:12:RL!5?钎>Rk榞]?~sw}ӠaI?H8U^w1	hm'eQS؉{4tMIb|H$tAH,	.Xt5Pɗ3 xZ&	׀F)`YGa_1U~cs^*9qD\Yq/eP$`r]\'ڛSG=T**Վ	&}XTPovO!4٨ܓ$Q;9Z"b ?&IK$)C<m(L W5&ٞJ;wK)͖bg*[wѹ#:w7!UCc3]ms;WN(6s.lYTrtd>/\Cy0P>T16YHj<@M5xsR2<ihdf܁pE3"ruốHqpE{tAX:L7 iBi95yl$P>KT4( YV[0zdc uDu	!AO_W$u#ႮA5t7@BT4r?rkm^ᔿ0  yٴ0l){pwlۃuӏ4V$lZ
45:13:[2صu8tMؒ\jGj߹N7uZǶMHot3G u=+8J?kY4c!/g _Y,DvR64]*Lz:Ijk[3i۠hU?txz%R$	@n>tȢ6"604P+ݛAU@1*5OYJftPc-`-瀗W6i2/ ]|i8ml7h? J<K0A^KLrUߪ7c!hK?HU8\yaGM 5TpHю~W>|')4Q[TJ
45:14:y#Aח[GaD3{eKF祠U4q}:Yqւud/ b%l-8ALҼcp`,[P֧Z<qȸ9KU/%
45:15:K9pኼEx5	=@O蔋$qpN(4]f;n)$5Ar/W]	R,C" vW(<+)؆G84ٽ]9Xp8~p=_ Ƙh$n~oVЉ721#_7ujO DwT:1*A&:Q~t_W^g7qݖ><C1m2rk:bFt3F69t.8T"ݼz)"x'2d[sOً15F8*@亵V1uɠr聻|
45:16:PDxfv"FR4Iݞ> iL50 hx]l3q9-؆m%^)Fm.FHz[h+0%+tm`旸xNNei8uE1z~iB wxm  TamЁwh oWHڀ%>n|h'T6fh־v{Ps:if}Mj9
45:17:*Qm<:>_+evZ&6@ro1C+<0޻VR5ưuOQH-A~=
45:18:ivd2A3Nt0	L-d;ޫvu9 Dk`](Ȏ 	PPS~μK#R	,U+pMXq*%c;mNlF ]$B xm~2ڭD2DRBAgi=?l%j%QE~{O.oBfC1YjllgB~q[ߕUI+23%hYN3q~č]@k)^fKيcp!-5]þce3ıAIk//Q"q`u)6",3$jWr\c.-/LY$w{%^K LGa` ~BoOA&,}C< ,7mRgzi]誡Ǖ^1#_.fCE3}m՘37@>0lFK)2{}z*lɁ(͔ZmcE2zUck ;/`ċ4?*wAX99vm|>C-"GM M{QlF[0rNXGͨv,A}et~UaLYxkXܐk(046:1:x\ksVzWz%m74tDDep@ -+$+i۩=qx9~i>6/_xp}?<^ɓEϟ<1L$2y_dQjd\Dŕ.,S2K)*|YflRaifyձYqW.Il"`!('
46:2:˞!4eQYe>Ņ@q&+3TqYS|`%4,"*\4/q97d'UWi^'4?|h:E]7Bie1QdGOGE\.+F3"HͣI:}J,Ei]Poy˅zG+Fϳd>MSwCst ș-qfV#W9i,Z)x;<O(]2n[`KV$$m.fe2Nc{a4t3o;] Ħ^uh
46:3:l㼺
46:4:W)lj" ԏ&yVE	Pe4$e>I*Ԗo&9\ٔdWI9+$S1	%"w1$ FEy=6?y6c{muw{妀x*)4/+3]sroa&qYDM
46:5:G/*MOHh!7/揷EG40{rmZ?$ٙ^BxB]DWeM>8<+f^4"0ei{;j-ڪ0y9Z{+§OݮQk˾U5Q%,$Qö5\PLJ*)-48%ЯQ9)bVC	WB|u;[/6^f0QQ_Ҕ
46:6:|x
46:7:֜W&g7bAq}Ҕ^L3$7Ot)5ds(SF٘ZW|iL+?euӱ?.+Y
46:8:%rA^t4=@2lK,Ϣ!)fbmRh{HOiMs 2{ɗ즳$ڬ,u|瞍&)l_bc}~{AȲkm?kǽZ﬎$&ۚG]IAP˂$}X{@4)y\]Kayg7}UB8Q<- Ӳ:$W(l9?ymd}>1@|;O;gv"**JXb)
46:9:Ч8a >B\G` rKvb$'Y!8QbIR`lFv꽕r>I,S`Ss03ˬ׸5S2l@9V[ph%M⮇^2 )GlVyirx! B>N͊|.[U2]] Z
46:10:Vh(MNv0/I8Ix3øMd'OtV3}ؾP6=}HMr#: M_D&0|Ș*]`Q,'.IQB~[#Ь|ȑ@LP:ϝeqm;pftí54aY
46:11:+"AɺYd[QMq5z@|`XHεdxN52*tHNDr/`h/;pu.0K`P"Z!.TM	sQe0$wR0u ،W $&uBXBJ&⵳|n@VmY+_"BtzΔٻPtp75m>p~1wPpՈ4Hfzi褜DD= oϔpǓȀMQM*S7'	֬?\婕,A|2ؠ,L~؈ jtF6;jYNp0*U[HZ0`k2Jduˣ5p!HqG [k{4+?8.1TDӁ:Yv(@!QCǿ!+~z[}˗	uЊ:6^J{ӨFK>6*+|U|$ʐ3{vFGzݳQuONl{ofsb t]ɺw}׀:#w}ۉ:#w}].(BrgS#-,
46:12:E63#I7MNp͌#"a:>/BRp3!3tvuXT
46:13:%zEݹ}x]2șGGnj'IFk=[ y@֦G+X;9¦iI<(R6&^|P-ERgU5V{X$4ݷr1,,<Vv+w(j%|`h.f7FC::<֞W?H|\j
46:14:8oô"Onc33]`+Yb1 T2pi$[ #|-ZgPߙ<HoCf0thRq6c=3.>g#)n/#J]{b
46:15:IP	M/>n%[XDoNa؟(2E	z:
46:16: :WdˇX<*_"Q\^VuuD,QU()D
46:17:`HW=)^!p;5/F;HIq3~T;<^h7ďڥFN?<6O>ubՑ/(iXԙfn6ͲJkOA_@-8MB7dWWWpz !/~yI>^Ǽ@snT:ɨ=&ʶ)*/hL0zhJAsy3hR4qc?:f=3S%s1X#%n}/}>G]:vCjMyْ^Pms!AP!<fmj@.fgjh(vJ{1yʝhXA{:(Xl	Of۱D?QҎh^pJ[:ٳT`92Qh~QZ44{	W'ϱ_п=ϵ/\:S=I9|u"gF{3]JkXnŢ+,zb.:T]ʁ"Ĝ!0҃RtD3 H=:R@ĮV|o@(ϫV3l7H5P|l,t6
46:18:Uj;C=%eA#ȢC1MKg	n%zg`hGX8<m2{:3Û*z`Dj[rʾ
46:19:&<*cIJp~IfYj0!k5j?3,)-+q"WY|Wۧԋ
46:20:6Q#$L\,RvTpS'>Xѓ1HK<MQxo Xi<$+e	|/tid:+4\`^ٸL	)vmPFT3
46:21:( ;,MD"3C7PQkM8;)l
46:22:70I;sf.6aoKV.m[8J=(:<HY|3aAr	ԣ(pi2hӭ9J9(͕q(0x!<Bz#-^Dk¢\&L1@%`@<ӜIJG*oE}Nv]W" J+Uč&ʳ,l+:RW-Ykd7ZTRͦ*_pE(Nf5+PC> )l_ht}3V	APJ{pOn@މ`R8w<^ku,704Yr!jWO%^sҵoHd2I1ޕ`6^a]^[ʵVJgA$6Ø*؃5raO`6ߴnqSJ%20٤AAj3K3!0Via3Dt]ĢxI A%54LF(a7]1<(09kCH+͇
46:23:miD0qCv\
46:24:$J"|fY<i$3%Ӧ>OCh$ZCm䯓!M	z4Zz$hC׳L@Ciw_j{DI8Mjavq Rl@
46:25:!۵G4e8ȓ'+T>˱}O dxmѼZȨl=R(Z{K/b7Zf>\Of_l	GQ)b)RsVOE)\QaK/@).mM\Vc^9Սs7OVycΐy q
46:26:ټĸQHelj#%FHz|SRW,-|5)_놡X'Fؗӭ7̉7E*9g8Dк',Wst(hIk^ߞa@6Rtd$ldٝA
46:27:s*$7V$E}5JwO)(h1b+P?;4^lylMIh+lN볆{d ?[mEF:w
46:28:H 	l+k֮<r=QG=DZ},BOI_.0ʂΕfVoM\Pg:,J+B%s'fN\uxau'x 5hhTbY!WN O1y3<8FIϯzxm"~V)nVϷ)
46:29:T<4P"Zxsƌ:{#NjЎgEá%.I0?4x^Afwoz^o\b^w"KfC7anGEj`uPX|9av-`)ӽ3wgQu6*@Uւ|^-pz "eɎ;gL濷:	:)eR{ivkn6 YݘS=EgnaG6ӕX8.F.!"b]FʁuǵMmbڪSٵĪ(۟CQPo^=[Y|mrFqZ9#'%chxGF*7끈#<9:YNA9S,
46:30:&6 H0aUќʼ19g0P
46:31:Z	L?(+(dzMW/"A\ƚ!EM0nMs}t&<_
46:32:'TlS) /lH"vllxV
46:33:
46:34:DefҊ//gɕ+oݧ@RV2D?&sY~J@\G:垦kPCr$A,uuX|ԜYd;{m)%a1[*?ghِ+pGgA)<V{@{~׿=]l%*5;x4[f,4Y	5I6cTUƮ"X>݊UG)nL"sz*ß*C;qo$%~|,6GcӇ1)?٦\;!RVָv <|Pȉ8O#cy/I(+cqc	+SψQQ0r.%<#-1EAxy~6"hj)''\հLƴ3\e!{մFj%h~ĽurEYRքT\DvEb"dzC◔@Y`aD vW*-_k -b)oEW: {\RMz jP<957ʕiuX`..\oڇ?D4qm6bkfaH`mrosIp@z^JeDw]"xD_C6SqtpdSvbV"疯1BkL5>tt&*rP<=<lׯ}}~ˢ3t_Gw(zi^]zII@Ko@r>#H\aO!j<h<ߑ+;KqDxݲ)w5l0X347:1:x+)JMU06c040075U000+((aX\^'/VȢEǀ !48:1:xXKs6d\;M^zR$T4$&t0ESB{>EZ:,~(Y?w?϶9)o<I+RkCۺ"DSFG3׶Rݰs5S=~A%!x Y&s5&#XX!EVokbӃelmKX.mvDWGi85P׶,fTp^-u߿\ܓT:B&IuXmR^("ۖ>M}Dz26H*-Ʉ?|c\-E?M𙂼wHo
48:2:V[qu:
48:3:t-C!>@e 3eX{"zTsXxr,L%=4G6,9bӔ}?b(h	ycʫNoj]=0$8{WQ^-'lW
48:4:&Qy&1PsZa&K+<)Ӻ;!Һ;%Ӻ]ZjCpl##p*`;ଖ4u5<5$$ՕdmRb|+vLl^&v@'3HX>	8*O-zT&=LlZl{4m7Tܸ*f+
48:5:@4M!X8mJDFLJR
48:6:,&{eQĺxM55([M*eNB@n"qR)+$Z4 glðMdWG=TTYjåAsqwШʘ=N	;C MDϒiʘ3Fw+VLBct6\L0:TSVΰ{n[ќܸٔ>v<9D5jcg[e8d֢,Q7Z_N3NPJ2ȥw{Vԩj]ANWRl`Wp3])}C>:Nc 
48:7:k[-aǇGn.?o7&s-_4*J̢9'
48:8:q1&S<l_UkK!;!:(ؒѼ\v0Lݽfux* On'u2ڪUX?rRE9aie mЍKVv"9HQ_ðg/Ay%R,9JRdvU]%4ubÃ[
48:9:.<ktѵG}B\Jέ0/QZzRj j/9S"1unCFCK'f/>F0PLOUMUT(2#>_h^UKf&A(tZ`
48:10:R0 mk|{;ͬUnkd#ufQ)T }Y~"; ,:*r!ϲVʆ!R9Iwwְ~/#IBU4( J49:1:xXmOVW#NԐn@(iҤqnbg_j}9^	04i\?92N^#~Ύ~}H(Vir>N9M,2Jꂬ,,ɫ4ZǫxIi0ߒYܧ͓˫58	m}KIDQa"47N"W<4k۽G	8n&jBrTUf<CLfE8WFHcEY\c*0W#JJt6
49:2:ݧRN*Y q2@(&d`sVfڐ{1e:8ett~J_X딂V6)Âz8p;Jxͼ'cZ[Wz+RjANApd^v5Q
49:3:):RP@/vXl!UY(&jKٓFXgA%j?lUW{oiޒI2K(Íݳj>FT))/t@F*
49:4:]tm|#uGiA)e*TrbQMRh/ eraY!ɺP<q*V֣sT,w%ik^(X[*/T	\IzcT"A)CaTJlA9:ѷViW	8K6!K$%\+4䮟&Ei|%=<	,6Jaf!c.jΤ#]&U;6UM|o#=pް*KK!80↝j!0]p;F]YpX$xo"θC\yN=W?<?.pJOf6~sZpYFx$2٢9tr<:Gb<`"!7@f98r.K?-ULΣг6mGF8),%̀ѿ<@	1Dƃ>Z5Aj!N2AZ.K= $rnlBfN!zZ{8gKf3uō	$VCg-XPV'FY!78m+Þ<~Gq.[dzU1F]WoEEInC&ZfY`6S>-©@]z6n@lB|rRV :*Rpm2ܮ=hC3h g*v2GMKֹݵu_O(]Z^=jQ5ybrJfкt_ªkM =P-?(yk98V;fb]zemU^KVf	~uþ`>Mo@W
49:5:A+lAwX8ӆm֕ІlZ+S)	DGΰۙ$qW"NrP\O9ГF1
49:6:>bR/pv:n
49:7:n鍉_&_Jצ%0mZ_'7obon{O{coܞ-qe@""SŨi]\,b_B	usFD9W.Z8?5h_SluRX&\ >!?_N0RsNo\:IzeW[9[wR50:1:x+)JMU0425c040075UrutuMa'B==>+PEEEzie8g)r=,35wR۴A06Ҵ"a3Ϭdzr=r'nH)H-**q<݂;dwEQZ\X\`3ņ*+49?/-3]/ׄω.w߽ٟZK"j**76bx!k5LiO3PU)%@w:QZO
50:2:\mYE\kߔ`ʙd0 G8\,CĪ+<J%a23/3'|WL̒qX70757Is6զ]djo0@S@z)O0܌&Ay43%\M:tl&5HѾ\u{뜾gAdė'F]e(+ʷ2eikSf4YqC"Pe%Ey@nw	!>>&fJ9``ɝ1>	W{xPWcRɫGq'GU6S'MX]Z,L@$a:͕a/Tfd%f>ƺ+_:mgkR1%)ԙ`q6;wE
50:3:̭z(2of9vN)9MKUһg0(`lӇ5	}} t?'"Lue)7 U
50:4:eDk]]1_BT% }ol%sWv/uRu+)V%!˴U|3#@r۞{J^Pf++*?o 7H51:1:xuMO0ǽO+9a$Y|	L>cm'}Zm[/=5%LooshAm1hG=
51:2:bU,Iu;Ud25Bf1ȫtf0e&0gG<e jEb6c1|*AH	D[!> Q:d 4`jHHFxJDI]ytXZbk5
51:3:C4+IChR"k3ǏW#Ec%	q82r{&SAퟃ9ـ ܑ52:1:x\SƖ_6`08wkCLy fJh`փ4hn4a'S['0HΣ[S濭>O;{O?.FhxG=ڞegf8(Ϧk~hAni9J2|tvb667n|Y|{t|`ly:DɿQ&uk;Vy_!v<GjVej$E\ŧ0-E>Sz3t_磁-㧽ƻVxdު1|Vyf2ͦp{Qr?zzr}bZ*%oGYY2c8Y&|%cJyB?>My25i|R.;d!IÇ0b98pk6liY&L.-bA:emI"ICsGc|b tV<|$nٴUH?N@pOFrGYjL(ڈ	(ڸ(~EQ;bZqZrz#1bQ}pneE~ai?Ҝf@ͲܭjI*|RdE/ihPSN~"i,~wi9hJ=4KfakViPO̽/X.CM:Gݥ,HK7]	t:i:jEfЊlO?`Osyv>B?xB[:=O
52:2:}Y~ɧ(Vcc>n/E!(z;{9اpQf~nwSnaپהb4i	?,jo?ͯ6/1Ww]1z7"{w[Ov]d.R'Dyw]}9Ȧ.y	˷QE"Bq	7ȗȗocEE||sB,'"߄1~""~E.E:tt>"[]d[tuYZk0'c)?|c]4Ǧ-N!eELd%@/Nd]DQ615D劎!;`s\)a̩ug%SiJ(g]hii(ު*V@~R߽䍙X1ɿR|:`&+afQm4\R!$ ;~a\<Fdlrr_ ?l}M@2r'eb<X)<牡ɗRm;xhVVTܨD8b.A0I-VT$fGi$M4/iL32Ly\R33	QcH-k\jsY:Wх\rM}Y˼4@CfQѫ*PMɑJIUbv1S_qdŒ < |?[,Q,_^MR_qO5?M	oXL$Mf䧸0_6jBcb(hߒ [L9	EbAŬ*c:࡯D_SCA]IH:-UX|z~6֬@_GXN7Y̚XaZgi:=I+*2Z.iZ^Kqk4|M\?2~
52:3:[>{CN,!E~RJM.=g3cQmkktc)VIh
52:4:,':sihD*ĒAs"ո5J	a{7{C"ⱆ)`/0Kc0,v}Y GrֆP&2'	ll1 ;&QI臥Cq.lP-8L.na@*	L:.U(#t4{(N_ *FKZMr*=﨨ncrCy3@ST׎6Bj[SUVg$(AN>(G&[@	xIs`ow) jE'cf5)T G|Ih;eӔҲxڇ$gEx'_Xh^ey{vmpn3I(	Gܦ-M&ڙ` Smڧ+*)6c^1iyhK<DoCZ6D)pw {`6lNQo~64-͛5phE1BiciU9aw9/|=z\^;nTƁ9wv!SxHl4[:`aNѫh霢y`^ЁUyXe^A譅ZJxW]LW9M$&y}q
52:5:/VhZxYVƄV4̀S1J[9$VcWE*3^
52:6:+Z}Ȣ%6Z=Y_(Q:\ЏNLWpgfΤ='sXi&.^y`"YK@!+ Xփ+ ب*jsP{Ԧu:-Uc%U4aBAZH8s%@kB`h)m xIX	EGS
52:7:w¸y8\N#?`U!N.͗]zT@j/sYrW_ ~Gao[l*m	䟘%+n+Xt<F$d6(/Xɦ9@(o{Z>|#+xa1>Hhjw6J;Mo$>yqX{@9!
52:8:SԚb(Bŉqk&ⱯXZ-52*UFW+xChjo(\ˍyb>
52:9:eP3C:o`N't(rm.ݡe<ZYB0Ǖbo)r8`W
52:10:69_f`m:@NnhgсfEBZnа94d]j7@0C&oޮK8ּ+][B(jv:8+Z[ܩJfXoZmޯTr&[-𔶗\GL*+vz?^Xѝ~e+30(8diC᠍Y$#l7/4Iq&p(!;<Q!9U	)pr.mH5thYZi@pe-C1X'=T^g%d/^%Za*) goܒKQگ4V|r 	!<Cc~zQ,d:ۭm¯ɼ(B뷒X4T#p{#0;4
52:11:ipBw9ue<f%4)g3h D3qP,(JTXP
52:12: }#'I_N-˴5=l"@ZA~)+#i!p&	c+P~&z`HƙKlsN;xui}J# g !F`[gEHg0˼|ChMEeHŒ-b̳Be\Y7X@aTEGͯr 5ު܆K7D |γVifD L70>GXCċ"
52:13:փhPZt}V㔲Y}	*Lm~v,lZ
52:14:$o3CAB?.s$vgBN}1eq6EˑV>Kz|^(d.)).ɾp01
52:15:.ָ{
52:16:"~MfFserAKΤa7@_ݰxYBT3e5Zq4(SDZgFF#ߖLL`
52:17:,iV)
52:18:Z֔4f~b̚8پ:Tyn1Fȯ7QR=4.áwѸk¾`&I!$;|0Att6;[d)WLĜ"#{#+Oq{{&aa?<<VQN}ej2fPϜPk'wp|pa 񹭭y6|s)~^1ϷX>1=M.'95qhz$ٓjeDxݍc]k-ٷ=ꈗ4i>+l݀JVKhȃ~;?9mfht3<yYN̬%hɢiC)׀^S:[N $W8uix<ᓠQ,w6M:{nHFL`@vVDC8͉Lôy[Z	4</xG z
52:19:DI	ʤ<fiMW40uc/'lː1}gchR̘3pJt02
52:20:8!9N<2 (9nH|eT
52:21:uOzG
52:22:bؽ2W1U'F]	S&K.RW|C/}+u!8[}| FBnbz_uOcd{l#6waq/lyhu@N@[څR͉jo	j$rzjBup4^8Aq:3Zs\ *f њ//p.hDd;\Syx&yJB;
52:23:'f$Fbwl&cȊ@i`QIwR	nPTiEFv7;g8kHa4iRLLQ?Sa`ġ+$X[ޜ(Цŵ]sz!S,͙S܇n I/J:MWHڔBvh^?L~\,>:́O@$#nR[$W"U*l֭LNbZdB9Hfu|>(!Enq<
52:24:#N$Lb(p9iGxʍh=c$i1CY>8?Lr50(F<>Lݘ*E5`.8#
52:25: O!H5M߹$G&RxI׍p&/\NNo]YĆ*i>= :<&P6)R4m	"@*(8><'3[	5{(V5 '9iY[L2ش"*C)irr~+G|,(RpƐ|l6*K7x,tnsb= )a6dmѐ}o
52:26:3]\rjovә026Ds`P}ƻc5)\y	i>CVwʵǂ`MP$1ٕ=Uheۦ	[!8w>HGeUYx9o̭LϢ#ܚV_=`"gXεE-h1^KsdJEr>~Cl:}9~/,tru725e>&R?Jv}^M[S5}_GQy_OK=74/.*[zblqcqʩNۻɀM'V׈BR܅Jp#̧?CW.	q05a;CnȲ4$Bߏܖ̹=˪-2ٹ[wu|Y$ o2qcV~ecN1A^,`~3AX_=rϳ X-ske#.GY9ո@RӁ?e2wN2CI¢%6\{>&H1hr:|Ri0?OHq_uDXMM46xC9R@*#ToD9'OtIњ`C[G8(f:1|ơ},=UP Kg*]iڇb'tVEkIl<\=ea8N^[hoiMhXMvN|]}w8FUa(-_ cq)	qoL}Z\ MVRnGY*;ᰮb볺8G][ڎnIQky:aW?ƃUƈ=rftC?#53:1:xUMk@UbW=I@86BNb%%+Ѯʲ'{w>޼y3
53:2:x闳Ons3m&Yc74jΖl1ǻm)'!*P,s]/\;s&$#)d	{h+s{v#4ŚՑqNqq{LӵO8A| [΋.iU}JD]	`	4nOsĂeeKw-TBE<KsXPz8Q4J&؃ܛ+j6|CCz1]" IV ,2@lh"lIˆ$%5,E0
53:3:|W
53:4:r^ȩb/+D}HXʒ"g;FH{3T{Wr%yKq
53:5:^1U]oּH̈`0ɮ+x{@0	=lRk'$`1BbCT"wݺsUHɺu\/a	] q9UĻvﾳ!\5;󿑠O߉ͪTYӯLg	<GYqxF:P"fV'*Q>~3wf\15'Y,l2	r n6ϖ*9UfuJ.b*gY9YO5%RrAOMXT`~Z&fR^д%lx5]q7`_'54:1:x
54:2:0@ӚE;8_6C[~-iJm6%3׌HKkch׻(GW 7AEԃ2 :D^;^+zqpszD30!z~Z2WhxآATZjץ\jr.O~55:1:xUێ0]U
55:2:(K!6A!ZUCMUⰗq.KIg̙E.WFRa(Q~Z%h6cX&%Ve0H(!0L?*.cĲ)`E{YMc7KmdɁeg3KAvYݠ,[<C$!OBraJ!_8+$2C+Z|Ġ|?5$JB==ؚ##P,Ҁ1؃/ayn݁=A]᯼/!OakԠ'[aʇD-eeerD[h6;WwH_k?`sDݺ)>m<-rn#*lvD27.K4/"⒟XD`m($oŤp;2	x}2Wz@u	!ג/YxR<pa5x1В[[l^RCr7,H%tc'̤o}[}}>'A,%<t'@ǿ7n5kAIwb[(t6D-@zIvZI%A&[jm/o{56:1:xK
56:2:0 ]o/oS\y6@{~	fmO ң@*fŠvV3Zetye51j{jyx5|:j3eSlWBPB{+B%\ |0AD57:1:xXn8 Yuڢ\jmɮQ_%&(8CJ8ۢq@3n]xlxFe:FC,3ᗔd0`!0uVuaCA+ǧ0h?'Rs2A/g'OVNi2Yv?}}!^t -x~{1`Inh-1?vJ9!uRj/ӓ?'eu,E<9!`\%D	OȇxQ3yVN%yTQkJk.wQ(F@ҘAGKlFbh6ؽݓ}| H!,j];8jVjͻcZi\L?pFh
57:2:K;'9]SNϤg5D{Fu>fhEfϢD	0&MrEuȣa
57:3:Y&R"**e9Xǜ8df'Ÿb^5=h W&e_"u-α&~F\],<uϭCRie4YQVrLՏxBm6p;;Br1C<ή(A,@uY(Elue2׾nn,E:h*{9Ս(g =5BޟMذm|^LCʿ.+P *+|u{rX+Ǎ_nK:w5gs=Tj6ߛ"ew?UDpxԓcwS
57:4:V6WpfWWMjb\bCT"nmYvDn)!ʉ-x4&}pEVdl+[4<ȁ^=͉+4aeTgG3OZK*lMJM%{a*rqn~{V: *ϳw~tU.f$F׽Eℂ81!jK:	ii$w#yڟ['͆+ٔU+;_FY{/!rtTpJ<C=qq;º;Um),h#oy]HK	y-[6(Ä1(BK*AӥO:xıF4^k	@K4
57:5: \'kFtkv>EnD(>!f{xC<03@4 `(| "9MAFFDsWgDc*-SgK2G?	}'"Jfvz/-58:1:xYkoGE?\\9q)j#bA1ֻc(0c;3;;k
58:2:ޙs4-W_}A{ӣ	d./.DY"|6?_8OFgxvi#%YQ",+i0:L^RT'l?&sUΓ>_nv.&g{4~@dXPQI^NZ- y~*Yg-ZK\J}*'^B`*/ls;M&s $,G&<$.{YLեڣA
58:3:;(bhܝ/lY5wI뤨lH4?ymR2&Y821]'"(.P$^"	ɳ)pd7CEQPXN+`ڋ}:})YXç@qz8EP+fHYe婖_SoG[~-(lWy(L! Q<lY)>gV
58:4:&!K|r2>zryt>3xt֍5j?JQ!)Zy%XWn}RZ 8)2-
58:5:D1+B΀=,vNMkֵ,im1\6Mt %sԕ73[a2J0G%:'[E픁OW%WVTZ鰦"7i>vm7/TQ7ȼ\ZH$2@I%4;G5vMQuC+p(MԹp\M;P\I"8prf31Ylm,0aP/L%u|<4p>6/#0}\RDB'B%ǉ9HԀFO4Ta&
58:6:SʗTT297p H X`6'^"}`Ym^o@PIz\:l7Ih)1K+\wΓU?g=sͤK_k"{s(ײ= C-:%EjA&V*F4ӚS/ qi@bи.NGC`ZȇmEa*"Aa̷hRADzY>ZE;NdPN@EQP3>ع̀oU2γ/t9DFkS'*]Kx]!iٲmV((Gո"&NqlFr`?ŕ\ K/"3^.aƶ\g~ccB ~	1	$^K]1fTP#VIW>egjhX}<[^ͱ{(D- m]p1h)-[ (E2\Z
58:7:^t#z==X/q4c2xj UcQ5Ƿ#]%]A&;*x[<nHwT bh=	Ogd{~מ7ݦ+kk3p'`GdEnBX"uqe*P޶_u],b-O-!.SE\]ox{M`ԻмD8iY'֞ڒM1.H}!z<VkK4!_9GܢƖg"9׎l5>-ps+C\Q4[ۑ:/6Nv*ft	;'27zfFq)a&`0<<ç;F)ѭh7tR%-|9ui}}+y94I2kTγ[!N2j'՘l3m43	͍t$LUe^͋- _2pG|eiDniW(7Nsrmja'势|Iژj빌:74>)w;2B{|}u?talaEo>裈kz}ZjzޮA⠵*5P59:1:x\ks֙ޯ[K^ʗLvhNHv$A	5 hY}=%YsywpcW/^pu?<^ɓ7Eϟ<1L$2y_dQjd\Dŕ.,c2K1*|YflRaic,b\DDE=CHN=C`&ˢ|"*MWfǙⲊMi~YEU8vTœ4Wqe~}؋>4kC!QRN4Fcga".ieg@͎y${$_\W%ͮ͢yBl$@D,6Osw; >rfK5;rܮٻ`86xCZ-Gqq]o/Hb-h%+rٟ[hayY&4F3O=sxڵPjYPj kոîCS`4_VJeS	 ~4ɳ*J
59:2:/9$,IU |3!|"Ϧ$(]@P
59:3:ϿLҔd́]L јzO|&/,wil!7* (d 8̋#mxK)7<XVe8FD)u(yYV1|0$oR8zAWiOoBxZFBm~[p]NPK)צ1I%,)EtUVSl&Q%YI(SQ1pV9'9yQܠ
59:4:ٙ'U7"|z]l5n[UUrO\0l[ˤ>yBQ:ş*7I.j߯%?JPRL?@v^l`
59:5:y%:b7))'0EqL~φo,ałR/4]/0)24ǔyDɜ.yPbeѹ|j=H89@O5mrqe1L@<6eae !Kt_.ۋ"w8Am	\8Y4 $ŌA@JͼpUR'%_N0jhrv{6t7a~)e#BEj%~㾳:"0nk:u%"A}Xv'BN]
59:6:ˋ<;(GǑZ|i ՙ'9BYLVgḥm#٬ Q>%GdQQQK,V>5}3 508ɖ[z[%Aͬ<̺ 
59:7:.Ɖj AODWA\KVz&NaO,Z^@_"`NLE[o~½J4bz`h?lb#N7/_ų)woVs⯒j`
59:8:WTB-EC,lr2#E|IxHm"kP>qo~ꨠ⥜OCnk%i9LmM&<45CU@g9uILfE^s5D ͆ ey(Kk܁6nq8XXU X1/	O"p&S`؊jTכ,j#%Wa} :u}k;vH4Ȩd!9ɽ0;]©I,AbU,P5& E!c,O`` P fχH$ 1=>~ 2`lBxU2skjJdS۫^| 2'+DLu+iȷP&FA6KD'<%"yx3G};`8DvV	
59:9:[Ѥ;Zzs~|mUZ.ć*Ɋzn:NI
59:10:Fgn5y,'8I,Vpj+x5tm.Z(4YDh~c!R@V!0Js$U+)9t NE.Jq1PHo&E{qBkuaj'$͇4
59:11:$_f_<B#2L^uQgǃ^l:zݓ[sNk[cA-vBU[nq}nw;z}nڷ;Bz}n"tШ,y1}6?"YPh93&f"a		5Eu\}^˅gBg
59:12:* l("4*J6bsFe3l/iO'(lb%ǃ{@$MVvvs=pxQBm-MX0Z<vϪzk.BIhlobxY^xt6WPJ8]ܭͦu;;#oD&utx0v=mg/~q_pp1*iEfFg5g˵Wbe4 %;HF9˗dmA0G8YZ~.))3)1y6%>Maī鮳Vnmƒ;$(f\|FSh]^fG4AK')^,"D!}[J0°?Qe6lɋTjt@&;/"u<!EɖyTEb	XP/R)S7 1{D*B	z$R⽈#C@cowjw7#yjN$'CXj{?j.E`;~HF<}ԉUGDp"ݚ`A7PQ4wifGWZ[|Foii'B{_!CIYlz
59:13:*bZD'Tx	-S$.+(z<ħh13ѣakS(q,!F%/ JĝL)`U9v鬢aC7AW狯eKzyB-ͅT;}mB1<$	գ))wFUbm`m%<5on	ZtG%*OHJ;â-x)m1J,gR1G^=GiAӼҴ5^wOc7??{wyk?Gt6z"Ɠ$s,>EΌfְ"܋EXĢ78 ]tH=xF/E<9-Ca!-fzt2H]H&P(#bWwgsn~k.Xmw{SKG\E?.b~!RK"OxЎ^q>%.{yduf7U5+}0L&xTXǒ`Sy̲`BT%$k~4gXRZVD
59:14:t(f:ͯZ|OdmFI1rX)6nጧͳ"O}'cfҗ0ykߡT@xVIW$0_|%_Ȏ5|uVhN5׽qSSPsf8P@vvY
59:15:ЛDf2o;"pvSoH-a0j)vX5E\߶ޖ]7q0-{ Puxxm0;0;ʡg N=3GIX,Na1dD[ss8PB+7rQ aj1r)T)Bx>F3["{ׄE]MP%J/9rׇcJx9  T**씻9D 4[W: ]qډMgY*7VutZ:	<5nMTHU?P \{3k50W؝IT}R S83ݿ_uGz(!(r8{0hmo/nm-Dp"=wG}*q`"dYo
59:16:ah>,9E"X/BJ5칯/OKB~kQߐPeic+8lZI'6ú _k2땈Hl1UHa;k&Z\m?=>i3v'on=K
59:17:d*7h#"`IfgB4`a8%fՉE4#rHKkh^'*Po>cxP`sv;<8W: WgXۀL1Ǖ98Rk!`;p\%IEL܃4jyHf6Em	yK&M})<3$W`HhAp_'ACrhtX%H"g<"2ݿ*
59:18:pJ0>ABܷk%ip{V'%NVܩ|c)xAf=+]mۢyuQp{(57qQ^njaMw$k}͞^i+MJR"-R6W[#XA	L5RÖ^R]. ]G	ښǼs.n5;1!K;Ay)kq8FJˤz|SRW,-fRbſ.CI_)N&b_N&2'|FWyB랬n,Hc_5a%qy~{n[g,JQÒm/ew'+],XaPd5h4G*=*"Šԋ~E/bwhz9;|J{7%0;py;Il#g~<A$8ޡ+ 3v6 'x2FiLY$u*D5!k=%~(V:W[eX5re_C)B\[(ϝc5;isE㵇EםۺsqRUSŊ)g<^%Sd8<1B;8'S>~697]sXZ=ߦ(|JS}mhF33b]j\8A;':d7$9NXsDopIw{6GA߽uz	r5xu-	rNχC!q6C)oXLa2P7FǧxLNϰ{RwޝE#ڨWZzwa!8Ċ8/';>2Og@1$ ~Au-RREKivkn6 YݘS=EgnaG6ӕX8.F.!"b]FʁuǵMmbڪSٵĪ(۟CQPo^=[Y_čLsFNJB,	hZ?U:nG;ixzst4`r+YLl4A$/'`FpL9,ͥyc&5,s%Ja۵
59:19:3,@1-l4_#BB~ls-k259¸e|6nzߒGC|~)Ӟ<SeaOa rզ"ؙYy~(HC*4J)3'2<E%K+?%W/qjB mKa[ɼsF
59:20:b|=<f!1*rA{7AQ^FʥPcSsgQHJgPl]K;Ǆl0ugCp9?ic̦[BU\_]zt=Npld%D'-LUdPW5b`t+ZV9q#OL2 :7
59:21:oI̗\`sLdbTp턇HYAZ6ہ#W@"'`j<mj뿄'S;:X9~ƍ'Lo?#GE%TpUfH8xYşوrW2zxgpUbCRy9ueBJYSr-$uۊ_Re6Z"^e֪~Uă%)] qjKF6mTqC7(W>[Q8aC4̺lxs9k!tiۈu[Z!˽%ÁJ;zE*]ݵt +''ZQrD5&נ#9|]eʐ?]}3QAoca۾~ׇX=wݷWwz=g'%	-97bw̎ qm>h<~CyPsAwI\)_3'=La;G?>AKV60:1:x}{W[םz`4mgf0o	
60:2:Hڸ^ZB:MH8wwٗ#3vSg_~t8>\7Mw~l>G}v{x`ώƴvU?'մ;G{񃭓u|:Qf|=<x_v~ڗ_o~_֭|:_;U11ů=h ?Va#_fa~^n8"j_s[wowڏªk暭Sje5tG}8,0pV{1i;>?:?+jZ!"yg(ÝCkuc!S>aڻjG@%N VX_<Y:fеuDK$nje;^N8;vayvSCl?mcnno_3l˳bNW7DʱלMn%n|_ץwg#,iAӟ$@X
60:3:qcZ =xqSi!5]a3r\|ARZ]._`EސO%	^{vS%qC<u$xٍӔqQs_5{oܣ?~1^itb/O7j4qtAKqR,}urMS|^xɤ˶ugswI{QqR}p|p+eݻgXJdYUA5 !O<zBG8j#tVY#8 \u[UN]^T9НB!U WSOؙÆ/t*	Hp)9>Bx:uWi$KG6-h3eYbï}ޝal|{^E#>xp~<S#ü=>YF(kpF8&"3t6˯YY];z ,!9/Aiл#+1hڜᎭ#xs:Ck0FaGi-Q zA_-~}ziXïjv9kkgX-ZZ~w]a՚HCjf+Z_]踽9D'dlh%L(;UU_|<}.ҹݑ |oY~{l,`>uv;dnGx2x!v}=4#&׶;AMnf$4@ [ᘔy.S)": kRp b]	AVƓW%w-*``O 쒑n@*RC꺢nxZ	_  '{{
60:4:i5}kM!EIvj 0k1/4 *BB	/uES0 `&:,+؂Hæڼ`.t-̪a5yuQARN0#e4๲2+QJ2ckrqbIo'L)@6léi"s@k-	!
60:5:37=e.;
60:6:VKjl=Ng&s U:^T3㻝/;'_K4ZQg{{=.;Qg mwr
60:7:Ǭ8h0zWBfgM шUMG&f.2O98.DDBC]_1Js$4{|L:nZ
60:8:Uz?Jףp IQ8Vewhkz˳iUEV~ F6$x "~@_KZnΚA)*?"om
60:9:/1uyOjiP|HP4/`bGK7FdgɃ|>Z&y>ZZ'6ӻe}b36|7鵻qfmF]lh:}V	w+dgݳ0s`]UU.'l0Q#VLk6GkHx䄮14 `SO#Y 8FmxsoT*7+WuP&h<$w!_cڮZɨ=%j|98RW/UD{k.?~wN5~LOc4hӏdx ߋ.M>GL|LP&f̙O߻ȉ@$oDQ5G]*N)0$]$b6d2^=D؃na8EyqavE]G;F:m}׉hJ(C3,@=1:!˖MaтW8ܛX7"!fT$r3GT_b apB}h_VXP ӥ$i~ݎZBb_
60:10:fp	w,F'`>lr3ե{P]^8CџWg[{:3 )( zc#o./^V`Ow-4CA+4.m9FMק}}H}^z{px$x:cϨ&d0nwU^fo_Ȥ 5\, MiRW;2@[)C:!dn6\+< *
60:11:nPNiR/QCɳ@Bڔ?"QTw qzګ"˱}>SNt0gl"w:Gt?'*Ovno`)Eˋ?+e%mH/BLcxmxL! T@t]qٙ]f%wvP7if-yQп>tJFjҋٖR.UxL'"@& T:'س5wX:Vnex4p6+mzw?jBv+\X YE3g&'ïlN_u4<^ǟ8;+Uj3#)rBn >17#Hg(2tzIh`K,
60:12:JK`7 0+-(KDc:7|f)|f\c$ϬצK;<B!tM{Α HxiDk,	0XNU0"Z3HÎ{+ `<2MI;|}0ͮ
60:13::0B̟Wa,J05|' F<kK*&2})Fed}nȰ -.b %J޾,jo1DNN1WyʌA1;0n
60:14:X6&1U;A>o{cHz-k	_V-d<J%ƙľV_[ZCIVSPmV%ЌtN9f+A*"bFTu{>&)_9"!%tUˠ~| %RVk)Yk]1B&[}|tl4NP9&Ҁ<<SU^5ȰBe/ k\EJ/qbpd}3)5tCDCtWr٧¥VЙCcUBJhO&͘qk
60:15:CAѤAS /+LF3oI
60:16:$DǠUcqÉрL$zQfԏóK,0pX<(;KbMW6)9His-'jW8̵.VW? a8q*gj&~5Qy0zNZڑBFeЩ
60:17:yErY:Kk),nsHwj8D GsM4lgq5d	ю
60:18:*uzR sJ٢2ڢUJC"M
60:19:bz6FfXt&R^L\ #I*s &UhX{
60:20:ӭԌ_=#|a|=EW"fp 4Z7hLq{yrl:'T2sqb!#䦰'c@h25.r! \Ӻe۶h'#3VSl>妼p|j\Z_ƣV[{{j<FtPɒYJN^mٱEVx {AfC%g .,}jirP?i,~Mc-7*O}C#'nR#;,HM>(dYY>EلK5]I;,	?xkE$_n30[(KHC
60:21:)Jbf=J5!=TQElJ0e41 
60:22:\`ł :.q^C9Q"˂,ʅI<AnhGXPSVpdV9@c2노nˌ	m^HJ a1| %Q;-3:|?H*Rz$yL2N$+~/I_NPK5׻!~+pfH+#+60oh	UE4PQIliWTCwvqbu%d ž$8Ko;OhB8ar0䶛63,S VZ6O~T{Lhb&ũc-Ldd݂٥Jr2'w3Om0YԐE.Rdf~0uDc؇did"S7a%ȭ7[!Z,}G!bzK#t5c/JCv`iHeCsuzp>$ȯftҝ΅El+h;H{4ʶ';^d%+_h@HTϽpB3:Lq@2.T(ڦ~P	"(]iLhPq0		ҕ̙|cqhcWQ}Tk);51UJ1;aPKj$yI>:S9=*HQz>iKZ~61T17ֻLT.r>:!/ggΚjgv>*'/,^0REZ^SJQmBXjvZdt*#pt,zh@a]E9흣}\noxx~70)ANv=wv6ݡ\U-'FY@2LgcDX]&# Kc8n#a|N5ZU8jR7eu
60:23:񽒶FDk]mg1aE]Y,,I$:l5n$[rԽ4?OCnI; ?-H/38X`Ⱦ4%T6uhY#4}l0%-uH3Rc=!Lnuf&X72x ǖ&YxD=$.+?b=H@FrsgS\,/?tL$[_]}ar~æIӞfo`a:)(JHMf<	Ή"6LmBGJ"6%DsFv&{=GtLLdcw7!@!H  1w	(p6w9Yw89lNQ{\_%ÄqCβ`-G+DP3	|K>ZYVRX<
60:24:y<i	W+1X.RiyL>I7^mDmN}(=	#?>j]*@sz^떟θ,|&5<
60:25:2EѪEpB9>0'!EϢS zmRTNSݳ-dG<Dփ%|Zòk}EL/H5c		 &*d<^ol%:.>֞u(tAƖ	2ɢ.{NkS4;4%Oh=RJmy, H@
60:26:fN_W`"	9tFFI'#۔g*fSKW̦MW\w-I&ܘK6I1QZnlHC]6`N)^W-8k+QJ^.8M?zD5nԘڧZΊE|?]]lW^;+DQ<rýxu}o^ŔSp"0D YMLFal=W1Ь0J6ѩVyW,S(4SRΊ_b@JƜv_h$K(ߧgӠ)bNBsB1ǖKF+$/{5fə[neWu~K߯x ^i0,A(ܕnTS3&}xS1Ɗ!єhr6:9$$@aUN	TAHZ\7^3\h֕E<McfS㣚JA#%=VWFTyJAjNڙj+'L7Dטyk-)E	ԗ]h@3LE$ XCxFZQK9-,0mj
60:27:2rTۄn_78V,Pӄ׈6B2@FhIhFCmj(-UNUӧR	RGR~"fh7klsle.X`rHl($b(쌐]fAF9NPn{I0R#wunThkTBr{;g.adݘ  pF`&q~UIGY^&DYGԔ;0t8}ed3X46T|r %+n<$yp,T`=J]SJqDq&<	*)Nw|#yn_-z"Iơ2IZf3IXwf'2#-dEFTOiEj)4Ɋ"-X3g&)7A׷-^%LҢ9cMrBp(M`Bb-S΢TﲛٚlOH$P	ia5m-m'h	P[M]D`8\e}c9ճz\IO\Hcbdj8DÖ"bRЙ|bNlϓ0^=(.iLr 5fZzRHZujgyDHtqg"8'qh,l_N{UJ&V`m ZE'5Ӭ&SHB쬠غ̆$OnX^	DSpHU(dD[zX+îgzQ~.c(U]+v%H29MQ_;e; ,Va"pB:t+WLe'D*a;#J(k`wNd%[1HkrZd(C#ؖ  9Lؐ3Ĩ2 PO' ]z,i`b4*%+zK([H|Qٜu#`֡F20YC1+bNH͐Hsc7vץ0,)&+)AL:,DQTr(e8ק-=	 :P{{rdKf2I׆7}ܼD!|突VҼJ:#:hzyYI ]q&^h/xMxXEf (1Nvg74QJ\3;Gڑ^S@<鏜" \vU`!\
60:28:-Wnq\.(͢ wV,o'VF$6|d9ƛ7}	l=X_th-,kIWF=ez;F;v-?Ns%
60:29:f瘱*F!>⮻dO˧/ZC]>r] u2#]<|K7"H	V ق#Y]Bd1>PkPfAK9rHodC&yΩ OB{ǫ(H8lwwよ  K!N>_*,`_QOzޓ+$QMp!;hE1?̓#ɴǽx	B!1LV%}]䑀$ދN447H5(C`hNZX~'5FNeN*s%.Pdl_(n<ܞ&,8m+T2Kr')-N[NׄO/r>u8ˎ(I)0mw	u%ӏ<(797qǶ(MiLk. C)ǈ4p0cX1)n-8nmD EKGMlc+'~}KV)x-Zæ
60:30:FWW&)WԲ9XB*%±ISq^mQE<@8*YeJM\Pzfm!$(aah""ߨ{lʸɲ	Tk0`IٰuS:4(mF/d/|5(䫤.p_h	)F@BlMDĸ*Iݗ5&6iCyZdQ_p8ತN#-	:	s/Mq'!BO@8IanfXo)+@HOAל@5ufAo)IT1-x5.WISx#cc	U;Z_#[ʙ' Ah-iQȩĠ6ı8qd}Bxi-yFz=lgF_@cw;_S1_$rWodЯU?X,jCڕ8܉gp	$VŨ2Q#t%
60:31:%bYJhrL֡?6ו(g2~Fs@`˽oE!㶰m]Fn|~ȸJ.omz#|xF\,4){%b%/±E?=EyqqClqվP42%~hR,jA/vZ~ɵUp??A"gm'xazS]/`wtÆlF?&.*3;KkkוuVTe؛ITcc߷"?XV6CW}h1SRЯNl3D`9ћZ%ͺ*jIs HGϰTyi+g8_c1؎bͦv
60:32:흣#lW"$Z:.0|ODBkyl,Ȋ/	# "sbOH+hCM逦رlC1:pTSjOKeXL.Mt#wjdOͦ!d_o⫛BZLO@%_sxu(<&Q(5QZej^ٵ2*FUX+DNp,jd:lr혣!/.u[oֳ#-%D>t,ɑ7KHld wFP¿r[7N+V[#b0]GHW&2\50o+PSQטE X#4.zTX\7HNW\p p8".1Tc<gYaq\~?.%pxe.sʔ5<[X +1DLת.C)aUh/+ֳ"x79F7 E&m yi)i4QL	.z'J[<z3(DmY\U=_*aER/^H-,os*{?Y5?P"v绰\ITO6Qc*,}p|o pز
60:33:X3d}pn_tPV(oVˠ|0h`,mܘҦ>]ʪ#TݗVLʦ,ʆ]!3o*][*{Q@fubREG7e3b{Ex`!(4/LDm*^|{x@SU(ErɺE_8RBݲY
60:34:bxg]-/r0o;ܳp=oM5k8ߪ#JʟST7Q U'Ubk O8%ri)3SUfwIDZ-er]w2:uH
60:35:jixc6\^8r$6I⨃nڹ"ZZ9irtNmk>^K d	fIB#bٽ*BqNDRY[WDͰv7C=V]%o}2Q5UJ_<szG˸N'uD4LSH6MǸs
60:36:
60:37:NW&B6)^g,	WRZĤ>\I
60:38: M@fQ^xNdǕEX\>zΚ?P)vbc?Δ?<WxC zVyQ4ȟ-%u> 
60:39:pSNSX}@$f$J`6~#%PPH	Co(^xA)yCŜ,K[gy\;*&#b@/o#ٵ8?F%ZC7pOrv0`j^Pg5svڷmw4h0h0El1+ rt	!+Nc*llaF)=HI_2);JđBTة\.0Gwl
60:40:[޻g;SZVHwIk)%nՔk>/}=P<hk!Br4%q4a
60:41:,F, xףjNbfAGwOjC
60:42:lb(ȹX|%LiC =r_`lܵ&ȝp4FTWZCJ{w聧ш}ЂT`#S5fxݧS3&'K"Z7)yN6<c*?Ev"pqߦixk j\s\&Ms
60:43:
60:44:|&k-t,.L4չ7\$AoICEO<ۈQ~<g5{ ؔɀpؑg-(.1hNV{!?J: WɎV؂( Pu>Xx>"DngU#:efo3-W(G:MzskC<sKϕS4pp39@(/A=A ܶy5%C6̜<ɴ,b\qL1
60:45:ZU-wZM_\u\ZykeVjD6:px^gӧ(SaE,5Q`e>N1{u8YI.bACQxǇcA
60:46:u0_Wswal%RhF,=\t҆F?ףKk工xlPzhƢuQ&
60:47:"+D2o=6PҿT*OVBAv~YĝCpjXd!CE(R5`y!4>QS-`Bь&1`QՇ`I{?+v~kX48l+<JinRdZhZ.KdKCRYM?F.!Jɀ/4d[\wSQJkJ}61:1:xU]O0]	YمtՑLX`!ޑ -S:=}I^&p\Y,6iI
61:2:^I)ƞsǰeYhhQ@#y%5MUBGR5!3Xv8
61:3:|l |~9b/t}d)!H3WTԪg>j)u(hQ|Ūxx{vd<IT("T2DblInV~#~ﰳA/@?5pރ?:71وa`؄a0`؄q-~tv}DxQ7PR`r^<W7{62:1:x]Sƶ3	SB^'HvNG#l~-#ɐ4>ծ$4[/gϞ=_Vg?:'G7Ϟ~_k+s?Si5l}YЍ>ͭn6qs5QwU2(%+[yxzi/{P;9mO֟%_oV(u9zezN܍U`t:
62:2:$|u~`/#q]Q?6'a¼n|w?7ý[m X[QDv5%tco؍w~7Yjme_.zJ*VAS-'}^ݒҟ)]wv­va5b!,"~ƮinnU+1ħ]to* jJ S-J7LMYLen2<Qdx:<N3p(,Oǝ\%on(UXA4>@@7i>Qost_TH>x]eZ,(M<?a7<JRKjE2Юe,?@!)&4k@LrNyCuNTfg>.M5ÓT쇛j5l+nӿQoBc
62:3:m\ԭ,@JǚWX_^}OaIT<^j쨿	uW{6kHBbR R=#gBoKewL*+կԟ%Lkqxްg#Vj~T~+;+lp9'ɤ	ϓ^W{R^?ۭak#l_e~	|1`VH01/?6wT+d[pg*m4[PZ6г.U}ާ&
62:4:k˺(L_|}KDW4 (0s
62:5:_h^n<·x?_{p\L{Jr\
62:6:K4?70D+j4~5maAڅr*@3\:[ϮSu=cآ`=&*\J%f/Yiݺn"m|@v:λ"|G<cj
62:7:[Oh,I ><Ug,^Zv~><L9݂\M%Ķ6kŀΠkԅCESpD>lP SN,,0=v;JDiOqOLgǪdp"HxhG/|*|Oc*n}I0SO`=inX-p<~<upߡ8\Ғd]J2Hi]+)S,!hF.*Qt@{#m (cݵ./yWYWc⇡A@%;hpЮGdjpCf
62:8:~dQԧ-y=$P$G;MÇiMuiْ.9@76M<1(N,P좗wN1_=jQ`Љ2>;9^~wwG_ӓ++e׉&&LOPP4{Ζi3ް;'愆E0'
62:9:KR칐VvO'mi
62:10:Z;l[A+b-)ctUͷvɈ 8FF&퍪jS&M=~l;XAK#+4n!2}RJ%NoH!xE1;/ť4XT Hez̢0t BPuTB/mTӕ6<zVG;y;&hb`w+y.^F>"Y;"عN5qހF]\,?YR+";I-Ŗm^͖}%N^IUuSDևJlǂP~Tv6P?<T-"VfgK"[<?Z;_mnjg{6x!7%\9/la.l"tpa."LN"̪v}%f|64TKO;SZ-2$iaΝVsrH}T+IY)%LUsOMRon G̉礝`W4QY3<Q7Q;[8*eᑮ8Gez$YuܾIƆ&)KRLڬd PT7@fGL+Jn¸w\ۜ&\]<FQlvF?29.?&(emY}iT\"·עn7"[礐@}"h//=>ivJǤqፑH:+`.%SM'uİ$D-wC>!ȯ1M+dW&ܯS^lg=
62:11:[RmctRmmƫ+YLvڤ+'Yi!pD!RZHdi/\:i'4!/\O+ŁfAxQKfbi0qCRw3cof0q{gnåJ
62:12:CTU0(UUjrZA<%5cW/?R-z~c+o"V?ߧ7SGPIS[,۱a2i\B8=).U!NH>T@}YaTkJ__p+FTW}}ᩮrLXFݎ'q|3G<>'b4%HaD@FQ&)l=G\fc!g	鸗f967Op[1_}-RI2/w3PfHv@ pZ>RXѬ&YK$txQ.=ON@`M9D76q(mcuV>=.-d=qVLCgS^"kVtۋΩA<	eZ(Ϙx|wW(*R;19a=h<BvaU\;mtA i<%~nu0NNaX NAs
62:13:V?(R&⡔!K!mJQ2	Td zDDr.HtF4hF`I9N qARbf#@ IhUL[C1t3R͗|RgyDZz*"K`#Ed9j/ IHK̔@ɑe	˒<~lX9Y,Uڌb``0z[kgr ͪ%nd.﹣7 ȉR10\]Eq2uݵ.>߲3t=%KR654?xN͍-/Y7 :~ϋ:n2oOsqp#zKRNϦ'hFf,6|=E)F} 9 k,L	`IK2)'i2ed x֘3kBxW~؝nNg";5#%V^x yA%3,FIH]D#@iFns]`\+2}b3a'DqJ%%)y#@@j!/l(N㳳̈Fzq,OT`r
62:14:dՁ߱>V$/\EИJbcKoYPceoU܃mԚtKY1!nmK`NaGrHz	Ѡ m#z<Zy"#XHmTax-s6<`b_<L'A8C捛hc
62:15:cDzv1	#ְhP
62:16:t*ET\~\BvYﭙ 3$y
62:17:ޛ(U5(XYl`8/[o+xi$:փ?PY-C^;N/;-m	aOCbt8]s<:-jKÚi"SH xaesgKxM;Ecu7'Oԏ۠7
62:18:c
62:19:iBz @k$~9]7	6!dUZVxpWwRQIvDh}w2$dhu>3ϓx;\8H
62:20:"_w%ڣEqf@2%p*ϲ.ڤTO$# NBP;D"
62:21:,>I)Iw	}qU_ {47,{IYGss[V|!w.nv@Xuw^={vwn=w햧l&b&+=q^]}Sv댋mĊ;[,^w|ylJә|B|L )9`͆ҩYS5ҋauNX5_ϥ3V8C=UG3vҝ
62:22:Df%j
62:23:g+H.NMb9y,NicMshUrJ̞%/OHt(_GV_N镔ɂ:0K(R7siC~!'H4T-yX9ҒI"I:}&PP(]=$QR d'98WRlJNRnÝ"Ya>^G+gߪ6qRKs#HC1W#eJ^2'DI*$LT'yed_ Be:z?<e$qNi"vR:1ZuBJ1AsknM1.tل#hoLJ{-N*/{7>&j̙%wަ;݅I~8ͩOkDvpJgF]8wMvN|Gxai%Ɲ7=Jlr,*dr`@!U:_"L͓ˉ͋5'q\Qljm-M-ܓ#*:& Hbk|oU5( q7<bɰ <;z}$8b2coO#`7] 3U)»0@=`[<Zgax߻	KJV+"Sǉs&`E<Lp m@Ι39L|p?TٯBj:)aCx/N!ԧ'2ytmĒVD\Q넥SSHwW~3&C<X7fG45nT}+3DO<|7.Q60Ā@f|S| NuATI{9cug
62:24:7gdI2QcDʇŖ݇,kASdQkmpS\GN+uRXVYY	 րqhҬHTPs~I`T\Lǭ.pԷh>g8/*jrJ<GQm[kZgPU-mY<Ntl6E+QRwJ2h;)5.4c@Hkr2h8]PR+Rj*;6BFKM49Zbیhg(Zˤ!MQX13nlɒrUZ6ACsNo|ZxL#%<7pG,d8$ӝ։7z`G
62:25:*$|FkGg_$ac̥=WHhF3V^dk1Z5T)MXozxp=veq@ab|DGdj.`\B)F1qdXؠ`D
62:26:'4)Vu -GH7	b~c\(fG$@55W}Ll}U{j:	+a(ȸchRZᖏHkܬ>,	ѱ,`aER\bqaq^ٝR$!k-uL*KT1Z'юX$0K90e#={=b﯎ij0!!/wo@*֦#Ez9RU?$wIki馒	$U\"\iXGp@h'd+p_TfW;>zHUx1's;Ӣ#E,/)HzVę?y7uF,-Q?H}qCRS;0ч.tHz#(Is("g|niJ:2=~LDPd@`1i2roFL¤ZấDzg4h7I&xd* wG<Mt$?1m`-7Y58V;v2M.Δu#M.S9y.du38\֚	Q|rXcA\$t8e'P֢P꛶,̡gÊ>^Zdg HKODWWO1JNv_KXZ	t[SM'g1;J$
62:27:Ӌ=6<C;$LCC8[<Jtm16b9]/֖BQH[&h7wkwqYΑBhՇH݅]?k<UFu{;EYNQ-㔿+AإVezwF]&)tEWЮ}4`_xQK)];fo)]ފY'nfxr.c^&d"c+Ffc%7yu,؜j1'd}Nf	p0mߜXbRR<-XCQ02=dඞ@^'e﹡(_0߯`)*ƟEZ9%p22D`5m.fôrX}@[u֌"ZMkn{hhzF7*#EKxtRh5TfvPjрܛ^Le(zJS}ㆯMoZƲs`mzMHa;Wn+`{)ym3R/dYu,.BlB RnʃQ=`a.l63:1:48b0c2dc58f7cd88ee1cbd0e130173486b11d4f7
63:2:64:1:48b0c2dc58f7cd88ee1cbd0e130173486b11d4f7
64:2:65:1:/************************************************************************************************************
65:2:
65:3:    NAME
65:4:	array.c
65:5:	
65:6:    DESCRIPTION
65:7:	Extra array functions.
65:8:	
65:9:    AUTHOR
65:10:	Christian Vigh, 10/2014.
65:11:	
65:12:    HISTORY 
65:13:	tbd
65:14:
65:15: ************************************************************************************************************/
65:16:# include 	"php_vroom.h"
65:17:# include 	"array.h"
65:18:
65:19:
65:20:/*===========================================================================================================
65:21:
65:22:    NAME
65:23:	array_initialize - initializes the array_buffer module.
65:24:
65:25: *===========================================================================================================*/
65:26:void 	array_initialize	( THRAK_INIT_FUNC_ARGS )
65:27:   {
65:28:    }
65:29:
65:30:    
65:31:/*===========================================================================================================
65:32:
65:33:    NAME
65:34:	array_shutdown
65:35:	
65:36:    DESCRIPTION
65:37:	Sub-extension shutdown function.
65:38:	
65:39: *===========================================================================================================*/
65:40:void 	array_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
65:41:   {
65:42:    }    
65:43:
65:44:    
65:45:/*===========================================================================================================
65:46:
65:47:    NAME
65:48:	array_flatten - Flattens an array.
65:49:	
65:50:    PROTOTYPE 
65:51:	$array 	=  array_flatten ( $array, $copy_keys = false ) ;
65:52:	
65:53:    DESCRIPTION
65:54:	Flattens an array so that it has only one nesting level.
65:55:	
65:56:    PARAMETERS 
65:57:	$array (array) -
65:58:		Array to be flattened.
65:59:		
65:60:	$copy_keys (boolean) -
65:61:		When true, array keys are copied into the flattened array, whenever possible.
65:62:		
65:63:    RETURNS
65:64:	The flattened array.
65:65:	
65:66:    NOTES
65:67:	. When both an outer array and a nested array contain the same associative key, the corresponding value
65:68:	  in the outer array will be overridden by the one of the nested array.
65:69:	  Example :
65:70:	  
65:71:		print_r ( array_flatten ( [ 'a' => 1, [ 'a' => 'nested value', 'b' => 1 ] ] ) ) ;
65:72:		
65:73:	  will output :
65:74:	  
65:75:		[ 'a' => 'nested value', 'b' => 1 ]
65:76:		
65:77:	. Keys will be lost during the flattening process if their value is a nested array :
65:78:	
65:79:		print_r ( array_flatten ( [ 1, 'nested_array' => [ 2, 3 ] ] ) ) ;
65:80:		
65:81:	  will output :
65:82:	  
65:83:		[ 1, 2, 3 ] 
65:84:	
65:85: *===========================================================================================================*/
65:86:static zend_always_inline void  __array_flatten ( zval *  output_array, zval *  input_array, zend_bool  copy_keys )
65:87:   {
65:88:	HashTable *		array_hash 	=  Z_ARRVAL_P ( input_array ) ;
65:89:	HashPosition 		array_position ;
65:90:	char * 			key ;
65:91:	ulong 			key_length ;
65:92:	ulong 			index ;
65:93:	zval ** 		item ;
65:94:	int  			key_type ;
65:95:
65:96:
65:97:	/* Loop through array items */
65:98:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & array_position ) ; 
65:99:			zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & array_position )  ==  SUCCESS ; 
65:100:			zend_hash_move_forward_ex ( array_hash, & array_position ) ) 
65:101:	   {
65:102:		/* Get array key for current position */	
65:103:		key_type 	=  zend_hash_get_current_key_ex ( array_hash, & key, & key_length, & index, 0, & array_position ) ;
65:104:
65:105:		/* Add a reference to the item */
65:106:		Z_ADDREF_PP ( item ) ;
65:107:
65:108:		// If array given, recursively process its contents
65:109:		if  ( Z_TYPE_PP ( item )  ==  IS_ARRAY )
65:110:		   {
65:111:			__array_flatten ( output_array, * item, copy_keys ) ;
65:112:		    }
65:113:		else
65:114:		   {
65:115:# ifdef 	PHP_WIN32
65:116:# 	pragma 		warning ( disable : 4267 )
65:117:# endif
65:118:			// If the key type is string, then add the current item with an associative index
65:119:			if  ( key_type  ==  HASH_KEY_IS_STRING  &&  copy_keys )
65:120:			   {
65:121:				add_assoc_zval_ex ( output_array, key, key_length, * item ) ;
65:122:			    }
65:123:			// Otherwise, simply add the current item
65:124:			else 
65:125:				add_next_index_zval ( output_array, * item ) ;
65:126:# ifdef 	PHP_WIN32
65:127:# 	pragma 		warning ( default : 4267 )
65:128:# endif
65:129:		    }
65:130:	    }
65:131:    }
65:132:    
65:133:PHP_FUNCTION ( array_flatten )
65:134:   {
65:135:	zval *		input_array ;
65:136:	zend_bool	copy_keys 	=  0 ;
65:137:	     
65:138:	/* Parse arguments */
65:139:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "a|b", & input_array, & copy_keys )  ==  FAILURE )
65:140:		return ;
65:141:		
65:142:	/* Initialize output array */
65:143:	array_init ( return_value ) ;
65:144:	
65:145:	/* Run the recursive input array processing */
65:146:	__array_flatten ( return_value, input_array, copy_keys ) ;
65:147:    }
65:148: 
65:149: 
65:150: /*===========================================================================================================
65:151:
65:152:    NAME
65:153:	iin_array - Case-insensitive search in array.
65:154:	
65:155:    PROTOTYPE 
65:156:	$bool 	=  iin_array ( $needle, $haystack ) ;
65:157:	
65:158:    DESCRIPTION
65:159:	Performs a case-insensitive search of the value $needle in the array $haystack.
65:160:	
65:161:    PARAMETERS 
65:162:	$needle (mixed) -
65:163:		Value to be searched.
65:164:		
65:165:	$haystack (array) -
65:166:		Array to be searched.
65:167:		
65:168:    RETURNS
65:169:	True if the array contains the specified value, false otherwise.
65:170:	
65:171: *===========================================================================================================*/
65:172: 
65:173: /***
65:174:	Grrr ! in_array uses compare_function(), which has no kcase-insensitive equivalent...
65:175:	This is simply an adaptation of the original.
65:176: ***/
65:177:#define TYPE_PAIR(t1,t2) (((t1) << 4) | (t2))
65:178:
65:179:static zend_always_inline int 	__case_compare_function ( zval *  result, zval *  op1, zval *  op2, int  identical TSRMLS_DC  )  
65:180:   {
65:181:	switch ( TYPE_PAIR ( Z_TYPE_P ( op1 ), Z_TYPE_P ( op2 ) ) ) 
65:182:	   {
65:183:		case TYPE_PAIR ( IS_STRING, IS_STRING ) :
65:184:			Z_LVAL_P ( result ) 	=  zend_binary_zval_strcasecmp ( op1, op2 ) ;
65:185:			ZVAL_LONG ( result, ZEND_NORMALIZE_BOOL ( Z_LVAL_P ( result ) ) ) ;				
65:186:			return ( SUCCESS ) ;
65:187:			
65:188:		default :
65:189:			return ( ( identical ) ? 
65:190:					is_equal_function 	( result, op1, op2 TSRMLS_CC ) :
65:191:					is_identical_function   ( result, op1, op2 TSRMLS_CC )
65:192:				) ;
65:193:	    }
65:194:    }
65:195:   
65:196:static zend_always_inline int __is_case_equal_function ( zval *  result, zval *  op1, zval *  op2 TSRMLS_DC )
65:197:   {
65:198:	if  ( __case_compare_function (result, op1, op2, 0 TSRMLS_CC )  ==  FAILURE)
65:199:		return ( FAILURE ) ;
65:200:		
65:201:	ZVAL_BOOL ( result, ( Z_LVAL_P ( result )  ==  0 ) ) ;
65:202:	return ( SUCCESS ) ;
65:203:    }
65:204:    
65:205:    
65:206:static zend_always_inline int __is_case_identical_function ( zval *  result, zval *  op1, zval *  op2  TSRMLS_DC )
65:207:   {
65:208:	if  ( __case_compare_function (result, op1, op2, 1 TSRMLS_CC )  ==  FAILURE)
65:209:		return ( FAILURE ) ;
65:210:		
65:211:	ZVAL_BOOL ( result, ( Z_LVAL_P ( result )  ==  0 ) ) ;
65:212:	return ( SUCCESS ) ;
65:213:    }
65:214:    
65:215:    
65:216:PHP_FUNCTION ( iin_array )
65:217:   {
65:218:	zval *		value,				/* value to check for 		*/
65:219:	     *		array,				/* array to check in 		*/
65:220:	     **		entry,				/* pointer to array entry 	*/
65:221:			res ;				/* comparison result 		*/
65:222:	HashTable *	hash ;				/* Array hash 			*/
65:223:	HashPosition 	pos ;				/* hash iterator 		*/
65:224:	zend_bool 	strict =  0 ;			/* strict comparison or not 	*/
65:225:	int 		( * is_equal_func ) ( zval *, zval *, zval * TSRMLS_DC) 
65:226:				=  __is_case_equal_function;
65:227:
65:228:	
65:229:	/*  Parse parameters */
65:230:	if ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "za|b", & value, & array, & strict )  ==  FAILURE )
65:231:		return ;
65:232:
65:233:	/* Use strict comparison function if needed */
65:234:	if  ( strict )
65:235:		is_equal_func = __is_case_identical_function ;
65:236:
65:237:	/* Loop through array entries */
65:238:	hash 	=  Z_ARRVAL_P ( array ) ;
65:239:	zend_hash_internal_pointer_reset_ex ( hash, & pos ) ;
65:240:	
65:241:	while  ( zend_hash_get_current_data_ex ( hash, ( void ** ) & entry, & pos )  ==  SUCCESS ) 
65:242:	   {
65:243:		is_equal_func ( & res, value, * entry TSRMLS_CC ) ; 
65:244:		
65:245:		if  ( Z_LVAL ( res ) ) 
65:246:			RETURN_TRUE ;
65:247:		
65:248:		zend_hash_move_forward_ex ( hash, & pos ) ;
65:249:	    }
65:250:
65:251:	RETURN_FALSE ;
65:252:    }
65:253: 
65:254: 
65:255:  /*===========================================================================================================
65:256:
65:257:    NAME
65:258:	array_ikey_exists - Case-insensitive search in array keys.
65:259:	
65:260:    PROTOTYPE 
65:261:	$bool 	=  array_ikey_exists ( $needle, $haystack ) ;
65:262:	
65:263:    DESCRIPTION
65:264:	Performs a case-insensitive search of the value $needle in the keys of the array $haystack.
65:265:	
65:266:    PARAMETERS 
65:267:	$needle (mixed) -
65:268:		Key to be searched.
65:269:		
65:270:	$haystack (array) -
65:271:		Array to be searched.
65:272:		
65:273:    RETURNS
65:274:	True if the array contains the specified key, false otherwise.
65:275:	
65:276: *===========================================================================================================*/
65:277: PHP_FUNCTION ( array_ikey_exists )
65:278:   {
65:279:	zval *		key ;					/* key to check for 		*/
65:280:	HashTable *	array_hash ;				/* array to check in 		*/
65:281:	HashPosition 	array_position ;			/* current array position 	*/
65:282:	char *		array_key ;
65:283:	int 		array_key_length ;
65:284:	int  		array_key_index ;
65:285:	int  		array_key_type ;
65:286:	int  		length ;
65:287:
65:288:	
65:289:	/* Check parameters */
65:290:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zH", & key, & array_hash )  ==  FAILURE )
65:291:		return ;
65:292:
65:293:	/* Search key depending on its type */
65:294:	switch  ( Z_TYPE_P ( key ) ) 
65:295:	   {
65:296:		case 	IS_STRING :
65:297:			zend_hash_internal_pointer_reset_ex ( array_hash, & array_position ) ;
65:298:			length 	=  Z_STRLEN_P ( key ) ;
65:299:		
65:300:			while  ( ( array_key_type = zend_hash_get_current_key_ex ( 
65:301:								array_hash, & array_key, & array_key_length, & array_key_index, 0, & array_position ) )  !=  HASH_KEY_NON_EXISTENT ) 
65:302:			   {
65:303:				if  ( length  ==  array_key_length - 1  && 
65:304:						! strncasecmp ( Z_STRVAL_P ( key ), array_key, length ) )
65:305:					RETURN_TRUE ;
65:306:		
65:307:				zend_hash_move_forward_ex ( array_hash, & array_position ) ;
65:308:			    }
65:309:			    
65:310:			RETURN_FALSE ;
65:311:			
65:312:		case IS_LONG :
65:313:			if  ( zend_hash_index_exists ( array_hash, Z_LVAL_P ( key ) ) )
65:314:				RETURN_TRUE ;
65:315:			RETURN_FALSE ;
65:316:			
65:317:		case IS_NULL :
65:318:			if  ( zend_hash_exists ( array_hash, "", 1 ) )
65:319:				RETURN_TRUE;
65:320:			RETURN_FALSE ;
65:321:
65:322:		default :
65:323:			php_error_docref ( NULL TSRMLS_CC, E_WARNING, "The first argument should be either a string or an integer" ) ;
65:324:			RETURN_FALSE ;
65:325:	    }
65:326:    }66:1:/************************************************************************************************************
66:2:
66:3:    NAME
66:4:	array.h
66:5:	
66:6:    DESCRIPTION
66:7:	Definitions for buffered arrays.
66:8:	
66:9:    AUTHOR
66:10:	Christian Vigh, 10/2014.
66:11:	
66:12:    HISTORY 
66:13:	tbd
66:14:
66:15: ************************************************************************************************************/
66:16:# ifndef 	__ARRAY_H__
66:17:# 	define	__ARRAY_H__
66:18:
66:19:language_block ( C ) ;
66:20:
66:21:/*-----------------------------------------------------------------------------------------------------------
66:22:
66:23:	Macros & constants.
66:24:	
66:25: *-----------------------------------------------------------------------------------------------------------*/
66:26:# define 	ARRAY_BUFFER_CLASS_NAME			"ArrayBuffer"
66:27:# define 	ARRAY_BUFFER_RESOURCE_NAME		"array_buffer"
66:28:
66:29:# define 	ARRAY_BUFFER_MAX_SIZE_SETTING		"array_buffer.max_size"
66:30:# define 	DEFAULT_ARRAY_BUFFER_MAX_SIZE		"1Mb"
66:31:# define 	ARRAY_BUFFER_MIN_FREE_MEMORY_SETTING	"array_buffer.min_free_memory"
66:32:# define 	DEFAULT_ARRAY_BUFFER_MIN_FREE_MEMORY	"30%"
66:33:
66:34:
66:35:/*-----------------------------------------------------------------------------------------------------------
66:36:
66:37:	Array buffer structures.
66:38:	
66:39: *-----------------------------------------------------------------------------------------------------------*/
66:40:typedef struct array_buffer
66:41:   {
66:42:	void *		data ;
66:43:	long 		size ;
66:44:    }  array_buffer ;
66:45:    
66:46: 
66:47:/*-----------------------------------------------------------------------------------------------------------
66:48:
66:49:	External variables.
66:50:	
66:51: *-----------------------------------------------------------------------------------------------------------*/
66:52:ZEND_BEGIN_MODULE_GLOBALS ( array_buffer )					/* Module globals					*/
66:53:	int  	junk ;
66:54:ZEND_END_MODULE_GLOBALS ( array_buffer ) ;
66:55:
66:56:extern int 			array_buffer_resource_id ;			/* Id of the resource associated with an array_buffer 	*/
66:57:extern thrak_byte_quantity 	array_buffer_max_size ;				/* Max array buffer size 				*/
66:58: 
66:59: 
66:60:/*-----------------------------------------------------------------------------------------------------------
66:61:
66:62:	External array_buffer functions.
66:63:	
66:64: *-----------------------------------------------------------------------------------------------------------*/
66:65:extern PHP_FUNCTION ( array_buffer_clone ) ;
66:66:extern PHP_FUNCTION ( array_buffer_copy ) ;
66:67:extern PHP_FUNCTION ( array_buffer_create ) ;
66:68:extern PHP_FUNCTION ( array_buffer_destroy ) ;
66:69:extern PHP_FUNCTION ( array_buffer_get ) ;
66:70:extern PHP_FUNCTION ( array_buffer_resize ) ;
66:71:extern PHP_FUNCTION ( array_buffer_set ) ;
66:72:extern PHP_FUNCTION ( array_buffer_size ) ;
66:73:
66:74:extern void 		array_buffer_initialize		( THRAK_INIT_FUNC_ARGS ) ;
66:75:extern void 		array_buffer_shutdown		( THRAK_SHUTDOWN_FUNC_ARGS ) ;
66:76:
66:77:/*-----------------------------------------------------------------------------------------------------------
66:78:
66:79:	External array functions.
66:80:	
66:81: *-----------------------------------------------------------------------------------------------------------*/
66:82:extern PHP_FUNCTION ( array_flatten ) ; 
66:83:extern PHP_FUNCTION ( iin_array ) ;
66:84:extern PHP_FUNCTION ( array_ikey_exists ) ;
66:85:
66:86: 
66:87:extern void 		array_initialize		( THRAK_INIT_FUNC_ARGS ) ;
66:88:extern void 		array_shutdown			( THRAK_SHUTDOWN_FUNC_ARGS ) ;
66:89:
66:90:end_language_block ( C ) ;
66:91:
66:92:# endif		/* __ARRAY_H__  */67:1:/************************************************************************************************************
67:2:
67:3:    NAME
67:4:	array_buffer.h
67:5:	
67:6:    DESCRIPTION
67:7:	Implementation of buffers for scalar arrays.
67:8:	
67:9:    AUTHOR
67:10:	Christian Vigh, 10/2014.
67:11:	
67:12:    HISTORY 
67:13:	tbd
67:14:
67:15: ************************************************************************************************************/
67:16:# include 	"php_vroom.h"
67:17:# include 	"array.h"
67:18:
67:19:/*-----------------------------------------------------------------------------------------------------------
67:20:
67:21:	Global variables.
67:22:	
67:23: *-----------------------------------------------------------------------------------------------------------*/
67:24: 
67:25:/* Module globals */
67:26:ZEND_DECLARE_MODULE_GLOBALS ( array_buffer ) ;
67:27:
67:28:/* Id of the resource associated with an array_buffer */
67:29:int 					array_buffer_resource_type_id ;		
67:30:
67:31:/* Max array buffer size */
67:32:static thrak_byte_quantity		ini_setting_max_size ; 
67:33:/* Array buffers will not be allocated if available memory falls below this limit */
67:34:static thrak_memory_quantity		ini_setting_min_free_memory ;
67:35:
67:36:
67:37:/*===========================================================================================================
67:38:
67:39:    NAME
67:40:	array_buffer_resource_destructor - Destroys a resource of array_buffer type.
67:41:
67:42: *===========================================================================================================*/
67:43:static void  array_buffer_resource_destructor ( zend_rsrc_list_entry *  resource TSRMLS_DC )  
67:44:   {
67:45:        array_buffer *	abp 	=  ( array_buffer * ) resource -> ptr ;
67:46:
67:47:	if  ( abp  !=  NULL )		// Paranoid checks...
67:48:	   {
67:49:		if (  abp -> data  !=  NULL )		// Free array data
67:50:			efree ( abp -> data ) ;
67:51:			
67:52:		efree ( abp ) ;
67:53:	    }
67:54:    }
67:55:
67:56:    
67:57:    
67:58:/*===========================================================================================================
67:59:
67:60:    NAME
67:61:	array_buffer_initialize - initializes the array_buffer module.
67:62:
67:63: *===========================================================================================================*/
67:64:static void  array_buffer_init_globals ( THRAK_GLOBALS_TYPE ( array_buffer ) *  globals )
67:65:   { }
67:66:
67:67:void 	array_buffer_initialize	( THRAK_INIT_FUNC_ARGS )
67:68:   {
67:69:	char * 		ini_value ;
67:70:	int 		status ;
67:71:	
67:72:	/* Initialize module globals */
67:73:	THRAK_INIT_GLOBALS ( array_buffer, array_buffer_init_globals ) ;
67:74:	
67:75:	/* Register a resource of type "array_buffer" */
67:76:	array_buffer_resource_type_id	=  zend_register_list_destructors_ex ( array_buffer_resource_destructor, NULL, 
67:77:								ARRAY_BUFFER_RESOURCE_NAME, module_number ) ;
67:78:								
67:79:	/* INI setting : array_buffer.max_size. Allows for Kilobytes quantities (suffixed by "K" or "KB") and megabytes ("M" or "MB") */
67:80:	ini_value 	=  thrak_ini_get_string ( ARRAY_BUFFER_MAX_SIZE_SETTING, DEFAULT_ARRAY_BUFFER_MAX_SIZE ) ;
67:81:	status 		=  thrak_ini_parse_byte_quantity ( ini_value, & ini_setting_max_size ) ;
67:82:
67:83:	if (  ! status )
67:84:		php_error_docref ( NULL TSRMLS_CC, E_NOTICE, "Incorrect value \"%s\" for the \"%s\" ini setting.\n", ini_value, ARRAY_BUFFER_MAX_SIZE_SETTING ) ;
67:85:
67:86:	efree ( ini_value ) ;
67:87:	
67:88:	/* INI setting : array_buffer.min_free_memory. */
67:89:	ini_value 	=  thrak_ini_get_string ( ARRAY_BUFFER_MIN_FREE_MEMORY_SETTING, DEFAULT_ARRAY_BUFFER_MIN_FREE_MEMORY ) ;
67:90:	status 		=  thrak_ini_parse_memory_quantity ( ini_value, & ini_setting_min_free_memory ) ;
67:91:
67:92:	if (  ! status )
67:93:		php_error_docref ( NULL TSRMLS_CC, E_NOTICE, "Incorrect value \"%s\" for the \"%s\" ini setting.\n", ini_value, ARRAY_BUFFER_MIN_FREE_MEMORY_SETTING ) ;
67:94:
67:95:	efree ( ini_value ) ;
67:96:	
67:97:    }
67:98:
67:99:    
67:100:/*===========================================================================================================
67:101:
67:102:    NAME
67:103:	array_buffer_shutdown
67:104:	
67:105:    DESCRIPTION
67:106:	Sub-extension shutdown function.
67:107:	
67:108: *===========================================================================================================*/
67:109:void 	array_buffer_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
67:110:   {
67:111:    }    
67:112:    
67:113:
67:114:/*===========================================================================================================
67:115:
67:116:    NAME
67:117:	array_buffer_clone - Clones a buffer.
67:118:	
67:119:    PROTOTYPE 
67:120:	$new_resource = array_buffer_clone ( $resource ) ;
67:121:	
67:122:    DESCRIPTION
67:123:	Clones an array buffer.
67:124:	
67:125:    PARAMETERS
67:126:	$resource (resource) -
67:127:		Array buffer resource to be cloned.
67:128:		
67:129:    RETURNS
67:130:	A resource that points to the clone of the specified input array buffer, or false if something went
67:131:	wrong.
67:132:	
67:133: *===========================================================================================================*/
67:134:PHP_FUNCTION ( array_buffer_clone )
67:135:   {
67:136:	zval * 			z_resource ;
67:137:	array_buffer *		input_buffer ;
67:138:	array_buffer *		cloned_buffer ;
67:139:
67:140:	/* Parse arguments */
67:141:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "r", & z_resource )  ==  FAILURE )
67:142:		return ;
67:143:
67:144:	/* Error handling (bad resource id) is performed by ZEND_FETCH_RESOURCE */
67:145:	ZEND_FETCH_RESOURCE ( input_buffer, array_buffer *, & z_resource, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:146:
67:147:	/* Check memory constraints */
67:148:	if  ( ! thrak_memory_check_constraint ( sizeof ( array_buffer ) + input_buffer -> size, & ini_setting_min_free_memory TSRMLS_CC ) )
67:149:	   {
67:150:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Not enough memory to allocate %d bytes", sizeof ( array_buffer ) + input_buffer -> size ) ;
67:151:		RETURN_FALSE ;
67:152:	    }
67:153:	
67:154:	/* Allocate a new array buffer */
67:155:	cloned_buffer 	=  emalloc ( sizeof ( array_buffer ) ) ;
67:156:	
67:157:	if  ( cloned_buffer  ==  NULL )
67:158:		RETURN_FALSE ;
67:159:		
67:160:	cloned_buffer -> data 	=  emalloc ( input_buffer -> size ) ;
67:161:	
67:162:	if  ( cloned_buffer -> data  ==  NULL )
67:163:	   {
67:164:		efree ( cloned_buffer ) ;
67:165:		RETURN_FALSE ;
67:166:	    }
67:167:	    
67:168:	/* Perform the copy */
67:169:	memcpy ( cloned_buffer -> data, input_buffer -> data, input_buffer -> size ) ;
67:170:	cloned_buffer -> size 	=  input_buffer -> size ;
67:171:	
67:172:	/* Then register this new "array_buffer" resource */
67:173:	ZEND_REGISTER_RESOURCE ( return_value, cloned_buffer, array_buffer_resource_type_id ) ;
67:174:    }
67:175:    
67:176:    
67:177:/*===========================================================================================================
67:178:
67:179:    NAME
67:180:	array_buffer_copy - Copies an array buffer over an existing one.
67:181:	
67:182:    PROTOTYPE 
67:183:	$bytes_copied = array_buffer_copy ( $dst_resource, $src_resource, $num_bytes = 0, 
67:184:						$dst_offset = 0, $src_offset = 0 ) ;
67:185:	
67:186:    DESCRIPTION
67:187:	Copies the whole or a part of an array buffer over an existing one. Only the bytes that can fit into
67:188:	the destination buffer array will be copied.
67:189:	
67:190:    PARAMETERS
67:191:	$dst_resource (resource) -
67:192:		Destination array buffer.
67:193:		
67:194:	$src_resource (resource) -
67:195:		Source array buffer.
67:196:		
67:197:	$num_bytes (integer) -
67:198:		Number of bytes to copy. If unspecified or zero, the whole contents of the source array buffer
67:199:		will be copied (up to destination buffer size).
67:200:		
67:201:	$dst_offset (integer) -
67:202:		Offset where to start the copy in the destination buffer.
67:203:		Defaults to zero.
67:204:		
67:205:	$src_offset (integer) -
67:206:		Offset where to start the copy from the source buffer.
67:207:		Defaults to zero.
67:208:		
67:209:    RETURNS
67:210:	The number of bytes copied, or false is some invalid parameters were specified.
67:211:	
67:212: *===========================================================================================================*/
67:213:PHP_FUNCTION ( array_buffer_copy )
67:214:   {
67:215:	zval *			z_source ;					/* Parameter values */
67:216:	zval *			z_destination ;
67:217:	array_buffer *		source_buffer ;
67:218:	array_buffer *		destination_buffer ;
67:219:	long 			num_bytes 		=  0 ;
67:220:	long 			source_offset		=  0 ;
67:221:	long 			destination_offset	=  0 ;			/* End of parameter values */
67:222:	long 			destination_byte_count,				/* Number of bytes that can be copied into the destination */
67:223:				source_byte_count ;				/* Number of bytes that can be copied from the source */
67:224:
67:225:	
67:226:	/* Parse arguments */
67:227:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "rr|lll", 
67:228:			& z_source, & z_destination, & num_bytes, & destination_offset, & source_offset )  ==  FAILURE )
67:229:		return ;
67:230:
67:231:	/* Check byte count + source & destination offsets */
67:232:	if  ( num_bytes  <  0 )
67:233:	   {
67:234:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "number of bytes to be copied must be a positive integer" ) ;
67:235:		RETURN_FALSE ;
67:236:	    }
67:237:
67:238:	if  ( destination_offset  <  0 )
67:239:	   {
67:240:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "destination offset must be a positive integer" ) ;
67:241:		RETURN_FALSE ;
67:242:	    }
67:243:	    
67:244:	if  ( source_offset  <  0 )
67:245:	   {
67:246:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "source offset must be a positive integer" ) ;
67:247:		RETURN_FALSE ;
67:248:	    }
67:249:	    
67:250:	/* Get destination & source buffers */
67:251:	ZEND_FETCH_RESOURCE ( destination_buffer, array_buffer *, & z_destination, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:252:	ZEND_FETCH_RESOURCE ( source_buffer     , array_buffer *, & z_source     , -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:253:	
67:254:	/* Compute byte count limits */
67:255:	if  ( destination_offset  >=  destination_buffer -> size )
67:256:		RETURN_FALSE ;
67:257:		
67:258:	if  ( source_offset  >=  source_buffer -> size )
67:259:		RETURN_FALSE ;
67:260:		
67:261:	destination_byte_count 	=  ( long ) min ( destination_buffer -> size - destination_offset, num_bytes ) ;
67:262:	source_byte_count 	=  ( long ) min ( source_buffer -> size - source_offset, num_bytes ) ;
67:263:	num_bytes 		=  min ( source_byte_count, destination_byte_count ) ;
67:264:	
67:265:	/* Perform the copy */
67:266:	memcpy ( ( ( char * ) destination_buffer -> data ) + destination_offset, ( ( char * ) source_buffer -> data ) + source_offset, num_bytes ) ;
67:267:	
67:268:	RETURN_LONG ( num_bytes ) ;
67:269:    }
67:270:    
67:271:    
67:272:/*===========================================================================================================
67:273:
67:274:    NAME
67:275:	array_buffer_create - Creates an array buffer.
67:276:	
67:277:    PROTOTYPE 
67:278:	$resource 	=  array_buffer_create ( $size ) ;
67:279:	
67:280:    DESCRIPTION
67:281:	Creates an array buffer of the specified size.
67:282:	
67:283:    PARAMETERS
67:284:	$size (int) -
67:285:		Array buffer size, in bytes.
67:286:	
67:287:     RETURN VALUE
67:288:	A resource identifying the allocated array buffer, or false if something went wrong.
67:289:	
67:290: *===========================================================================================================*/
67:291:PHP_FUNCTION ( array_buffer_create )
67:292:  {
67:293:	long 			size ;
67:294:	array_buffer *		buffer ;
67:295:	
67:296:	
67:297:	/* Parse arguments */
67:298:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "l", & size )  ==  FAILURE )
67:299:		return ;
67:300:  
67:301:	/* Check that the specified size is positive and less than or equal to max array size */
67:302:	if  ( size  <=  0 )
67:303:	   {
67:304:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Array buffer size must be a positive integer" ) ;
67:305:		RETURN_FALSE ;
67:306:	    }
67:307:	else if  ( size  >  ini_setting_max_size. bytes )
67:308:	   {
67:309:		php_error_docref ( NULL TSRMLS_CC, E_NOTICE, "Array buffer size exceeds maximum size (%d bytes) ; array size adjusted to this limit",
67:310:			ini_setting_max_size ) ;
67:311:		size	=  ini_setting_max_size. bytes ;
67:312:	    }
67:313:	    
67:314:	/* Check memory constraints */
67:315:	if  ( ! thrak_memory_check_constraint ( sizeof ( array_buffer ) + size, & ini_setting_min_free_memory TSRMLS_CC ) )
67:316:	   {
67:317:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Not enough memory to allocate %d bytes", sizeof ( array_buffer ) + size ) ;
67:318:		RETURN_FALSE ;
67:319:	    }
67:320:	
67:321:	/* Allocate the buffer */
67:322:	buffer 		=  ( array_buffer * ) emalloc ( sizeof ( array_buffer ) ) ;
67:323:	
67:324:	if  ( buffer  ==  NULL )
67:325:		RETURN_FALSE ;
67:326:		
67:327:	buffer -> data 	=  emalloc ( size ) ;
67:328:	
67:329:	if  ( buffer -> data  ==  NULL )
67:330:	   {
67:331:		efree ( buffer ) ;
67:332:		RETURN_FALSE ;
67:333:	    }
67:334:	    
67:335:	buffer -> size 		=  size ;
67:336:	memset ( buffer -> data, 0, size ) ;
67:337:	
67:338:	/* Then register this new "array_buffer" resource */
67:339:	ZEND_REGISTER_RESOURCE ( return_value, buffer, array_buffer_resource_type_id ) ;
67:340:   }
67:341:
67:342:   
67:343:/*===========================================================================================================
67:344:
67:345:    NAME
67:346:	array_buffer_free - Frees a resource associated to an array buffer.
67:347:	
67:348:    PROTOTYPE 
67:349:	array_buffer_free ( $resource ) ;
67:350:	
67:351:    DESCRIPTION
67:352:	Frees the resources associated with the specified array buffer resource.
67:353:	
67:354:    PARAMETERS
67:355:	$resource (resource) -
67:356:		Array buffer resource.
67:357:	
67:358: *===========================================================================================================*/
67:359:PHP_FUNCTION ( array_buffer_destroy )
67:360:   {
67:361:	zval * 		z_resource ;
67:362:
67:363:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "r", & z_resource )  ==  FAILURE )
67:364:		return ;
67:365:
67:366:	zend_list_delete ( Z_LVAL_P ( z_resource ) ) ;
67:367:    }
67:368:    
67:369:
67:370:/*===========================================================================================================
67:371:
67:372:    NAME
67:373:	array_buffer_get - Gets a byte.
67:374:	
67:375:    PROTOTYPE 
67:376:	array_buffer_get ( $resource, $offset, $num_bytes = 1 ) ;
67:377:	
67:378:    DESCRIPTION
67:379:	Retrieves a byte at the specified offset.
67:380:	
67:381:    PARAMETERS
67:382:	$resource (resource) -
67:383:		Array buffer resource.
67:384:		
67:385:	$offset (int) -
67:386:		Offset of the byte to be retrieved.
67:387:		
67:388:	$num_bytes (integer) -
67:389:		Number of bytes to retrieve.
67:390:	
67:391:    RETURNS
67:392:	When $num_bytes is 1 (the default), array_buffer_get() returns the byte value at the specified offset 
67:393:	of the array buffer.
67:394:	When $num_bytes is greater than 1, consecutive bytes are returned as a binary string.
67:395:	The function returns false if the offset is invalid.
67:396:	
67:397: *===========================================================================================================*/
67:398:PHP_FUNCTION ( array_buffer_get )
67:399:   {
67:400:	zval * 			z_resource ;
67:401:	long 			offset ;
67:402:	long 			num_bytes 		=  1 ;
67:403:	array_buffer *		buffer ;
67:404:	char 			c ;
67:405:
67:406:	/* Parse arguments */
67:407:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "rl|l", & z_resource, & offset, & num_bytes )  ==  FAILURE )
67:408:		return ;
67:409:
67:410:	/* Get the array buffer */
67:411:	ZEND_FETCH_RESOURCE ( buffer, array_buffer *, & z_resource, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:412:
67:413:	/* Check offset */
67:414:	if  ( offset  <  0 )
67:415:	   {
67:416:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Array buffer offset must be a positive integer" ) ;
67:417:		RETURN_FALSE ;
67:418:	    }
67:419:	else if  ( offset  >=  buffer -> size )
67:420:		RETURN_FALSE ;
67:421:		
67:422:	// Check byte count
67:423:	if  ( num_bytes  <  1 )
67:424:	   {
67:425:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "byte count must be a strictly positive integer" ) ;
67:426:		RETURN_FALSE ;
67:427:	    }
67:428:		
67:429:	// Get the character at the specified offset if only one byte is to be retrieved
67:430:	if  ( num_bytes  ==  1 )
67:431:	   {
67:432:		c 	=  * ( ( ( ( char * ) buffer -> data ) ) + offset ) ;
67:433:	
67:434:		RETURN_LONG ( c ) ;
67:435:	    }
67:436:	// Otherwise, return at most $num_bytes as a binary string
67:437:	else
67:438:	   {
67:439:		num_bytes 	=  ( long ) min ( buffer -> size - offset, num_bytes ) ;
67:440:		
67:441:		ZVAL_STRINGL ( return_value, ( ( char * ) buffer -> data ) + offset, num_bytes, 1 ) ;
67:442:	    }
67:443:    }
67:444:  
67:445:  
67:446:  /*===========================================================================================================
67:447:
67:448:    NAME
67:449:	array_buffer_resize - Resizes an array buffer.
67:450:	
67:451:    PROTOTYPE 
67:452:	array_buffer_resize ( $resource, $new_size ) ;
67:453:	
67:454:    DESCRIPTION
67:455:	Resizes an array buffer.
67:456:	
67:457:    PARAMETERS
67:458:	$resource (resource) -
67:459:		Array buffer resource.
67:460:		
67:461:	$size (int) -
67:462:		New size for the array buffer. If less than the current size, existing values above will be
67:463:		truncated.
67:464:	
67:465:    RETURNS
67:466:	True if the array buffer has been resized or remains unchanged because the new size is equal to the
67:467:	actual size, false otherwise.
67:468:	
67:469: *===========================================================================================================*/
67:470:PHP_FUNCTION ( array_buffer_resize )
67:471:   {
67:472:	zval * 			z_resource ;
67:473:	long 			new_size ;
67:474:	array_buffer *		buffer ;
67:475:	void *			new_data ;
67:476:
67:477:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "rl", & z_resource, & new_size )  ==  FAILURE )
67:478:		return ;
67:479:
67:480:	/* Error handling (bad resource id) is performed by ZEND_FETCH_RESOURCE */
67:481:	ZEND_FETCH_RESOURCE ( buffer, array_buffer *, & z_resource, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:482:
67:483:	/* Check new size */
67:484:	if  ( new_size  <=  0 )
67:485:	   {
67:486:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Array buffer size must be a positive integer" ) ;
67:487:		RETURN_FALSE ;
67:488:	    }
67:489:	else if  ( new_size  >  ini_setting_max_size. bytes )
67:490:	   {
67:491:		php_error_docref ( NULL TSRMLS_CC, E_NOTICE, "Array buffer size exceeds maximum size (%d bytes) ; array size adjusted to this limit",
67:492:			ini_setting_max_size ) ;
67:493:		new_size	=  ini_setting_max_size. bytes ;
67:494:	    }
67:495:	    
67:496:	/* Do nothing if new size is equal to old size */
67:497:	if  ( new_size  ==  buffer -> size )
67:498:		RETURN_TRUE ;
67:499:
67:500:	/* Check memory constraint */
67:501:	if  ( new_size  >  buffer -> size )
67:502:	   {
67:503:		if  ( ! thrak_memory_check_constraint ( new_size - buffer -> size, & ini_setting_min_free_memory TSRMLS_CC ) )
67:504:		   {
67:505:			php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Not enough memory to allocate %d bytes", new_size - buffer -> size ) ;
67:506:			RETURN_FALSE ;
67:507:		    }
67:508:	    }
67:509:		
67:510:	/* Resize the array buffer */
67:511:	new_data 	=  erealloc ( buffer -> data, new_size ) ;
67:512:	
67:513:	if (  new_data  ==  NULL )	/* Allocation error */
67:514:		RETURN_FALSE ;
67:515:
67:516:	/* If size increased, initialize the extra bytes */
67:517:	if  ( new_size  >  buffer -> size )
67:518:		memset ( ( ( char * ) new_data ) + buffer -> size, 0, new_size - buffer -> size ) ;
67:519:	
67:520:	/* All done, update the array buffer structure */
67:521:	buffer -> data		=  new_data ;
67:522:	buffer -> size 		=  new_size ;
67:523:	
67:524:	RETURN_TRUE ;
67:525:    }
67:526:    
67:527:    
67:528:/*===========================================================================================================
67:529:
67:530:    NAME
67:531:	array_buffer_set - Initializes an array buffer.
67:532:	
67:533:    PROTOTYPE 
67:534:	$bytes_set = array_buffer_set ( $resource, $offset = 0, $init_value = 0, $num_bytes = 0  ) ;
67:535:	
67:536:    DESCRIPTION
67:537:	Initializes a whole or a range of an array buffer to the specified value.
67:538:	
67:539:    PARAMETERS
67:540:	$resource (resource) -
67:541:		Array buffer to be initialized.
67:542:		
67:543:	$init_value (integer) -
67:544:		Initialization value.
67:545:		
67:546:	$num_bytes (integer) -
67:547:		Number of bytes to initialize. If unspecified or zero, the whole contents of the array buffer
67:548:		are initialized.
67:549:		
67:550:	$offset (integer) -
67:551:		Offset where to start initialization from.
67:552:		Defaults to zero.
67:553:		
67:554:    RETURNS
67:555:	The number of bytes initialized, or false is some invalid parameters were specified.
67:556:	
67:557: *===========================================================================================================*/
67:558:PHP_FUNCTION ( array_buffer_set )
67:559:   {
67:560:	zval *			z_buffer ;					/* Parameter values */
67:561:	zval *			z_char_or_string ;
67:562:	array_buffer *		buffer ;
67:563:	long 			init_value 		=  0 ;
67:564:	long 			num_bytes 		=  1 ;
67:565:	long 			offset			=  0 ;
67:566:
67:567:	
67:568:	/* Parse arguments */
67:569:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "r|lzl", 
67:570:			& z_buffer, & offset, & z_char_or_string, & num_bytes )  ==  FAILURE )
67:571:		return ;
67:572:
67:573:	/* Check byte count + source & destination offsets */
67:574:	if  ( num_bytes  <  0 )
67:575:	   {
67:576:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "number of bytes to be initialized must be a positive integer" ) ;
67:577:		RETURN_FALSE ;
67:578:	    }
67:579:
67:580:	if  ( offset  <  0 )
67:581:	   {
67:582:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "offset must be a positive integer" ) ;
67:583:		RETURN_FALSE ;
67:584:	    }
67:585:	    
67:586:	/* Get array buffer */
67:587:	ZEND_FETCH_RESOURCE ( buffer, array_buffer *, & z_buffer, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:588:	
67:589:	/* Compute byte count limits */
67:590:	if  ( offset  >=  buffer -> size )
67:591:		RETURN_FALSE ;
67:592:		
67:593:	num_bytes 	=  ( long ) min ( ( buffer -> size - offset ), num_bytes ) ;
67:594:	
67:595:	// Initialize
67:596:	memset ( ( ( char * ) buffer -> data ) + offset, init_value, num_bytes ) ;
67:597:	
67:598:	RETURN_LONG ( num_bytes ) ;
67:599:    }
67:600:    
67:601:    
67:602:/*===========================================================================================================
67:603:
67:604:    NAME
67:605:	array_buffer_size - Returns the size in bytes of an array buffer.
67:606:	
67:607:    PROTOTYPE 
67:608:	$size 	=  array_buffer_length ( $resource ) ;
67:609:	
67:610:    DESCRIPTION
67:611:	Returns the size in bytes of the array buffer associated to the specified resource.
67:612:	
67:613:    PARAMETERS
67:614:	$resource (resource) -
67:615:		Memtext resource.
67:616:		
67:617:    RETURN VALUE
67:618:	Size in bytes of the array buffer.
67:619:	
67:620: *===========================================================================================================*/
67:621:PHP_FUNCTION ( array_buffer_size )
67:622:   {
67:623:	zval * 		z_resource ;
67:624:	array_buffer *	buffer  	=  NULL ;
67:625:
67:626:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "r", & z_resource )  ==  FAILURE )
67:627:		return ;
67:628:	
67:629:	/* Error handling (bad resource id) is performed by ZEND_FETCH_RESOURCE */
67:630:	ZEND_FETCH_RESOURCE ( buffer, array_buffer *, & z_resource, -1, ARRAY_BUFFER_RESOURCE_NAME, array_buffer_resource_type_id ) ;
67:631:	    
67:632:	RETURN_LONG ( ( long ) buffer -> size ) ;
67:633:    }
67:634:
67:635:    
67:636:    68:1:/************************************************************************************************************
68:2:
68:3:    NAME
68:4:	ini_helpers.c
68:5:	
68:6:    DESCRIPTION
68:7:	Helper functions for parsing .INI file values.
68:8:	
68:9:    AUTHOR
68:10:	Christian Vigh, 11/2014.
68:11:	
68:12:    HISTORY 
68:13:	tbd
68:14:
68:15: ************************************************************************************************************/
68:16:# include 	"thrak.h"
68:17:# include 	<ctype.h>
68:18:# include 	<math.h>
68:19:
68:20:
68:21:/*===========================================================================================================
68:22:
68:23:    NAME
68:24:	thrak_array_to_char - Converts an array to an array of C-strings.
68:25:	
68:26:    PROTOTYPE 
68:27:	char *  thrak_array_to_char ( zval *  array, char ***  argv, int *  argc, int **  argl ) ;
68:28:	
68:29:    DESCRIPTION
68:30:	Converts an array (of strings) to an array of string
68:31:		
68:32:    PARAMETERS
68:33:	array (zval *) -
68:34:		A pointer to a zval containing either an array or a scalar value.
68:35:		If a scalar value is supplied, it will be first converted to string and an array of 1 element
68:36:		will be created.
68:37:		
68:38:	argv (char **) -
68:39:		Address of a char * array that will receive the array of pointers to individual zero-terminated
68:40:		strings.
68:41:		Note that this array contains (argc + 1) elements ; the last one being a NULL pointer to signal
68:42:		the end of the array.
68:43:		
68:44:	argc (int *) -
68:45:		Address of an integer that will receive the number of elements in the input array.
68:46:		
68:47:	argl (int **) -
68:48:		If not NULL, will receive the respective lengths of each string in argv. Last item (which 
68:49:		corresponds to the last NULL item in argv) will be set to -1.
68:50:		
68:51:    RETURNS
68:52:	A pointer to the memory block allocated to store all the individual array strings. This memory must
68:53:	then be freed using the thrak_free_array_to_char() function.
68:54:	
68:55: *===========================================================================================================*/
68:56:THRAK_API char * 	thrak_array_to_char ( zval *  array, char ***  argv, int *  argc, int **  argl )
68:57:   {
68:58:	HashTable *		array_hash ;
68:59:	HashPosition 		array_position ;
68:60:	zval ** 		item ;
68:61:	char *			buffer ;
68:62:	int 			total_size 	=  1 ;
68:63:	char **			arg_values ;
68:64:	int  			arg_count ;
68:65:	int *			arg_lengths ;
68:66:	char * 			p ;
68:67:	int 			current_argc,
68:68:				length ;
68:69:	int 			argv_length,
68:70:				argl_length ;
68:71:	
68:72:
68:73:	/* Ban forbidden zval types, retain only ARRAY and STRING types, and convert all other scalar types to string */
68:74:	switch  ( Z_TYPE_P ( array ) )
68:75:	   {
68:76:		case 	IS_OBJECT :
68:77:		case 	IS_RESOURCE :
68:78:		case	IS_NULL :
68:79:			return ( NULL ) ;
68:80:			
68:81:		case 	IS_ARRAY :
68:82:		case 	IS_STRING :
68:83:			break ;
68:84:			
68:85:		default :
68:86:			convert_to_string_ex ( & array ) ;
68:87:	    }
68:88:	    
68:89:	/* Compute the size needed to hold all the strings supplied in the input array */
68:90:	if  ( Z_TYPE_P ( array )  ==  IS_ARRAY )
68:91:	   {
68:92:		/* Get hash from array */
68:93:		array_hash 	=  Z_ARRVAL_P ( array ) ;
68:94:		
68:95:		/* Get item count and allocate this count + one element (the last element being a NULL pointer) */
68:96:		arg_count 	=  zend_hash_num_elements ( array_hash ) ;
68:97:		
68:98:		/* A first pass through the input array to compute the total size needed */
68:99:		for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & array_position ) ; 
68:100:				zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & array_position )  ==  SUCCESS ; 
68:101:				zend_hash_move_forward_ex ( array_hash, & array_position ) ) 
68:102:		   {
68:103:			/* Ignore non-scalar types and convert non-strings to strings */
68:104:			switch ( Z_TYPE_PP ( item ) )
68:105:			   {
68:106:				case 	IS_OBJECT :
68:107:				case 	IS_RESOURCE :
68:108:				case 	IS_ARRAY :
68:109:				case 	IS_NULL :
68:110:					continue ;
68:111:					
68:112:				case 	IS_STRING :
68:113:					break ;
68:114:					
68:115:				default :
68:116:					convert_to_string_ex ( item ) ;
68:117:			    }
68:118:			    
68:119:			/* Update total needed size */
68:120:			total_size 	+=  Z_STRLEN_PP ( item ) + 1 ;
68:121:		    }
68:122:		    
68:123:		/*** 
68:124:			The buffer that will be allocated has the following layout :
68:125:			. offset 0 					: argv 
68:126:			. offset sizeof ( char * ) * ( argc + 1 ) 	: argl (optional)
68:127:			. offset argl + ( sizeof ( int ) * ( argc + 1 )	: zero-terminated strings
68:128:			. last byte 					: 0, to indicate the end of zero-terminated strings
68:129:			
68:130:		 ***/
68:131:		argv_length 	=  ( ( arg_count + 1 ) * sizeof ( char * ) ) ;
68:132:		argl_length 	=  ( argl  ==  NULL ) ?  0 : ( ( arg_count + 1 ) * sizeof ( int ) ) ;
68:133:		
68:134:		buffer 	=  emalloc ( argv_length + argl_length + total_size ) ;
68:135:		
68:136:		if  ( buffer  ==  NULL )
68:137:			return ( NULL ) ;
68:138:			
68:139:		/* Set the pointers to the correct offset into buffer */
68:140:		arg_values 	=  ( char ** ) buffer ;
68:141:		
68:142:		if  ( argl  !=  NULL )
68:143:		   {
68:144:			arg_lengths 	=  ( int * ) ( buffer + argv_length ) ;
68:145:			p 		=  buffer + argv_length + argl_length ;
68:146:		    }
68:147:		else 
68:148:			p 		=  buffer + argv_length ;
68:149:		    
68:150:		/* Second pass : copy input array values to buffer and update argv accordingly */
68:151:		current_argc 	=  0 ;
68:152:		
68:153:		for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & array_position ) ; 
68:154:				zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & array_position )  ==  SUCCESS ; 
68:155:				zend_hash_move_forward_ex ( array_hash, & array_position ) ) 
68:156:		   {
68:157:			/* Ignore non-scalar types and convert non-strings to strings */
68:158:			switch ( Z_TYPE_PP ( item ) )
68:159:			   {
68:160:				case 	IS_OBJECT :
68:161:				case 	IS_RESOURCE :
68:162:				case 	IS_ARRAY :
68:163:				case 	IS_NULL :
68:164:					continue ;
68:165:					
68:166:				case 	IS_STRING :
68:167:					break ;
68:168:					
68:169:				default :
68:170:					convert_to_string_ex ( item ) ;
68:171:			    }
68:172:			    
68:173:			/* Add current item and make it nul-terminated */
68:174:			length 		=  Z_STRLEN_PP ( item ) ;
68:175:			memcpy ( p, Z_STRVAL_PP ( item ), length ) ;
68:176:			
68:177:			* ( p + length ) 	=  0 ;
68:178:			
68:179:			/* Add it to the argv array */
68:180:			arg_values [ current_argc ] 		=  p ;
68:181:			
68:182:			if  ( argl  !=  NULL )
68:183:				arg_lengths [ current_argc ]	=  length ;
68:184:				
68:185:			p 	+= length + 1 ;
68:186:			current_argc ++ ;
68:187:		    }
68:188:	    }
68:189:	/* Input value is not an array ; if scalar type, we will convert it to a string and put it in a 1-element argv array */
68:190:	else
68:191:	   {
68:192:		/* Ignore non-scalar types and convert non-strings to strings */
68:193:		switch ( Z_TYPE_P ( array ) )
68:194:		   {
68:195:			case 	IS_OBJECT :
68:196:			case 	IS_RESOURCE :
68:197:			case 	IS_NULL :
68:198:				return ( NULL ) ;
68:199:				
68:200:			case 	IS_STRING :
68:201:				break ;
68:202:				
68:203:			default :
68:204:				convert_to_string_ex ( & array ) ;
68:205:		    }
68:206:
68:207:		length 		 =  Z_STRLEN_P ( array ) ;
68:208:		total_size 	+=  length + 1 ;
68:209:		
68:210:		arg_count 	=  1 ;
68:211:		argv_length 	=  ( ( arg_count + 1 ) * sizeof ( char * ) ) ;
68:212:		argl_length 	=  ( argl  ==  NULL ) ?  0 : ( ( arg_count + 1 ) * sizeof ( int ) ) ;
68:213:		
68:214:		buffer 	=  emalloc ( argv_length + argl_length + total_size ) ;
68:215:		
68:216:		if  ( buffer  ==  NULL )
68:217:			return ( NULL ) ;
68:218:			
68:219:		/* Set the pointers to the correct offset into buffer */
68:220:		arg_values 	=  ( char ** ) buffer ;
68:221:		
68:222:		if  ( argl  !=  NULL )
68:223:		   {
68:224:			arg_lengths 	=  ( int * ) ( buffer + argv_length ) ;
68:225:			p 		=  buffer + argv_length + argl_length ;
68:226:		    }
68:227:		else 
68:228:			p 		=  buffer + argv_length ;
68:229:		
68:230:		current_argc 	=  0 ;
68:231:		
68:232:		/* Copy the string value in it */
68:233:		strncpy ( p, Z_STRVAL_P ( array ), length ) ;
68:234:		
68:235:		/* Terminate by a double nul character (one for the string, one for signalling the end of the string list) */
68:236:		p [ length ] = p [ length + 1 ] = 0 ;
68:237:		
68:238:		/* Add it to the argv array */
68:239:		arg_values [0] 	=  p ;
68:240:		
68:241:		if  ( argl  !=  NULL )
68:242:			arg_lengths [0] 	=  length ;
68:243:			
68:244:		current_argc ++ ;
68:245:	    }
68:246:	    
68:247:	/* Make sure the last array item is a NULL pointer */
68:248:	arg_values [ current_argc ] 	=  NULL ;
68:249:	
68:250:	if  ( argl  !=  NULL )
68:251:	   {
68:252:		arg_lengths [ current_argc ] 	=  -1 ;
68:253:		* argl 				=  arg_lengths ;
68:254:	    }
68:255:	
68:256:	/* Update caller supplied values */
68:257:	* argv 	=  arg_values ;
68:258:	* argc 	=  arg_count ;
68:259:	
68:260:	/* All done, return */
68:261:	return ( buffer ) ;
68:262:    }
68:263:    
68:264:    
68:265:    
68:266:/*===========================================================================================================
68:267:
68:268:    NAME
68:269:	thrak_free_array_to_char - Frees memory previously allocated by thrak_array_to_char.
68:270:	
68:271:    PROTOTYPE 
68:272:	zend_bool  thrak_free_array_to_char ( char *  data ) ;
68:273:	
68:274:    DESCRIPTION
68:275:	Frees memory previously allocated by thrak_free_array_to_char().
68:276:		
68:277:    PARAMETERS
68:278:	data (char *) -
68:279:		A pointer returned by thrak_array_to_char().
68:280:		
68:281:    RETURNS
68:282:	1 if memory has been successfully freed, 0 otherwise.
68:283:	
68:284: *===========================================================================================================*/
68:285: THRAK_API zend_bool 	thrak_free_array_to_char ( char *  data )
68:286:    {
68:287:	if  ( data  !=  NULL )
68:288:	   {
68:289:		efree ( data ) ;
68:290:		return ( 1 ) ;
68:291:	    }
68:292:	else
68:293:		return ( 0 ) ;
68:294:     }69:1:/************************************************************************************************************
69:2:
69:3:    NAME
69:4:	array_statics.h
69:5:	
69:6:    DESCRIPTION
69:7:	Variables that must be initialized only once.
69:8:	
69:9:    AUTHOR
69:10:	Christian Vigh, 11/2014.
69:11:	
69:12:    HISTORY 
69:13:	tbd
69:14:
69:15: ************************************************************************************************************/
69:16:# ifndef 	__ARRAY_STATICS_H__
69:17:# 	define	__ARRAY_STATICS_H__
69:18:
69:19:language_block ( C ) ;
69:20:
69:21:/*-----------------------------------------------------------------------------------------------------------
69:22:
69:23:	Function arguments type information for array.c.
69:24:	
69:25: *-----------------------------------------------------------------------------------------------------------*/
69:26:/* array_flatten() */
69:27:THRAK_BEGIN_ARG_INFO ( array_flatten, 0, 0, 1 )
69:28:	THRAK_ARG_INFO ( 0, array )
69:29:	THRAK_ARG_INFO ( 0, copy_keys )
69:30:THRAK_END_ARG_INFO ;
69:31:
69:32:/* array_ikey_exists() */
69:33:THRAK_BEGIN_ARG_INFO ( array_ikey_exists, 0, 0, 2 )
69:34:	THRAK_ARG_INFO ( 0, needle )
69:35:	THRAK_ARG_INFO ( 0, haystack )
69:36:	THRAK_ARG_INFO ( 0, strict ) 
69:37:THRAK_END_ARG_INFO ;
69:38:
69:39:/* in_iarray() */
69:40:THRAK_BEGIN_ARG_INFO ( iin_array, 0, 0, 2 )
69:41:	THRAK_ARG_INFO ( 0, needle )
69:42:	THRAK_ARG_INFO ( 0, haystack )
69:43:THRAK_END_ARG_INFO ;
69:44:
69:45:
69:46:/*-----------------------------------------------------------------------------------------------------------
69:47:
69:48:	Function arguments type information for array_buffer.c.
69:49:	
69:50: *-----------------------------------------------------------------------------------------------------------*/
69:51:/* array_buffer_clone() */
69:52:THRAK_BEGIN_ARG_INFO ( array_buffer_clone, 0, 0, 1 )
69:53:	THRAK_ARG_INFO ( 0, resource )
69:54:THRAK_END_ARG_INFO ;
69:55:
69:56:/* array_buffer_copy() */
69:57:THRAK_BEGIN_ARG_INFO ( array_buffer_copy, 0, 0, 2 )
69:58:	THRAK_ARG_INFO ( 0, dest )
69:59:	THRAK_ARG_INFO ( 0, src )
69:60:	THRAK_ARG_INFO ( 0, num_bytes )
69:61:	THRAK_ARG_INFO ( 0, dst_offset )
69:62:	THRAK_ARG_INFO ( 0, src_offset )
69:63:THRAK_END_ARG_INFO ;
69:64:
69:65:/* array_buffer_create() */
69:66:THRAK_BEGIN_ARG_INFO ( array_buffer_create, 0, 0, 1 )
69:67:	THRAK_ARG_INFO ( 0, size )
69:68:THRAK_END_ARG_INFO ;
69:69:
69:70:/* array_buffer_destroy() */
69:71:THRAK_BEGIN_ARG_INFO ( array_buffer_destroy, 0, 0, 1 )
69:72:	THRAK_ARG_INFO ( 0, resource )
69:73:THRAK_END_ARG_INFO ;
69:74:
69:75:/* array_buffer_get() */
69:76:THRAK_BEGIN_ARG_INFO ( array_buffer_get, 0, 0, 1 )
69:77:	THRAK_ARG_INFO ( 0, resource )
69:78:	THRAK_ARG_INFO ( 0, offset )
69:79:	THRAK_ARG_INFO ( 0, num_bytes )
69:80:THRAK_END_ARG_INFO ;
69:81:
69:82:/* array_buffer_resize() */
69:83:THRAK_BEGIN_ARG_INFO ( array_buffer_resize, 0, 0, 2 )
69:84:	THRAK_ARG_INFO ( 0, resource )
69:85:	THRAK_ARG_INFO ( 0, new_size )
69:86:THRAK_END_ARG_INFO ;
69:87:
69:88:/* array_buffer_set() */
69:89:THRAK_BEGIN_ARG_INFO ( array_buffer_set, 0, 0, 2 )
69:90:	THRAK_ARG_INFO ( 0, buffer )
69:91:	THRAK_ARG_INFO ( 0, init_value )
69:92:	THRAK_ARG_INFO ( 0, num_bytes )
69:93:	THRAK_ARG_INFO ( 0, offset )
69:94:THRAK_END_ARG_INFO ;
69:95:
69:96:/* array_buffer_size() */
69:97:THRAK_BEGIN_ARG_INFO ( array_buffer_size, 0, 0, 0 )
69:98:THRAK_END_ARG_INFO ;
69:99:
69:100:end_language_block ( C ) ;
69:101:
69:102:# endif		/* __ARRAY_STATICS_H__  */70:1:dnl $Id$
70:2:PHP_ARG_ENABLE(vroom, whether to enable Vroom support, 
70:3:	[ --enable-vroom          Enable Vroom support] )
70:4:
70:5:if test "$PHP_VROOM" != "no"; then
70:6:	AC_DEFINE ( HAVE_VROOM, 1, [ ] )
70:7:	PHP_NEW_EXTENSION ( vroom, "php_vroom.c vroom.c array_buffer.c zval.c", $ext_shared )
70:8:	PHP_INSTALL_HEADERS ( ext/vroom, "php_vroom.h array.h zval.h" )
70:9:fi
70:10:71:1:// $Id$
71:2:// vim:ft=javascript
71:3:
71:4:ARG_ENABLE ( "vroom", "Vroom utilities support", "no" ) ;
71:5:
71:6:if (PHP_VROOM == "yes") 
71:7:   {
71:8:	EXTENSION ( "vroom", "thrak.c array_helpers.c ini_helpers.c string_helpers.c memory_helpers.c php_vroom.c vroom.c array.c array_buffer.c data.c minify.c string.c timer.c zval.c" ) ;
71:9:	PHP_INSTALL_HEADERS ( "ext/vroom/", "php_vroom.h array.h data.h minify.h string.h timer.h zval.h" ) ;
71:10:	AC_DEFINE ( 'HAVE_VROOM', 1, 'Have Vroom support' ) ;
71:11:    }
71:12:72:1:/************************************************************************************************************
72:2:
72:3:    NAME
72:4:	data.c
72:5:	
72:6:    DESCRIPTION
72:7:	Data-related operations.
72:8:	
72:9:    AUTHOR
72:10:	Christian Vigh, 11/2014.
72:11:	
72:12:    HISTORY 
72:13:	tbd
72:14:
72:15: ************************************************************************************************************/
72:16:# include 	"php_vroom.h"
72:17:# include 	"data.h"
72:18:
72:19:
72:20:/*-----------------------------------------------------------------------------------------------------------
72:21:
72:22:	Packing/unpacking function tables.
72:23:	
72:24: *-----------------------------------------------------------------------------------------------------------*/
72:25:# define 	WORD_PACKER 			0		/* Packer / unpacker index in function table */
72:26:# define 	DWORD_PACKER 			1 
72:27:# define 	QWORD_PACKER			2
72:28:
72:29:# define 	WORD_UNPACKER 			WORD_PACKER
72:30:# define 	DWORD_UNPACKER 			DWORD_PACKER
72:31:# define 	QWORD_UNPACKER			QWORD_PACKER
72:32:
72:33:# define 	LITTLE_ENDIAN_PACKER		0		/* Endianness index in function table */
72:34:# define 	BIG_ENDIAN_PACKER 		1
72:35:# define 	MACHINE_ENDIAN_PACKER		2
72:36:
72:37:# define 	LITTLE_ENDIAN_UNPACKER		LITTLE_ENDIAN_PACKER
72:38:# define 	BIG_ENDIAN_UNPACKER 		BIG_ENDIAN_PACKER
72:39:# define 	MACHINE_ENDIAN_UNPACKER		MACHINE_ENDIAN_PACKER
72:40:
72:41:
72:42:/* For double to long conversion */
72:43:typedef struct boxed_double
72:44:   {
72:45:	union 
72:46:	   {
72:47:		double 		double_value ;
72:48:		long long 	long_value ;
72:49:	    } ;
72:50:    }  boxed_double ;
72:51:
72:52:/* Packing/unpacking function prototypes */
72:53:typedef 	zend_bool  ( * packer_function ) 	( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
72:54:typedef 	zend_bool  ( * unpacker_function )	( zval *  binary_string, int  count, zval **  result TSRMLS_DC ) ;
72:55:
72:56:/* Packing function table */
72:57:static 		packer_function			packer_table [3] [3]	=
72:58:   {
72:59:	{ internal_data_pack_dwl, internal_data_pack_dwb, NULL },
72:60:	{ internal_data_pack_ddl, internal_data_pack_ddb, NULL },
72:61:	{ internal_data_pack_dql, internal_data_pack_dqb, NULL }
72:62:    } ;
72:63:
72:64:/* Unpacking function table */
72:65:static 		unpacker_function		unpacker_table [3] [3]	=
72:66:   {
72:67:	{ internal_data_unpack_dwl, internal_data_unpack_dwb, NULL },
72:68:	{ internal_data_unpack_ddl, internal_data_unpack_ddb, NULL },
72:69:	{ internal_data_unpack_dql, internal_data_unpack_dqb, NULL }
72:70:    } ;
72:71:
72:72:
72:73:/*===========================================================================================================
72:74:
72:75:    NAME
72:76:	data_initialize - Initializes the data functions.
72:77:		
72:78: *===========================================================================================================*/
72:79:void 	data_initialize ( THRAK_INIT_FUNC_ARGS )
72:80:   {
72:81:	/* Register constants for ZVAL types */
72:82:	REGISTER_LONG_CONSTANT ( "DATA_LITTLE_ENDIAN"	, LITTLE_ENDIAN		, CONST_CS | CONST_PERSISTENT ) ;
72:83:	REGISTER_LONG_CONSTANT ( "DATA_BIG_ENDIAN"	, BIG_ENDIAN		, CONST_CS | CONST_PERSISTENT ) ;
72:84:	REGISTER_LONG_CONSTANT ( "DATA_MACHINE_ENDIAN"	, MACHINE_ENDIAN	, CONST_CS | CONST_PERSISTENT ) ;
72:85:	
72:86:	/* Initialize the "machine-endianness-dependent" packer/unpacker entries */
72:87:	packer_table [ WORD_PACKER  ] [ MACHINE_ENDIAN_PACKER ] 	= packer_table [ WORD_PACKER  ] [ thrak_machine_endianness ] ;
72:88:	packer_table [ DWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] 	= packer_table [ DWORD_PACKER ] [ thrak_machine_endianness ] ;
72:89:	packer_table [ QWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] 	= packer_table [ DWORD_PACKER ] [ thrak_machine_endianness ] ;
72:90:	
72:91:	unpacker_table [ WORD_UNPACKER  ] [ MACHINE_ENDIAN_UNPACKER ] 	= unpacker_table [ WORD_UNPACKER  ] [ thrak_machine_endianness ] ;
72:92:	unpacker_table [ DWORD_UNPACKER ] [ MACHINE_ENDIAN_UNPACKER ] 	= unpacker_table [ DWORD_UNPACKER ] [ thrak_machine_endianness ] ;
72:93:	unpacker_table [ QWORD_UNPACKER ] [ MACHINE_ENDIAN_UNPACKER ] 	= unpacker_table [ DWORD_UNPACKER ] [ thrak_machine_endianness ] ;
72:94:    }
72:95:
72:96:
72:97:/*===========================================================================================================
72:98:
72:99:    NAME
72:100:	data_shutdown
72:101:	
72:102:    DESCRIPTION
72:103:	Sub-extension shutdown function.
72:104:	
72:105: *===========================================================================================================*/
72:106:void 	data_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
72:107:   {
72:108:    }
72:109:
72:110:  
72:111:/*===========================================================================================================
72:112:
72:113:	Packing functions.
72:114:	
72:115: *===========================================================================================================*/
72:116: 
72:117:/***
72:118:	WORD functions 
72:119: ***/
72:120:THRAK_API zend_bool  internal_data_pack_dwm ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:121:   { return ( packer_table [ WORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( values, count, result, result_length TSRMLS_CC ) ) ; }
72:122:
72:123:   
72:124:THRAK_API zend_bool  internal_data_pack_dwl ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:125:   {
72:126:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:127:	HashPosition 		pointer ;
72:128:	zval **			item ;
72:129:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:130:	int 			real_size 	=  real_count * 2 ;
72:131:	char *			bindata 	=  emalloc ( real_size ) ;
72:132:	char *			p ;
72:133:	long long		value ;
72:134:	int 			index 		=  0 ;
72:135:	boxed_double		box ;
72:136:	
72:137:	
72:138:	if  ( bindata  ==  NULL )
72:139:		return ( 0 ) ;
72:140:		
72:141:	p 	=  bindata ;
72:142:
72:143:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:144:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:145:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:146:	   {
72:147:		switch ( Z_TYPE_PP ( item ) )
72:148:		   {
72:149:			case 	IS_LONG :
72:150:			case 	IS_BOOL :
72:151:				value 	=  Z_LVAL_PP ( item ) ;
72:152:				break ;
72:153:				
72:154:			case 	IS_DOUBLE :
72:155:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:156:				value 			=  box. long_value ;
72:157:				break ;
72:158:				
72:159:			default :
72:160:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:161:				efree ( bindata ) ;
72:162:				return ( 0 ) ;
72:163:		    }
72:164:		    
72:165:		index ++ ;
72:166:		
72:167:		* ( p ++ )	=  value  &  0xFF ;
72:168:		* ( p ++ )	=  ( value  >>  8 )  &  0xFF ;
72:169:	    }	
72:170:
72:171:	* result	=  bindata ;
72:172:	* result_length =  real_size ;
72:173:	
72:174:	return ( 1 ) ;
72:175:    }
72:176:
72:177:    
72:178:THRAK_API zend_bool  internal_data_pack_dwb ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:179:   {
72:180:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:181:	HashPosition 		pointer ;
72:182:	zval **			item ;
72:183:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:184:	int 			real_size 	=  real_count * 2 ;
72:185:	char *			bindata 	=  emalloc ( real_size ) ;
72:186:	char *			p ;
72:187:	long long		value ;
72:188:	int 			index 		=  0 ;
72:189:	boxed_double		box ;
72:190:	
72:191:	
72:192:	if  ( bindata  ==  NULL )
72:193:		return ( 0 ) ;
72:194:		
72:195:	p 	=  bindata ;
72:196:
72:197:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:198:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:199:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:200:	   {
72:201:		switch ( Z_TYPE_PP ( item ) )
72:202:		   {
72:203:			case 	IS_LONG :
72:204:			case 	IS_BOOL :
72:205:				value 	=  Z_LVAL_PP ( item ) ;
72:206:				break ;
72:207:				
72:208:			case 	IS_DOUBLE :
72:209:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:210:				value 			=  box. long_value ;
72:211:				break ;
72:212:				
72:213:			default :
72:214:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:215:				efree ( bindata ) ;
72:216:				return ( 0 ) ;
72:217:		    }
72:218:		    
72:219:		index ++ ;
72:220:		
72:221:		* ( p ++ )	=  ( value  >>  8 )  &  0xFF ;
72:222:		* ( p ++ )	=  value  &  0xFF ;
72:223:	    }	
72:224:
72:225:	* result	=  bindata ;
72:226:	* result_length =  real_size ;
72:227:	
72:228:	return ( 1 ) ;
72:229:    }
72:230:
72:231:
72:232:/***
72:233:	DWORD functions 
72:234: ***/
72:235:THRAK_API zend_bool  internal_data_pack_ddm ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:236:   { return ( packer_table [ DWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( values, count, result, result_length TSRMLS_CC ) ) ; }
72:237: 
72:238: 
72:239:THRAK_API zend_bool  internal_data_pack_ddl ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:240:   {
72:241:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:242:	HashPosition 		pointer ;
72:243:	zval **			item ;
72:244:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:245:	int 			real_size 	=  real_count * 4 ;
72:246:	char *			bindata 	=  emalloc ( real_size ) ;
72:247:	char *			p ;
72:248:	long long		value ;
72:249:	int 			index 		=  0 ;
72:250:	boxed_double		box ;
72:251:	
72:252:	
72:253:	if  ( bindata  ==  NULL )
72:254:		return ( 0 ) ;
72:255:		
72:256:	p 	=  bindata ;
72:257:
72:258:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:259:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:260:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:261:	   {
72:262:		switch ( Z_TYPE_PP ( item ) )
72:263:		   {
72:264:			case 	IS_LONG :
72:265:			case 	IS_BOOL :
72:266:				value 	=  Z_LVAL_PP ( item ) ;
72:267:				break ;
72:268:				
72:269:			case 	IS_DOUBLE :
72:270:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:271:				value 			=  box. long_value ;
72:272:				break ;
72:273:				
72:274:			default :
72:275:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:276:				efree ( bindata ) ;
72:277:				return ( 0 ) ;
72:278:		    }
72:279:		    
72:280:		index ++ ;
72:281:		
72:282:		* ( p ++ )	=  value  &  0xFF ;
72:283:		* ( p ++ )	=  ( value  >>   8 )  &  0xFF ;
72:284:		* ( p ++ ) 	=  ( value  >>  16 )  &  0xFF ;
72:285:		* ( p ++ ) 	=  ( value  >>  24 )  &  0xFF ;
72:286:	    }	
72:287:
72:288:	* result	=  bindata ;
72:289:	* result_length =  real_size ;
72:290:	
72:291:	return ( 1 ) ;
72:292:    }
72:293:
72:294:    
72:295:THRAK_API zend_bool  internal_data_pack_ddb ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:296:   {
72:297:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:298:	HashPosition 		pointer ;
72:299:	zval **			item ;
72:300:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:301:	int 			real_size 	=  real_count * 4 ;
72:302:	char *			bindata 	=  emalloc ( real_size ) ;
72:303:	char *			p ;
72:304:	long long		value ;
72:305:	int 			index 		=  0 ;
72:306:	boxed_double		box ;
72:307:	
72:308:	
72:309:	if  ( bindata  ==  NULL )
72:310:		return ( 0 ) ;
72:311:		
72:312:	p 	=  bindata ;
72:313:
72:314:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:315:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:316:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:317:	   {
72:318:		switch ( Z_TYPE_PP ( item ) )
72:319:		   {
72:320:			case 	IS_LONG :
72:321:			case 	IS_BOOL :
72:322:				value 	=  Z_LVAL_PP ( item ) ;
72:323:				break ;
72:324:				
72:325:			case 	IS_DOUBLE :
72:326:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:327:				value 			=  box. long_value ;
72:328:				break ;
72:329:				
72:330:			default :
72:331:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:332:				efree ( bindata ) ;
72:333:				return ( 0 ) ;
72:334:		    }
72:335:		    
72:336:		index ++ ;
72:337:
72:338:		* ( p ++ )	=  ( value  >>  24 )  &  0xFF ;
72:339:		* ( p ++ )	=  ( value  >>  16 )  &  0xFF ;
72:340:		* ( p ++ )	=  ( value  >>   8 )  &  0xFF ;
72:341:		* ( p ++ )	=  value  &  0xFF ;
72:342:	    }	
72:343:
72:344:	* result	=  bindata ;
72:345:	* result_length =  real_size ;
72:346:	
72:347:	return ( 1 ) ;
72:348:    }
72:349:
72:350:    
72:351:/***
72:352:	QWORD functions 
72:353: ***/
72:354:THRAK_API zend_bool  internal_data_pack_dqm ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:355:   { return ( packer_table [ QWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( values, count, result, result_length TSRMLS_CC ) ) ; }
72:356:
72:357:   
72:358:THRAK_API zend_bool  internal_data_pack_dql ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:359:   {
72:360:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:361:	HashPosition 		pointer ;
72:362:	zval **			item ;
72:363:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:364:	int 			real_size 	=  real_count * 8 ;
72:365:	char *			bindata 	=  emalloc ( real_size ) ;
72:366:	char *			p ;
72:367:	long long		value ;
72:368:	int 			index 		=  0 ;
72:369:	boxed_double		box ;
72:370:	
72:371:	
72:372:	if  ( bindata  ==  NULL )
72:373:		return ( 0 ) ;
72:374:		
72:375:	p 	=  bindata ;
72:376:
72:377:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:378:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:379:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:380:	   {
72:381:		switch ( Z_TYPE_PP ( item ) )
72:382:		   {
72:383:			case 	IS_LONG :
72:384:			case 	IS_BOOL :
72:385:				value 	=  Z_LVAL_PP ( item ) ;
72:386:				break ;
72:387:				
72:388:			case 	IS_DOUBLE :
72:389:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:390:				value 			=  box. long_value ;
72:391:				break ;
72:392:				
72:393:			default :
72:394:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:395:				efree ( bindata ) ;
72:396:				return ( 0 ) ;
72:397:		    }
72:398:		    
72:399:		index ++ ;
72:400:		
72:401:		* ( p ++ )	=  value  &  0xFF ;
72:402:		* ( p ++ )	=  ( value  >>   8 )  &  0xFF ;
72:403:		* ( p ++ ) 	=  ( value  >>  16 )  &  0xFF ;
72:404:		* ( p ++ ) 	=  ( value  >>  24 )  &  0xFF ;
72:405:		* ( p ++ ) 	=  ( value  >>  32 )  &  0xFF ;
72:406:		* ( p ++ ) 	=  ( value  >>  40 )  &  0xFF ;
72:407:		* ( p ++ ) 	=  ( value  >>  48 )  &  0xFF ;
72:408:		* ( p ++ ) 	=  ( value  >>  56 )  &  0xFF ;
72:409:	    }	
72:410:
72:411:	* result	=  bindata ;
72:412:	* result_length =  real_size ;
72:413:	
72:414:	return ( 1 ) ;
72:415:    }
72:416:
72:417:THRAK_API zend_bool  internal_data_pack_dqb ( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC )
72:418:   {
72:419:	HashTable *		array_hash 	=  Z_ARRVAL_P ( values ) ;
72:420:	HashPosition 		pointer ;
72:421:	zval **			item ;
72:422:	int 			real_count 	=  ( count  > 0 ) ?  min  ( count, zend_hash_num_elements ( array_hash ) ) : zend_hash_num_elements ( array_hash ) ;
72:423:	int 			real_size 	=  real_count * 8 ;
72:424:	char *			bindata 	=  emalloc ( real_size ) ;
72:425:	char *			p ;
72:426:	long long		value ;
72:427:	int 			index 		=  0 ;
72:428:	boxed_double		box ;
72:429:	
72:430:	
72:431:	if  ( bindata  ==  NULL )
72:432:		return ( 0 ) ;
72:433:		
72:434:	p 	=  bindata ;
72:435:
72:436:	for  ( zend_hash_internal_pointer_reset_ex ( array_hash, & pointer) ; 
72:437:			index  <  real_count  &&  zend_hash_get_current_data_ex ( array_hash, ( void ** ) & item, & pointer )  ==  SUCCESS ; 
72:438:			zend_hash_move_forward_ex ( array_hash, & pointer ) ) 
72:439:	   {
72:440:		switch ( Z_TYPE_PP ( item ) )
72:441:		   {
72:442:			case 	IS_LONG :
72:443:			case 	IS_BOOL :
72:444:				value 	=  Z_LVAL_PP ( item ) ;
72:445:				break ;
72:446:				
72:447:			case 	IS_DOUBLE :
72:448:				box. double_value 	=  Z_DVAL_PP ( item ) ;
72:449:				value 			=  box. long_value ;
72:450:				break ;
72:451:				
72:452:			default :
72:453:				php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Non-numeric value found at index %d", index ) ;
72:454:				efree ( bindata ) ;
72:455:				return ( 0 ) ;
72:456:		    }
72:457:		    
72:458:		index ++ ;
72:459:
72:460:		* ( p ++ )	=  ( value  >>  56 )  &  0xFF ;
72:461:		* ( p ++ )	=  ( value  >>  48 )  &  0xFF ;
72:462:		* ( p ++ )	=  ( value  >>  40 )  &  0xFF ;
72:463:		* ( p ++ )	=  ( value  >>  32 )  &  0xFF ;
72:464:		* ( p ++ )	=  ( value  >>  24 )  &  0xFF ;
72:465:		* ( p ++ )	=  ( value  >>  16 )  &  0xFF ;
72:466:		* ( p ++ )	=  ( value  >>   8 )  &  0xFF ;
72:467:		* ( p ++ )	=  value  &  0xFF ;
72:468:	    }	
72:469:
72:470:	* result	=  bindata ;
72:471:	* result_length =  real_size ;
72:472:	
72:473:	return ( 1 ) ;
72:474:    }
72:475:
72:476:
72:477:
72:478:/*===========================================================================================================
72:479:
72:480:	Unpacking functions.
72:481:	
72:482: *===========================================================================================================*/
72:483: 
72:484:/***
72:485:	WORD functions 
72:486: ***/
72:487:THRAK_API zend_bool  internal_data_unpack_dwm ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:488:   { return ( unpacker_table [ WORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( binary_string, count, result TSRMLS_CC ) ) ; }
72:489:
72:490:
72:491:THRAK_API zend_bool  internal_data_unpack_dwl ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:492:   {
72:493:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 2, count ) : Z_STRLEN_P ( binary_string ) / 2 ;
72:494:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:495:	zval *		array_result ;
72:496:	long long 	value ;
72:497:	
72:498:	
72:499:	MAKE_STD_ZVAL ( array_result ) ;
72:500:	array_init ( array_result ) ;
72:501:	
72:502:	while  ( real_count -- )
72:503:	   {
72:504:		value 	=  ( * p ) |
72:505:			   ( ( * ( p + 1 ) ) <<  8 ) ;
72:506:			   
72:507:		p += 2 ;
72:508:			   
72:509:		add_next_index_long ( array_result, ( long ) value ) ;
72:510:	    }
72:511:	    
72:512:	* result 	=  array_result ;
72:513:	return ( 1 ) ;
72:514:    }
72:515:
72:516:    
72:517:THRAK_API zend_bool  internal_data_unpack_dwb ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:518:   {
72:519:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 2, count ) : Z_STRLEN_P ( binary_string ) / 2 ;
72:520:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:521:	zval *		array_result ;
72:522:	long long 	value ;
72:523:	
72:524:	
72:525:	MAKE_STD_ZVAL ( array_result ) ;
72:526:	array_init ( array_result ) ;
72:527:	
72:528:	while  ( real_count -- )
72:529:	   {
72:530:		value 	=  ( ( * p ) <<  8 ) |
72:531:			   ( ( * p + 1 ) ) ;
72:532:			   
72:533:		p += 2 ;
72:534:			   
72:535:		add_next_index_long ( array_result, ( long ) value ) ;
72:536:	    }
72:537:	    
72:538:	* result 	=  array_result ;
72:539:	return ( 1 ) ;
72:540:    }
72:541:
72:542:    
72:543:/***
72:544:	DWORD functions 
72:545: ***/
72:546:THRAK_API zend_bool  internal_data_unpack_ddm ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:547:   { return ( unpacker_table [ DWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( binary_string, count, result TSRMLS_CC ) ) ; }
72:548:
72:549:   
72:550:THRAK_API zend_bool  internal_data_unpack_ddl ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:551:   {
72:552:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 4, count ) : Z_STRLEN_P ( binary_string ) / 4 ;
72:553:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:554:	zval *		array_result ;
72:555:	long long 	value ;
72:556:	
72:557:	
72:558:	MAKE_STD_ZVAL ( array_result ) ;
72:559:	array_init ( array_result ) ;
72:560:	
72:561:	while  ( real_count -- )
72:562:	   {
72:563:		value 	=  ( * p ) |
72:564:			   ( ( * ( p + 1 ) ) <<   8 ) |
72:565:			   ( ( * ( p + 2 ) ) <<  16 ) |
72:566:			   ( ( * ( p + 3 ) ) <<  24 ) ;
72:567:			   
72:568:		p += 4 ;
72:569:
72:570:		add_next_index_long ( array_result, ( long ) value ) ;
72:571:	    }
72:572:	    
72:573:	* result 	=  array_result ;
72:574:	return ( 1 ) ;
72:575:    }
72:576: 
72:577: 
72:578:THRAK_API zend_bool  internal_data_unpack_ddb ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:579:   {
72:580:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 4, count ) : Z_STRLEN_P ( binary_string ) / 4 ;
72:581:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:582:	zval *		array_result ;
72:583:	long long 	value ;
72:584:	
72:585:	
72:586:	MAKE_STD_ZVAL ( array_result ) ;
72:587:	array_init ( array_result ) ;
72:588:	
72:589:	while  ( real_count -- )
72:590:	   {
72:591:		value 	=  ( ( * ( p + 3 ) )  ) |
72:592:			   ( ( * ( p + 2 ) ) <<   8 ) |
72:593:			   ( ( * ( p + 1 ) ) <<  16 ) |
72:594:			   ( ( * p ) << 24 ) ;
72:595:			   
72:596:		p += 4 ;
72:597:			   
72:598:		add_next_index_long ( array_result, ( long ) value ) ;
72:599:	    }
72:600:	    
72:601:	* result 	=  array_result ;
72:602:	return ( 1 ) ;
72:603:    }
72:604:    
72:605:    
72:606:/***
72:607:	QWORD functions 
72:608: ***/
72:609:THRAK_API zend_bool  internal_data_unpack_dqm ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:610:   { return ( unpacker_table [ QWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( binary_string, count, result TSRMLS_CC ) ) ; }
72:611:
72:612:   
72:613:THRAK_API zend_bool  internal_data_unpack_dql ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:614:   {
72:615:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 8, count ) : Z_STRLEN_P ( binary_string ) / 8 ;
72:616:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:617:	zval *		array_result ;
72:618:	long long 	value ;
72:619:	
72:620:	
72:621:	MAKE_STD_ZVAL ( array_result ) ;
72:622:	array_init ( array_result ) ;
72:623:	
72:624:	while  ( real_count -- )
72:625:	   {
72:626:		value 	=  ( long long ) ( * p ) |
72:627:			   ( ( ( long long ) ( * ( p + 1 ) ) ) <<   8 ) |
72:628:			   ( ( ( long long ) ( * ( p + 2 ) ) ) <<  16 ) |
72:629:			   ( ( ( long long ) ( * ( p + 3 ) ) ) <<  24 ) |
72:630:			   ( ( ( long long ) ( * ( p + 4 ) ) ) <<  32 ) |
72:631:			   ( ( ( long long ) ( * ( p + 5 ) ) ) <<  40 ) |
72:632:			   ( ( ( long long ) ( * ( p + 6 ) ) ) <<  48 ) |
72:633:			   ( ( ( long long ) ( * ( p + 7 ) ) ) <<  56 ) ;
72:634:			   
72:635:		p += 8 ;
72:636:
72:637:		add_next_index_long ( array_result, ( long ) value ) ;
72:638:	    }
72:639:	    
72:640:	* result 	=  array_result ;
72:641:	return ( 1 ) ;
72:642:    }
72:643:    
72:644:THRAK_API zend_bool  internal_data_unpack_dqb ( zval *  binary_string, int  count, zval **  result TSRMLS_DC )
72:645:   {
72:646:	int  		real_count 		=  ( count  >  0 ) ?  min ( Z_STRLEN_P ( binary_string ) / 8, count ) : Z_STRLEN_P ( binary_string ) / 8 ;
72:647:	char *		p			=  Z_STRVAL_P ( binary_string ) ;
72:648:	zval *		array_result ;
72:649:	long long 	value ;
72:650:	
72:651:	
72:652:	MAKE_STD_ZVAL ( array_result ) ;
72:653:	array_init ( array_result ) ;
72:654:	
72:655:	while  ( real_count -- )
72:656:	   {
72:657:		value 	=  ( ( long long ) ( * ( p + 7 ) )  ) |
72:658:			   ( ( long long ) ( * ( p + 6 ) ) <<   8 ) |
72:659:			   ( ( long long ) ( * ( p + 5 ) ) <<  16 ) |
72:660:			   ( ( long long ) ( * ( p + 4 ) ) <<  24 ) |
72:661:			   ( ( long long ) ( * ( p + 3 ) ) <<  32 ) |
72:662:			   ( ( long long ) ( * ( p + 2 ) ) <<  40 ) |
72:663:			   ( ( long long ) ( * ( p + 1 ) ) <<  48 ) |
72:664:			   ( ( long long ) ( * p ) << 56 ) ;
72:665:			   
72:666:		p += 4 ;
72:667:			   
72:668:		add_next_index_long ( array_result, ( long ) value ) ;
72:669:	    }
72:670:	    
72:671:	* result 	=  array_result ;
72:672:	return ( 1 ) ;
72:673:    }
72:674:    
72:675:    
72:676:/*===========================================================================================================
72:677:
72:678:	Packing/unpacking helper functions.
72:679:	
72:680: *===========================================================================================================*/
72:681:
72:682:/***
72:683:	packer_normalize_input -
72:684:		Ensures that the first argument of the xxxpack functions is always an array.
72:685:		Converts to an array if a single scalar value (long, double or bool) has been specified.
72:686: ***/
72:687:static zend_always_inline zend_bool  packer_normalize_input ( zval **  value TSRMLS_DC )
72:688:   {
72:689:	int 		status 	=  1 ;
72:690:	
72:691:	switch  ( Z_TYPE_PP ( value ) )
72:692:	   {
72:693:		case 	IS_ARRAY :
72:694:			 break ;
72:695:			
72:696:		case 	IS_LONG :
72:697:		case 	IS_DOUBLE :
72:698:		case 	IS_BOOL :
72:699:			convert_to_array_ex ( value ) ;
72:700:			break ;
72:701:			
72:702:		default :
72:703:			php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Only an array or a numeric value can be supplied as the first argument of a packing function" ) ;
72:704:			status 	=  0 ;
72:705:	    }
72:706:	    
72:707:	return ( status ) ;
72:708:    }
72:709: 
72:710:/***
72:711:	packer_check_endianness -
72:712:		Check that the supplied endianness constant is correct.
72:713: ***/
72:714:static zend_always_inline zend_bool  packer_check_endianness ( int  endianness TSRMLS_DC )
72:715:   {
72:716:	switch  ( endianness )
72:717:	   {
72:718:		case 	MACHINE_ENDIAN :
72:719:		case 	LITTLE_ENDIAN : 
72:720:		case 	BIG_ENDIAN :
72:721:			return ( 1 ) ;
72:722:			
72:723:		default :
72:724:			php_error_docref ( NULL TSRMLS_CC, E_WARNING, "The value supplied for the $endianness parameter must be one of the following constants : "
72:725:								      "DATA_LITTLE_ENDIAN, DATA_BIG_ENDIAN or DATA_MACHINE_ENDIAN" ) ;
72:726:			return ( 0 ) ;
72:727:	    }
72:728:    }  
72:729: 
72:730: 
72:731:/***
72:732:	packer_check_string -
72:733:		Checks that the specified zval is a string.
72:734: ***/
72:735:static zend_always_inline zend_bool  packer_check_zstring ( zval *  data TSRMLS_DC )
72:736:   {
72:737:	if  ( Z_TYPE_P ( data )  ==  IS_STRING )
72:738:		return ( 1 ) ;
72:739:	else
72:740:	   {
72:741:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Data to be unpacked must be a string." ) ;
72:742:		
72:743:		return ( 0 ) ;
72:744:	    }
72:745:    }
72:746:    
72:747:    
72:748:/*===========================================================================================================
72:749:
72:750:    NAME
72:751:	data_dwpack, ddpack, dqpack - Packs word/dword/qword values.
72:752:	
72:753:    PROTOTYPE
72:754:	$binstr 	=  data_dwpack ( $array, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS ] ] ) ;
72:755:	$binstr 	=  data_ddpack ( $array, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS ] ] ) ;
72:756:	$binstr 	=  data_dqpack ( $array, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS ] ] ) ;
72:757:	
72:758:	$binstr 	=  data_dwlpack ( $array, $count ) ;
72:759:	$binstr 	=  data_ddlpack ( $array, $count ) ;
72:760:	$binstr 	=  data_dqlpack ( $array, $count ) ;
72:761:	
72:762:	$binstr 	=  data_dwbpack ( $array, $count ) ;
72:763:	$binstr 	=  data_ddbpack ( $array, $count ) ;
72:764:	$binstr 	=  data_dqbpack ( $array, $count ) ;
72:765:
72:766:	$binstr 	=  data_dwmpack ( $array, $count ) ;
72:767:	$binstr 	=  data_ddmpack ( $array, $count ) ;
72:768:	$binstr 	=  data_dqmpack ( $array, $count ) ;
72:769:	
72:770:    DESCRIPTION
72:771:	These functions pack word/dword/qwords quantities, respectively.
72:772:	The groups of lpack/bpack/mpack functions packs values in little endian, big endian or machine endian
72:773:	format.
72:774:	
72:775:    PARAMETERS
72:776:	$array (array or scalar value) -
72:777:		Array of values to be packed, or a scalar value if only one value is to be packed.
72:778:		In this case, the $count parameter is ignored.
72:779:		
72:780:	$count (integer) -
72:781:		Number of values from $array to be packed. If not specified, all values will be packed.
72:782:		
72:783:	$endianness (integer) -
72:784:		Endianness of the packed values ; either DATA_LITTLE_ENDIAN, DATA_BIG_ENDIAN or 
72:785:		DATA_MACHINE_ENDIAN to use the machine endianness.
72:786:		
72:787:    RETURN VALUE
72:788:	A binary string containing the packed values, or false if an error occurred, such as not enough 
72:789:	memory.
72:790:	
72:791: *===========================================================================================================*/
72:792:
72:793:/***
72:794:	WORD functions.
72:795: ***/ 
72:796:PHP_FUNCTION ( data_dwpack )
72:797:   {
72:798:	zval *		array ;
72:799:	char *		result ;
72:800:	int 		result_length ;
72:801:	int 		count 		=  -1 ;
72:802:	int  		endianness	=  MACHINE_ENDIAN ;
72:803:	
72:804:	
72:805:	/* Parse arguments */
72:806:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|ll", & array, & count, & endianness )  ==  FAILURE )
72:807:		return;
72:808:	
72:809:	/* Ensure that the endianness has a correct value */
72:810:	if  ( ! packer_check_endianness ( endianness TSRMLS_CC ) )
72:811:		RETURN_FALSE ;
72:812:		
72:813:	/* Make sure the 1st argument is always an array */
72:814:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:815:	
72:816:	/* Call the appropriate packing function - return false if out of memory */
72:817:	if  ( ! packer_table [ WORD_PACKER ] [ endianness ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:818:		RETURN_FALSE ;
72:819:
72:820:	/* Return binary data */
72:821:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:822:    }
72:823: 
72:824: 
72:825:PHP_FUNCTION ( data_dwlpack )
72:826:   {
72:827:	zval *		array ;
72:828:	char *		result ;
72:829:	int 		result_length ;
72:830:	int 		count 		=  -1 ;
72:831:	
72:832:	
72:833:	/* Parse arguments */
72:834:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:835:		return;
72:836:	
72:837:	/* Make sure the 1st argument is always an array */
72:838:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:839:	
72:840:	/* Call the appropriate packing function - return false if out of memory */
72:841:	if  ( ! packer_table [ WORD_PACKER ] [ LITTLE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:842:		RETURN_FALSE ;
72:843:	
72:844:	/* Return binary data */
72:845:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:846:    }
72:847:
72:848:    
72:849:PHP_FUNCTION ( data_dwbpack )
72:850:   {
72:851:	zval *		array ;
72:852:	char *		result ;
72:853:	int 		result_length ;
72:854:	int 		count 		=  -1 ;
72:855:	
72:856:	
72:857:	/* Parse arguments */
72:858:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:859:		return;
72:860:	
72:861:	/* Make sure the 1st argument is always an array */
72:862:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:863:	
72:864:	/* Call the appropriate packing function - return false if out of memory */
72:865:	if  ( ! packer_table [ WORD_PACKER ] [ BIG_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:866:		RETURN_FALSE ;
72:867:	
72:868:	/* Return binary data */
72:869:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:870:    }
72:871:
72:872:    
72:873:PHP_FUNCTION ( data_dwmpack )
72:874:   {
72:875:	zval *		array ;
72:876:	char *		result ;
72:877:	int 		result_length ;
72:878:	int 		count 		=  -1 ;
72:879:	
72:880:	
72:881:	/* Parse arguments */
72:882:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:883:		return;
72:884:	
72:885:	/* Make sure the 1st argument is always an array */
72:886:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:887:	
72:888:	/* Call the appropriate packing function - return false if out of memory */
72:889:	if  ( ! packer_table [ WORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:890:		RETURN_FALSE ;
72:891:	
72:892:	/* Return binary data */
72:893:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:894:    }
72:895:
72:896: 
72:897:/***
72:898:	DWORD functions.
72:899: ***/ 
72:900: PHP_FUNCTION ( data_ddpack )
72:901:   {
72:902:	zval *		array ;
72:903:	char *		result ;
72:904:	int 		result_length ;
72:905:	int 		count 		=  -1 ;
72:906:	int  		endianness	=  MACHINE_ENDIAN ;
72:907:	
72:908:	
72:909:	/* Parse arguments */
72:910:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|ll", & array, & count, & endianness )  ==  FAILURE )
72:911:		return;
72:912:	
72:913:	/* Ensure that the endianness has a correct value */
72:914:	if  ( ! packer_check_endianness ( endianness TSRMLS_CC ) )
72:915:		RETURN_FALSE ;
72:916:		
72:917:	/* Make sure the 1st argument is always an array */
72:918:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:919:	
72:920:	/* Call the appropriate packing function - return false if out of memory */
72:921:	if  ( ! packer_table [ DWORD_PACKER ] [ endianness ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:922:		RETURN_FALSE ;
72:923:
72:924:	/* Return binary data */
72:925:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:926:    }
72:927: 
72:928: 
72:929:PHP_FUNCTION ( data_ddlpack )
72:930:   {
72:931:	zval *		array ;
72:932:	char *		result ;
72:933:	int 		result_length ;
72:934:	int 		count 		=  -1 ;
72:935:	
72:936:	
72:937:	/* Parse arguments */
72:938:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:939:		return;
72:940:	
72:941:	/* Make sure the 1st argument is always an array */
72:942:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:943:	
72:944:	/* Call the appropriate packing function - return false if out of memory */
72:945:	if  ( ! packer_table [ DWORD_PACKER ] [ LITTLE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:946:		RETURN_FALSE ;
72:947:	
72:948:	/* Return binary data */
72:949:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:950:    }
72:951:
72:952:    
72:953:PHP_FUNCTION ( data_ddbpack )
72:954:   {
72:955:	zval *		array ;
72:956:	char *		result ;
72:957:	int 		result_length ;
72:958:	int 		count 		=  -1 ;
72:959:	
72:960:	
72:961:	/* Parse arguments */
72:962:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:963:		return;
72:964:	
72:965:	/* Make sure the 1st argument is always an array */
72:966:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:967:	
72:968:	/* Call the appropriate packing function - return false if out of memory */
72:969:	if  ( ! packer_table [ DWORD_PACKER ] [ BIG_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:970:		RETURN_FALSE ;
72:971:	
72:972:	/* Return binary data */
72:973:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:974:    }
72:975:
72:976:    
72:977:PHP_FUNCTION ( data_ddmpack )
72:978:   {
72:979:	zval *		array ;
72:980:	char *		result ;
72:981:	int 		result_length ;
72:982:	int 		count 		=  -1 ;
72:983:	
72:984:	
72:985:	/* Parse arguments */
72:986:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:987:		return;
72:988:	
72:989:	/* Make sure the 1st argument is always an array */
72:990:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:991:	
72:992:	/* Call the appropriate packing function - return false if out of memory */
72:993:	if  ( ! packer_table [ DWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:994:		RETURN_FALSE ;
72:995:	
72:996:	/* Return binary data */
72:997:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:998:    }
72:999:
72:1000: 
72:1001:/***
72:1002:	QWORD functions.
72:1003: ***/ 
72:1004:PHP_FUNCTION ( data_dqpack )
72:1005:   {
72:1006:	zval *		array ;
72:1007:	char *		result ;
72:1008:	int 		result_length ;
72:1009:	int 		count 		=  -1 ;
72:1010:	int  		endianness	=  MACHINE_ENDIAN ;
72:1011:	
72:1012:	
72:1013:	/* Parse arguments */
72:1014:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|ll", & array, & count, & endianness )  ==  FAILURE )
72:1015:		return;
72:1016:	
72:1017:	/* Ensure that the endianness has a correct value */
72:1018:	if  ( ! packer_check_endianness ( endianness TSRMLS_CC ) )
72:1019:		RETURN_FALSE ;
72:1020:		
72:1021:	/* Make sure the 1st argument is always an array */
72:1022:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:1023:	
72:1024:	/* Call the appropriate packing function - return false if out of memory */
72:1025:	if  ( ! packer_table [ DWORD_PACKER ] [ endianness ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:1026:		RETURN_FALSE ;
72:1027:
72:1028:	/* Return binary data */
72:1029:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:1030:    }
72:1031: 
72:1032: 
72:1033:PHP_FUNCTION ( data_dqlpack )
72:1034:   {
72:1035:	zval *		array ;
72:1036:	char *		result ;
72:1037:	int 		result_length ;
72:1038:	int 		count 		=  -1 ;
72:1039:	
72:1040:	
72:1041:	/* Parse arguments */
72:1042:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:1043:		return;
72:1044:	
72:1045:	/* Make sure the 1st argument is always an array */
72:1046:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:1047:	
72:1048:	/* Call the appropriate packing function - return false if out of memory */
72:1049:	if  ( ! packer_table [ DWORD_PACKER ] [ LITTLE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:1050:		RETURN_FALSE ;
72:1051:	
72:1052:	/* Return binary data */
72:1053:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:1054:    }
72:1055:
72:1056:    
72:1057:PHP_FUNCTION ( data_dqbpack )
72:1058:   {
72:1059:	zval *		array ;
72:1060:	char *		result ;
72:1061:	int 		result_length ;
72:1062:	int 		count 		=  -1 ;
72:1063:	
72:1064:	
72:1065:	/* Parse arguments */
72:1066:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:1067:		return;
72:1068:	
72:1069:	/* Make sure the 1st argument is always an array */
72:1070:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:1071:	
72:1072:	/* Call the appropriate packing function - return false if out of memory */
72:1073:	if  ( ! packer_table [ DWORD_PACKER ] [ BIG_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:1074:		RETURN_FALSE ;
72:1075:	
72:1076:	/* Return binary data */
72:1077:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:1078:    }
72:1079:
72:1080:    
72:1081:PHP_FUNCTION ( data_dqmpack )
72:1082:   {
72:1083:	zval *		array ;
72:1084:	char *		result ;
72:1085:	int 		result_length ;
72:1086:	int 		count 		=  -1 ;
72:1087:	
72:1088:	
72:1089:	/* Parse arguments */
72:1090:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & array, & count )  ==  FAILURE )
72:1091:		return;
72:1092:	
72:1093:	/* Make sure the 1st argument is always an array */
72:1094:	packer_normalize_input ( & array TSRMLS_CC ) ;
72:1095:	
72:1096:	/* Call the appropriate packing function - return false if out of memory */
72:1097:	if  ( ! packer_table [ DWORD_PACKER ] [ MACHINE_ENDIAN_PACKER ] ( array, count, & result, & result_length TSRMLS_CC ) )
72:1098:		RETURN_FALSE ;
72:1099:	
72:1100:	/* Return binary data */
72:1101:	RETURN_STRINGL ( result, result_length, 0 ) ;
72:1102:    }
72:1103:
72:1104: 
72:1105:/*===========================================================================================================
72:1106:
72:1107:    NAME
72:1108:	data_dwunpack, ddunpack, dqunpack - unpacks word/dword/qword values.
72:1109:	
72:1110:    PROTOTYPE
72:1111:	$binstr 	=  data_dwunpack ( $data, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS, $count ] ] ) ;
72:1112:	$binstr 	=  data_ddunpack ( $data, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS, $count ] ] ) ;
72:1113:	$binstr 	=  data_dqunpack ( $data, [ count, [ $endianness = DATA_MACHINE_ENDIANNESS, $count ] ] ) ;
72:1114:	
72:1115:	$binstr 	=  data_dwlunpack ( $data, $count ) ;
72:1116:	$binstr 	=  data_ddlunpack ( $data, $count ) ;
72:1117:	$binstr 	=  data_dqlunpack ( $data, $count ) ;
72:1118:	
72:1119:	$binstr 	=  data_dwbunpack ( $data, $count ) ;
72:1120:	$binstr 	=  data_ddbunpack ( $data, $count ) ;
72:1121:	$binstr 	=  data_dqbunpack ( $data, $count ) ;
72:1122:
72:1123:	$binstr 	=  data_dwmunpack ( $data, $count ) ;
72:1124:	$binstr 	=  data_ddmunpack ( $data, $count ) ;
72:1125:	$binstr 	=  data_dqmunpack ( $data, $count ) ;
72:1126:	
72:1127:    DESCRIPTION
72:1128:	These functions unpack word/dword/qwords quantities, respectively.
72:1129:	The groups of lunpack/bunpack/munpack functions unpacks values in little endian, big endian or machine endian
72:1130:	format.
72:1131:	
72:1132:    PARAMETERS
72:1133:	$data (binary string) -
72:1134:		Values to be unpacked, stored as a binary string.
72:1135:		
72:1136:	$count (integer) -
72:1137:		Number of values from $array to be unpacked. If not specified, all values will be unpacked.
72:1138:		
72:1139:	$endianness (integer) -
72:1140:		Endianness of the unpacked values ; either DATA_LITTLE_ENDIAN, DATA_BIG_ENDIAN or 
72:1141:		DATA_MACHINE_ENDIAN to use the machine endianness.
72:1142:		
72:1143:    RETURN VALUE
72:1144:	An array containing the unpacked words/dwords/qwords.
72:1145:	
72:1146: *===========================================================================================================*/
72:1147:
72:1148:/***
72:1149:	WORD functions.
72:1150: ***/ 
72:1151:PHP_FUNCTION ( data_dwunpack )
72:1152:   {
72:1153:	zval *		data ;
72:1154:	zval *		result ;
72:1155:	int 		count 		=  -1 ;
72:1156:	int  		endianness	=  MACHINE_ENDIAN ;
72:1157:	
72:1158:	
72:1159:	/* Parse arguments */
72:1160:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|ll", & data, & count, & endianness )  ==  FAILURE )
72:1161:		return;
72:1162:	
72:1163:	/* Ensure that first argument is a string */
72:1164:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1165:		RETURN_FALSE ;
72:1166:	
72:1167:	/* Ensure that the endianness has a correct value */
72:1168:	if  ( ! packer_check_endianness ( endianness TSRMLS_CC ) )
72:1169:		RETURN_FALSE ;
72:1170:		
72:1171:	/* Call the appropriate unpacking function  */
72:1172:	if  ( ! unpacker_table [ WORD_UNPACKER ] [ endianness ] ( data, count, & result TSRMLS_CC ) )
72:1173:		RETURN_FALSE ;
72:1174:
72:1175:	/* Return binary data */
72:1176:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1177:    }
72:1178:
72:1179:    
72:1180:PHP_FUNCTION ( data_dwlunpack )
72:1181:   {
72:1182:	zval *		data ;
72:1183:	zval *		result ;
72:1184:	int 		count 		=  -1 ;
72:1185:	
72:1186:	
72:1187:	/* Parse arguments */
72:1188:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1189:		return;
72:1190:	
72:1191:	/* Ensure that first argument is a string */
72:1192:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1193:		RETURN_FALSE ;
72:1194:	
72:1195:	/* Call the appropriate unpacking function  */
72:1196:	if  ( ! unpacker_table [ WORD_UNPACKER ] [ LITTLE_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1197:		RETURN_FALSE ;
72:1198:
72:1199:	/* Return binary data */
72:1200:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1201:    }
72:1202:
72:1203:       
72:1204:PHP_FUNCTION ( data_dwbunpack )
72:1205:   {
72:1206:	zval *		data ;
72:1207:	zval *		result ;
72:1208:	int 		count 		=  -1 ;
72:1209:	
72:1210:	
72:1211:	/* Parse arguments */
72:1212:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1213:		return;
72:1214:	
72:1215:	/* Ensure that first argument is a string */
72:1216:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1217:		RETURN_FALSE ;
72:1218:	
72:1219:	/* Call the appropriate unpacking function  */
72:1220:	if  ( ! unpacker_table [ WORD_UNPACKER ] [ BIG_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1221:		RETURN_FALSE ;
72:1222:
72:1223:	/* Return binary data */
72:1224:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1225:    }
72:1226:
72:1227:    
72:1228:PHP_FUNCTION ( data_dwmunpack )
72:1229:   {
72:1230:	zval *		data ;
72:1231:	zval *		result ;
72:1232:	int 		count 		=  -1 ;
72:1233:	
72:1234:	
72:1235:	/* Parse arguments */
72:1236:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1237:		return;
72:1238:	
72:1239:	/* Ensure that first argument is a string */
72:1240:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1241:		RETURN_FALSE ;
72:1242:	
72:1243:	/* Call the appropriate unpacking function  */
72:1244:	if  ( ! unpacker_table [ WORD_UNPACKER ] [ MACHINE_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1245:		RETURN_FALSE ;
72:1246:
72:1247:	/* Return binary data */
72:1248:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1249:    }
72:1250:
72:1251:    
72:1252:/***
72:1253:	DWORD functions.
72:1254: ***/ 
72:1255:PHP_FUNCTION ( data_ddunpack )
72:1256:   {
72:1257:	zval *		data ;
72:1258:	zval *		result ;
72:1259:	int 		count 		=  -1 ;
72:1260:	int  		endianness	=  MACHINE_ENDIAN ;
72:1261:	
72:1262:	
72:1263:	/* Parse arguments */
72:1264:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|ll", & data, & count, & endianness )  ==  FAILURE )
72:1265:		return;
72:1266:	
72:1267:	/* Ensure that first argument is a string */
72:1268:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1269:		RETURN_FALSE ;
72:1270:	
72:1271:	/* Ensure that the endianness has a correct value */
72:1272:	if  ( ! packer_check_endianness ( endianness TSRMLS_CC ) )
72:1273:		RETURN_FALSE ;
72:1274:		
72:1275:	/* Call the appropriate unpacking function  */
72:1276:	if  ( ! unpacker_table [ DWORD_UNPACKER ] [ endianness ] ( data, count, & result TSRMLS_CC ) )
72:1277:		RETURN_FALSE ;
72:1278:
72:1279:	/* Return binary data */
72:1280:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1281:    }
72:1282:
72:1283:    
72:1284:PHP_FUNCTION ( data_ddlunpack )
72:1285:   {
72:1286:	zval *		data ;
72:1287:	zval *		result ;
72:1288:	int 		count 		=  -1 ;
72:1289:	
72:1290:	
72:1291:	/* Parse arguments */
72:1292:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1293:		return;
72:1294:	
72:1295:	/* Ensure that first argument is a string */
72:1296:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1297:		RETURN_FALSE ;
72:1298:	
72:1299:	/* Call the appropriate unpacking function  */
72:1300:	if  ( ! unpacker_table [ DWORD_UNPACKER ] [ LITTLE_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1301:		RETURN_FALSE ;
72:1302:
72:1303:	/* Return binary data */
72:1304:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1305:    }
72:1306:
72:1307:       
72:1308:PHP_FUNCTION ( data_ddbunpack )
72:1309:   {
72:1310:	zval *		data ;
72:1311:	zval *		result ;
72:1312:	int 		count 		=  -1 ;
72:1313:	
72:1314:	
72:1315:	/* Parse arguments */
72:1316:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1317:		return;
72:1318:	
72:1319:	/* Ensure that first argument is a string */
72:1320:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1321:		RETURN_FALSE ;
72:1322:	
72:1323:	/* Call the appropriate unpacking function  */
72:1324:	if  ( ! unpacker_table [ DWORD_UNPACKER ] [ BIG_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1325:		RETURN_FALSE ;
72:1326:
72:1327:	/* Return binary data */
72:1328:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1329:    }
72:1330:
72:1331:    
72:1332:PHP_FUNCTION ( data_ddmunpack )
72:1333:   {
72:1334:	zval *		data ;
72:1335:	zval *		result ;
72:1336:	int 		count 		=  -1 ;
72:1337:	
72:1338:	
72:1339:	/* Parse arguments */
72:1340:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z|l", & data, & count )  ==  FAILURE )
72:1341:		return;
72:1342:	
72:1343:	/* Ensure that first argument is a string */
72:1344:	if  ( ! packer_check_zstring ( data TSRMLS_CC ) )
72:1345:		RETURN_FALSE ;
72:1346:	
72:1347:	/* Call the appropriate unpacking function  */
72:1348:	if  ( ! unpacker_table [ DWORD_UNPACKER ] [ MACHINE_ENDIAN_UNPACKER ] ( data, count, & result TSRMLS_CC ) )
72:1349:		RETURN_FALSE ;
72:1350:
72:1351:	/* Return binary data */
72:1352:	RETURN_ZVAL ( result, 0, 0 ) ;
72:1353:    }
72:1354:
72:1355:    
72:1356:
72:1357:/*===========================================================================================================
72:1358:
72:1359:    NAME
72:1360:	internal_data_decode_format
72:1361:	
72:1362:    DESCRIPTION
72:1363:	Decodes a data_pack/data_unpack format specified.
72:1364:	
72:1365:    RETURN VALUE
72:1366:	Number of bytes
72:1367:	
72:1368: *===========================================================================================================*/
72:1369: 
72:1370:// __get_repeat_count -
72:1371://	Parses a repeat count after a format specifier.
72:1372://	A repeat count can be :
72:1373://	- A positive integer
72:1374://	- A '*' sign, meaning "until input data is exhausted"
72:1375://	- Or nothing, which is equivalent to '1'
72:1376:static zend_always_inline int 	__get_repeat_count ( char **  p, int *  pc )
72:1377:   {
72:1378:	int  		value ;
72:1379:	char *		q 		=  * p ;
72:1380:	
72:1381:	if  ( * q  ==  '*' )
72:1382:	   {
72:1383:		q ++ ;
72:1384:		* p 	=  q ;
72:1385:		* pc  -- ;
72:1386:		
72:1387:		return ( - 1 ) ;
72:1388:	    }
72:1389:	else if  ( isdigit ( * q ) )
72:1390:	   {
72:1391:		value 		=  0 ;
72:1392:		
72:1393:		while  ( * pc  &&  isdigit ( * q ) )
72:1394:		   {
72:1395:			value 	=  ( value * 10 ) + ( * q - '0' ) ;
72:1396:			q ++ ;
72:1397:			* pc -- ;
72:1398:		    }
72:1399:		    
72:1400:		* p 	=  q ;
72:1401:		
72:1402:		return ( value ) ;
72:1403:	    }
72:1404:	else
72:1405:		return ( 1 ) ;
72:1406:    }
72:1407:
72:1408:// __get_remaining_size :
72:1409://	Given a repeat count, data size and current zval argument, returns the actual number of bytes
72:1410://	that can be retrieved.
72:1411://	Returns -1 if 
72:1412://static zend_always_inline int  __get_remaining_size ( 
72:1413:// array_flatten ( zval * ) ;
72:1414:
72:1415:THRAK_API int  internal_data_decode_format ( const char * 		format,
72:1416:				   int 				format_length,
72:1417:				   int 				argc,
72:1418:				   zval **			argv,
72:1419:				   packing_data_format **	output_format_specifiers,
72:1420:				   int *			output_format_count 
72:1421:				   TSRMLS_DC ) 
72:1422:   {
72:1423:	packing_data_format *		format_specifiers ;					/* Format specifiers and format specifier count 						*/
72:1424:	int  				format_specifier_count 		=  0 ;
72:1425:	int  				current_argc 			=  0 ;			/* Current input argument 									*/
72:1426:	int  				byte_count 			=  0 ;			/* Number of bytes needed for packing 								*/
72:1427:	packing_data_format *		fsp ;							/* Pointer to next format specifier structure 							*/
72:1428:	char * 				p ;							/* Pointer to the format string 								*/
72:1429:	int  				pc 				=  format_length ;	/* Number of format characters remaining							*/
72:1430:	char  				format_character ;					/* Format specifier : format character 								*/
72:1431:	int 				repeat_count,						/* Format specifier : number of elements to process (-1 = until the end of the input argument)	*/
72:1432:	 				flags,							/* Format specifier : additional flags								*/
72:1433:					size ;							/* Format specifier : computed size of input data 						*/
72:1434:	
72:1435:	// Check if a valid format string has been specified.
72:1436:	if  ( format_length  <  1 )
72:1437:	   {
72:1438:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Missing or null format specifier." ) ;
72:1439:		return ( -1 ) ;
72:1440:	    }
72:1441:	    
72:1442:	// Allocate first as much format specifier entries as there are characters in the input string. We will adjust 
72:1443:	// to the real size before leaving
72:1444:	format_specifiers 	=  ( packing_data_format * ) emalloc ( format_length * sizeof ( packing_data_format ) ) ;
72:1445:	
72:1446:	if  ( format_specifiers  ==  NULL )
72:1447:		return ( -1 ) ;
72:1448:
72:1449:	p 	=  ( char * ) format ;
72:1450:	fsp 	=  format_specifiers ;
72:1451:	
72:1452:	while  ( pc )
72:1453:	   {
72:1454:		repeat_count 		=  0 ;
72:1455:		flags 			=  0 ;
72:1456:		size 			=  0 ;
72:1457:		format_character 	=  * p ;
72:1458:		
72:1459:		/* Determine format specifier, length and input arguments needed */
72:1460:		switch  ( * p )
72:1461:		   {
72:1462:			/* Formats that always take one argument : */
72:1463:				
72:1464:				/* Format 'a' : null-padded string */
72:1465:				case 	PACK_FORMAT_NULL_PADDED_STRING :
72:1466:					repeat_count 	=  __get_repeat_count ( & p, & pc ) ;
72:1467:					//size 		=  __get_remaining_size ( & argv, argc, repeat_count, 1 ) ;
72:1468:					break ;
72:1469:		    }
72:1470:		
72:1471:		/* Create new format specifier entry if format character is a valid one */
72:1472:		if  ( format_character )
72:1473:		   {
72:1474:			fsp -> format 	=  format_character ;
72:1475:			fsp -> flags 	=  flags ;
72:1476:			fsp -> repeat 	=  repeat_count ;
72:1477:			fsp -> size 	=  size ;
72:1478:			
72:1479:			fsp ++, format_specifier_count ++ ;
72:1480:		    }
72:1481:		// Otherwise, abort parsing
72:1482:		else
72:1483:		   {
72:1484:			efree ( format_specifiers ) ;
72:1485:			return ( -1 ) ;
72:1486:		    }
72:1487:	    }
72:1488:	
72:1489:	// Last checks before returning
72:1490:	if  ( ! format_specifier_count )		// No format specifier ?
72:1491:	   {
72:1492:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "No valid format specifier found." ) ;
72:1493:		return ( -1 ) ;
72:1494:	    }
72:1495:	
72:1496:	if  ( current_argc  <  argc )			// Unused arguments ?
72:1497:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "%d arguments unused", argc - current_argc ) ;
72:1498:	
72:1499:	// Resize down the format specifiers array (remember : we allocated format_length entries at the beginning of the function, that was a max)
72:1500:	if  ( format_specifier_count  !=  format_length ) 		
72:1501:	   {
72:1502:		format_specifiers 	=  erealloc ( format_specifiers, format_specifier_count * sizeof ( packing_data_format ) ) ;
72:1503:		
72:1504:		if  ( format_specifiers  ==  NULL )
72:1505:			return ( -1 ) ;
72:1506:	    }
72:1507:	    
72:1508:	// All done, return
72:1509:	* output_format_specifiers 	=  format_specifiers ;
72:1510:	* output_format_count 		=  format_specifier_count ;
72:1511:    }
72:1512:    
72:1513:    
72:1514:/*===========================================================================================================
72:1515:
72:1516:    NAME
72:1517:	data_pack - Packs series of data.
72:1518:	
72:1519:    DESCRIPTION
72:1520:	
72:1521:	
72:1522: *===========================================================================================================*/
72:1523:THRAK_API int  internal_data_pack ( const char * 			format_string,
72:1524:			  int  				format_string_length,
72:1525:			  int 				argc,
72:1526:			  zval **			argv,
72:1527:			  char ** 			result,
72:1528:			  size_t *			result_length
72:1529:			  TSRMLS_DC ) 
72:1530:   {
72:1531:	int  		current_argc 	=  argc ;
72:1532:	zval **		current_argv 	=  argv ;
72:1533:	char 		ch ;
72:1534:	int  		repeat_count ;
72:1535:	int 		total_size 		=  0 ;
72:1536:	
72:1537:	while  ( format_string_length -- )
72:1538:	   {
72:1539:		ch 	=  * format_string ++ ;
72:1540:		
72:1541:		if  ( format_string_length )
72:1542:		   {
72:1543:			if  ( * format_string  ==  '*' )
72:1544:			   {
72:1545:				repeat_count 	=  -1 ;
72:1546:				format_string ++ ;
72:1547:				format_string_length -- ;
72:1548:				
72:1549:				total_size 	+=  Z_STRLEN_PP ( current_argv ) ;
72:1550:			    }
72:1551:			else if  ( isdigit ( * format_string ) )
72:1552:			   {
72:1553:				repeat_count 	=  0 ;
72:1554:				
72:1555:				while  ( isdigit ( * format_string ) )
72:1556:				   {
72:1557:					repeat_count 	=  ( repeat_count * 10 ) + ( * format_string - '0' ) ;
72:1558:					format_string ++ ;
72:1559:					format_string_length -- ;
72:1560:				    }
72:1561:				    
72:1562:				total_size 	+=  repeat_count ;
72:1563:			    }
72:1564:		    }
72:1565:
72:1566:		current_argc --, current_argv ++ ;
72:1567:	    }
72:1568:
72:1569:	if  ( current_argc )
72:1570:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "%d arguments unused", ( argc - current_argc ) ) ;
72:1571:
72:1572:	return ( 1 ) ;
72:1573:    }
72:1574:    
72:1575:    
72:1576:PHP_FUNCTION(data_pack)
72:1577:   {
72:1578:	char * 		format ;
72:1579:	int 		format_length ;
72:1580:	zval ***	argv ;
72:1581:	int  		argc ;
72:1582:	char *		result ;
72:1583:	size_t 		result_length ;
72:1584:	
72:1585:	
72:1586:	/* Parse arguments */
72:1587:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "s+", & format, & format_length, & argv, & argc ) == FAILURE )
72:1588:		return;
72:1589:	
72:1590:	if  ( internal_data_pack ( format, format_length, argc, * argv, & result, & result_length TSRMLS_CC ) )
72:1591:	   {
72:1592:		efree ( argv ) ;
72:1593:		//RETURN_STRINGL ( result, ( long ) result_length, 0 ) ;
72:1594:		RETURN_FALSE;
72:1595:	    }
72:1596:	else
72:1597:	   {
72:1598:		efree ( argv ) ;
72:1599:		RETURN_FALSE ;
72:1600:	    }
72:1601:   }
72:1602:
72:1603:    
72:1604:/*===========================================================================================================
72:1605:
72:1606:    NAME
72:1607:	data_unpack - Packs series of data.
72:1608:	
72:1609:    DESCRIPTION
72:1610:	
72:1611:	
72:1612: *===========================================================================================================*/
72:1613:PHP_FUNCTION(data_unpack)
72:1614:   {
72:1615:	php_error_docref(NULL TSRMLS_CC, E_WARNING, "not yet implemented");
72:1616:    }
72:1617:73:1:/************************************************************************************************************
73:2:
73:3:    NAME
73:4:	data.h
73:5:	
73:6:    DESCRIPTION
73:7:	Definitions for data-related functions.
73:8:	
73:9:    AUTHOR
73:10:	Christian Vigh, 11/2014.
73:11:	
73:12:    HISTORY 
73:13:	tbd
73:14:
73:15: ************************************************************************************************************/
73:16:# ifndef 	__DATA_H__
73:17:# 	define	__DATA_H__
73:18:
73:19:language_block ( C ) ;
73:20:
73:21:/*-----------------------------------------------------------------------------------------------------------
73:22:
73:23:	Packing/unpacking structure information.
73:24:	
73:25: *-----------------------------------------------------------------------------------------------------------*/
73:26:
73:27:/* Format specifiers characters */
73:28:# define 	PACK_FORMAT_NULL_PADDED_STRING 		'a' 
73:29:
73:30:/* Format specifier structure */
73:31:typedef struct  packing_data_format
73:32:   {
73:33:	char 	format ;				/* Format specifier 									*/
73:34:	int 	flags ;					/* Extra flags 										*/
73:35:	int 	repeat ;				/* Length specified after the format specifier 						*/
73:36:	int 	size ;					/* When input arguments are available, indicates how much bytes can be retrieved 	*/
73:37:    } packing_data_format ;
73:38: 
73:39:/* Boxing structure */
73:40:typedef struct  packing_boxing_value
73:41:   {
73:42:	union
73:43:	   {
73:44:		char *		p ;
73:45:		short int 	si ;
73:46:		int 		i ;
73:47:		float 		f ;
73:48:		double 		d ;
73:49:		long 		l ;
73:50:		long long 	ll ;
73:51:	    } ;
73:52:    }   packing_boxing_value ;
73:53: 
73:54: 
73:55:/*-----------------------------------------------------------------------------------------------------------
73:56:
73:57:	External functions.
73:58:	
73:59: *-----------------------------------------------------------------------------------------------------------*/
73:60: 
73:61:/* Packing functions */
73:62:extern				PHP_FUNCTION ( data_dwpack ) ;
73:63:extern 				PHP_FUNCTION ( data_dwlpack ) ;
73:64:extern 				PHP_FUNCTION ( data_dwbpack ) ;
73:65:extern 				PHP_FUNCTION ( data_dwmpack ) ;
73:66:
73:67:extern 				PHP_FUNCTION ( data_ddpack ) ;
73:68:extern 				PHP_FUNCTION ( data_ddlpack ) ;
73:69:extern 				PHP_FUNCTION ( data_ddbpack ) ;
73:70:extern 				PHP_FUNCTION ( data_ddmpack ) ;
73:71:
73:72:extern 				PHP_FUNCTION ( data_dqpack ) ;
73:73:extern 				PHP_FUNCTION ( data_dqlpack ) ;
73:74:extern 				PHP_FUNCTION ( data_dqbpack ) ;
73:75:extern 				PHP_FUNCTION ( data_dqmpack ) ;
73:76:
73:77:/* Internal packing functions - Note that the pack_dxm functions are not used by the PHP_FUNCTIONs but provided for internal convenience */
73:78:extern THRAK_API zend_bool	internal_data_pack_dwl 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:79:extern THRAK_API zend_bool	internal_data_pack_dwb 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:80:extern THRAK_API zend_bool	internal_data_pack_dwm 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:81:
73:82:extern THRAK_API zend_bool	internal_data_pack_ddl 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:83:extern THRAK_API zend_bool	internal_data_pack_ddb 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:84:extern THRAK_API zend_bool	internal_data_pack_ddm 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:85:
73:86:extern THRAK_API zend_bool	internal_data_pack_dql 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:87:extern THRAK_API zend_bool	internal_data_pack_dqb 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:88:extern THRAK_API zend_bool	internal_data_pack_dqm 			( zval *  values, int  count, char **  result, int *  result_length TSRMLS_DC ) ;
73:89:
73:90:			
73:91:/* Unpacking functions */			
73:92:extern 				PHP_FUNCTION ( data_dwunpack ) ;
73:93:extern 				PHP_FUNCTION ( data_dwlunpack ) ;
73:94:extern 				PHP_FUNCTION ( data_dwbunpack ) ;
73:95:extern 				PHP_FUNCTION ( data_dwmunpack ) ;
73:96:
73:97:extern 				PHP_FUNCTION ( data_ddunpack ) ;
73:98:extern 				PHP_FUNCTION ( data_ddlunpack ) ;
73:99:extern 				PHP_FUNCTION ( data_ddbunpack ) ;
73:100:extern 				PHP_FUNCTION ( data_ddmunpack ) ;
73:101:
73:102:/* Internal unpacking functions - still for the convenience of internal needs */
73:103:extern THRAK_API zend_bool 	internal_data_unpack_dwl 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:104:extern THRAK_API zend_bool 	internal_data_unpack_dwb 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:105:extern THRAK_API zend_bool 	internal_data_unpack_dwm 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:106:									  
73:107:extern THRAK_API zend_bool 	internal_data_unpack_ddl 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:108:extern THRAK_API zend_bool 	internal_data_unpack_ddb 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:109:extern THRAK_API zend_bool 	internal_data_unpack_ddm 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:110:									  
73:111:extern THRAK_API zend_bool 	internal_data_unpack_dql 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:112:extern THRAK_API zend_bool 	internal_data_unpack_dqb 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:113:extern THRAK_API zend_bool 	internal_data_unpack_dqm 		( zval *  binary_data, int  count, zval **  result TSRMLS_DC ) ;
73:114:									  
73:115: 
73:116:/* General packing/unpacking functions */
73:117:extern THRAK_API int 		internal_data_decode_format 		( const char * 			format,
73:118:									  int 				format_length,
73:119:									  int 				argc,
73:120:									  zval **			argv,
73:121:									  packing_data_format **	output_format_specifiers,
73:122:									  int *				output_format_count 
73:123:									  TSRMLS_DC ) ;
73:124:									  
73:125:extern  			PHP_FUNCTION( data_pack ) ;
73:126:extern  THRAK_API int 		internal_data_pack 			( const char * 			format,
73:127:									  int  				format_length,
73:128:									  int 				argc,
73:129:									  zval **			argv,
73:130:									  char ** 			result,
73:131:									  size_t *			result_length
73:132:									  TSRMLS_DC ) ;
73:133:
73:134:extern  			PHP_FUNCTION ( data_unpack ) ;
73:135:extern  THRAK_API int 		internal_data_unpack 			( const char * 			format,
73:136:									  int  				format_length,
73:137:									  int 				argc,
73:138:									  char **			argv,
73:139:									  char ** 			result,
73:140:									  size_t *			result_length ) ;
73:141:
73:142:extern void 			data_initialize				( THRAK_INIT_FUNC_ARGS ) ;
73:143:extern void 			data_shutdown				( THRAK_SHUTDOWN_FUNC_ARGS ) ;
73:144:
73:145:end_language_block ( C ) ;
73:146:
73:147:# endif		/* __DATA_H__  */74:1:/************************************************************************************************************
74:2:
74:3:    NAME
74:4:	data_statics.h
74:5:	
74:6:    DESCRIPTION
74:7:	Variables that must be initialized only once.
74:8:	
74:9:    AUTHOR
74:10:	Christian Vigh, 11/2014.
74:11:	
74:12:    HISTORY 
74:13:	tbd
74:14:
74:15: ************************************************************************************************************/
74:16:# ifndef 	__DATA_STATICS_H__
74:17:# 	define	__DATA_STATICS_H__
74:18:
74:19:/*-----------------------------------------------------------------------------------------------------------
74:20:
74:21:	Function arguments type information for data.c.
74:22:	
74:23: *-----------------------------------------------------------------------------------------------------------*/
74:24:/* data_dxpack() */
74:25:THRAK_BEGIN_ARG_INFO_EX(data_dxpack, 0, 0, 1)
74:26:	THRAK_BYVAL_ARG_INFO(array)
74:27:	THRAK_BYVAL_ARG_INFO(count)
74:28:	THRAK_BYVAL_ARG_INFO(endianness)
74:29:THRAK_END_ARG_INFO ;
74:30:
74:31:/* data_dxxpack(),  */
74:32:THRAK_BEGIN_ARG_INFO_EX(data_dxxpack, 0, 0, 1)
74:33:	THRAK_BYVAL_ARG_INFO(array)
74:34:	THRAK_BYVAL_ARG_INFO(count)
74:35:THRAK_END_ARG_INFO ;
74:36:
74:37:/* data_dxunpack() */
74:38:THRAK_BEGIN_ARG_INFO_EX(data_dxunpack, 0, 0, 1)
74:39:	THRAK_BYVAL_ARG_INFO(data)
74:40:	THRAK_BYVAL_ARG_INFO(count)
74:41:	THRAK_BYVAL_ARG_INFO(endianness)
74:42:THRAK_END_ARG_INFO ;
74:43:
74:44:/* data_dxxunpack() */
74:45:THRAK_BEGIN_ARG_INFO_EX(data_dxxunpack, 0, 0, 1)
74:46:	THRAK_BYVAL_ARG_INFO(data)
74:47:	THRAK_BYVAL_ARG_INFO(count)
74:48:THRAK_END_ARG_INFO ;
74:49:
74:50:/* data_pack() */
74:51:THRAK_BEGIN_ARG_INFO_EX(data_pack, 0, 0, 2)
74:52:	THRAK_BYVAL_ARG_INFO(format)
74:53:	THRAK_BYVAL_ARG_VARIADIC_INFO(args)
74:54:THRAK_END_ARG_INFO ;
74:55:
74:56:/* data_unpack() */
74:57:THRAK_BEGIN_ARG_INFO_EX(data_unpack, 0, 0, 2)
74:58:	THRAK_BYVAL_ARG_INFO(format)
74:59:	THRAK_BYVAL_ARG_VARIADIC_INFO(args)
74:60:THRAK_END_ARG_INFO ;
74:61:
74:62:
74:63:# endif		/* __DATA_STATICS_H__  */75:1:/************************************************************************************************************
75:2:
75:3:    NAME
75:4:	ini_helpers.c
75:5:	
75:6:    DESCRIPTION
75:7:	Helper functions for parsing .INI file values.
75:8:	
75:9:    AUTHOR
75:10:	Christian Vigh, 11/2014.
75:11:	
75:12:    HISTORY 
75:13:	tbd
75:14:
75:15: ************************************************************************************************************/
75:16:# include 	"thrak.h"
75:17:# include 	<ctype.h>
75:18:# include 	<math.h>
75:19:
75:20:
75:21:/*===========================================================================================================
75:22:
75:23:    NAME
75:24:	thrak_ini_get_string - retrieves a .ini setting as a string
75:25:	
75:26:    PROTOTYPE 
75:27:	char *  value 	=  thrak_ini_get_string ( char *  setting, char *  default_value ) ;
75:28:	
75:29:    DESCRIPTION
75:30:		Retrieves a .ini setting as a string.
75:31:		
75:32:    PARAMETERS
75:33:	- setting (char *) :
75:34:		.INI file setting whose value is to be retrieved.
75:35:		
75:36:	- default_value (char *) :
75:37:		Default value to be returned when the setting does not exist.
75:38:				
75:39:    RETURNS
75:40:	A string that contains the .ini setting value, NULL if the setting is not defined or empty if defined.
75:41:	The default value will be substituted only if the setting is not defined.
75:42:	The return value is dynamically allocated and must be freed.
75:43:	
75:44: *===========================================================================================================*/
75:45:THRAK_API char * 	thrak_ini_get_string ( char *  setting, char *  default_value )
75:46:   {
75:47:	char * 		result 		=  zend_ini_string ( setting, ( long ) strlen ( setting ) + 1, 0 ) ;
75:48:
75:49:	
75:50:	if  ( result  ==  NULL )
75:51:	   {
75:52:		if  ( default_value  ==  NULL )
75:53:			return ( NULL ) ;
75:54:		else
75:55:			result 	=  default_value ;
75:56:	    }
75:57:		
75:58:	result 	=  thrak_trim ( result, NULL ) ;
75:59:
75:60:	return ( result ) ;
75:61:    }
75:62: 
75:63: 
75:64:/*===========================================================================================================
75:65:
75:66:    NAME
75:67:	thrak_ini_parse_byte_quantity - retrieves a byte quantity from a .INI value.
75:68:	
75:69:    PROTOTYPE 
75:70:	status 	=  thrak_ini_parse_byte_quantity ( char *  value, thrak_byte_quantity *  quantity ) ;
75:71:	
75:72:    DESCRIPTION
75:73:	Gets a byte quantity from a .INI setting. Quantities can be :
75:74:	- A byte count, specified as an integer
75:75:	- An integer followed by a string representing a quantity :
75:76:		- "k" or "kb" for kilobytes
75:77:		- "m" or "mb" for megabytes
75:78:		- "g" or "gb" for gigabytes
75:79:	
75:80:    PARAMETERS
75:81:	- value (char *) :
75:82:		String value to be parsed.
75:83:		
75:84:	- quantity (thrak_byte_quantity *) :
75:85:		A structure that will receive the parsed quantity information. It has the following fields :
75:86:		- bytes (long) :
75:87:			Total number of bytes.
75:88:		- quantity (long) :
75:89:			The initial quantity (for example, "1024" when the initial value is "1024mb").
75:90:		- multiplier (long) :
75:91:			The quantity multiplier (1024 for kilobytes, etc.).
75:92:		- multiplier_string (char *) :
75:93:			Noprmalized multiplier string ("Kb" for kilobytes, "Mb" for megabytes, etc.)
75:94:		
75:95:    RETURNS
75:96:	1 if the function succeded, 0 otherwise.
75:97:	
75:98: *===========================================================================================================*/
75:99:THRAK_API int  thrak_ini_parse_byte_quantity ( char *  value, thrak_byte_quantity *  qstruct )
75:100:   {
75:101:	char *		start	=  value,	
75:102:	     *		end 	=  NULL ;
75:103:	long 		quantity ;
75:104:	char *		multiplier_string 		=  "" ;
75:105:	int 		multiplier			=  1 ;
75:106:	
75:107:	
75:108:	/* Get a default value, if ini setting is empty */
75:109:	if  ( value  ==  NULL  ||  ! * value )
75:110:		return ( 0 ) ;
75:111:	
75:112:	/* Get first part, which should be a positive integer */
75:113:	quantity 	=  strtol ( start, & end, 0 ) ;
75:114:	
75:115:	/* Error checking : quantity must start with an integer value */
75:116:	if  ( end  ==  NULL )
75:117:		return ( 0 ) ;
75:118:		
75:119:	/* Error checking : size must be strictly positive */
75:120:	if  ( quantity  <  0 )
75:121:		return ( 0 ) ;
75:122:	    
75:123:	
75:124:	/* Skip spaces after the leading integer */
75:125:	value 	=  end ;
75:126:
75:127:	while  ( * value  &&  isspace ( * value ) )
75:128:		value ++ ;
75:129:		
75:130:	/* If something after, it must be a multiplier (kb, mb, etc) */
75:131:	if  ( * value )
75:132:	   {
75:133:		if  ( ! strcasecmp ( value, "b" ) )
75:134:			;
75:135:		else if  ( ! strcasecmp ( value, "k" )  ||  ! strcasecmp ( value, "kb" ) )
75:136:		   {
75:137:			multiplier_string 	=  "Kb" ;
75:138:			multiplier 		=  1024 ;
75:139:		    }
75:140:		else if  ( ! strcasecmp ( value, "m" )  ||  ! strcasecmp ( value, "mb" ) )
75:141:		   {
75:142:			multiplier_string 	=  "Mb" ;
75:143:			multiplier 		=  1024 * 1024;
75:144:		    }
75:145:		else if  ( ! strcasecmp ( value, "g" )  ||  ! strcasecmp ( value, "gb" ) )
75:146:		   {
75:147:			multiplier_string 	=  "Gb" ;
75:148:			multiplier 		=  1024 * 1024 * 1024 ;
75:149:		    }
75:150:		else
75:151:			return ( 0 ) ;
75:152:	    }
75:153:
75:154:	/* Initialize the byte_quantity structure */
75:155:	qstruct -> bytes 		=  quantity * multiplier ;
75:156:	qstruct -> quantity 		=  quantity ;
75:157:	qstruct -> multiplier_string	=  multiplier_string ;
75:158:	qstruct -> multiplier 		=  multiplier ;
75:159:	
75:160:	/* All done, report everything is ok */
75:161:	return ( 1 ) ;
75:162:    }
75:163:    
75:164:    
75:165:/*===========================================================================================================
75:166:
75:167:    NAME
75:168:	thrak_ini_parse_percentage - retrieves a percentage from a .INI value.
75:169:	
75:170:    PROTOTYPE 
75:171:	status 	=  thrak_ini_parse_percentage ( char *  value, double *  percentage ) ;
75:172:	
75:173:    DESCRIPTION
75:174:	Gets a percentage value from a .ini setting.
75:175:	
75:176:    PARAMETERS
75:177:	- value (char *) :
75:178:		.INI file setting whose value is to be parsed.
75:179:		
75:180:	- percentage (double *) :
75:181:		Address of a doiuble that will receive the parsed value.
75:182:		
75:183:    RETURNS
75:184:	1 if the function succeded, 0 otherwise.
75:185:	
75:186: *===========================================================================================================*/
75:187:THRAK_API int  thrak_ini_parse_percentage ( char *  value, double *  percentage )
75:188:   {
75:189:	char *		start	=  value,	
75:190:	     *		end 	=  NULL ;
75:191:	double 		percentage_value ;
75:192:	
75:193:	
75:194:	/* Note a quantity : maybe a percentage. Get first part, which should be a positive float */
75:195:	percentage_value 	=  strtod ( start, & end ) ;
75:196:
75:197:	/* Error checking : quantity must start with a float value value */
75:198:	if  ( end  ==  NULL )
75:199:		return ( 0 ) ;
75:200:
75:201:	/* Error checking : percentage must be in the range [0..100] */
75:202:	if  ( percentage_value  <  0   ||  percentage_value  >  100 )
75:203:		return ( 0 ) ;
75:204:		
75:205:	/* Skip spaces after the leading integer */
75:206:	value 	=  end ;
75:207:
75:208:	while  ( * value  &&  isspace ( * value ) )
75:209:		value ++ ;
75:210:		
75:211:	/* If something is after the float value, it must be a percent sign */
75:212:	if  ( * value )
75:213:	   {
75:214:		if (  strcmp ( value, "%" ) )
75:215:			return ( 0 ) ;
75:216:	    }
75:217:	else
75:218:		return ( 0 ) ;
75:219:	    
75:220:	// This is a percentage
75:221:	* percentage 	=  percentage_value ;
75:222:	
75:223:	return ( 1 ) ;
75:224:    }
75:225:    
75:226:    
75:227:/*===========================================================================================================
75:228:
75:229:    NAME
75:230:	thrak_ini_parse_memory_quantity - retrieves a byte quantity or percentage from a .INI value.
75:231:	
75:232:    PROTOTYPE 
75:233:	status 	=  thrak_ini_parse_memory_quantity ( char *  value, thrak_memory_quantity *  quantity ) ;
75:234:	
75:235:    DESCRIPTION
75:236:	Gets a free memory quantity from a .INI setting. This can be expressed as a quantity or percentage.
75:237:	
75:238:    PARAMETERS
75:239:	- value (char *) :
75:240:		.INI file setting whose value is to be retrieved.
75:241:		
75:242:	- quantity (thrak_memory_quantity *) :
75:243:		A structure that will receive the parsed information. It has the following fields :
75:244:		- bytes (long) :
75:245:			Total number of bytes.
75:246:		- quantity (long) :
75:247:			The initial quantity (for example, "1024" when the initial value is "1024mb").
75:248:		- multiplier (long) :
75:249:			The quantity multiplier (1024 for kilobytes, etc.).
75:250:		- multiplier_string (char *) :
75:251:			Noprmalized multiplier string ("Kb" for kilobytes, "Mb" for megabytes, etc.)
75:252:		
75:253:    RETURNS
75:254:	1 if the function succeded, 0 otherwise.
75:255:	
75:256: *===========================================================================================================*/
75:257:THRAK_API int  thrak_ini_parse_memory_quantity ( char *  value, thrak_memory_quantity *  mstruct )
75:258:   {
75:259:	/* Try to recognize a byte quantity first */
75:260:	if  ( thrak_ini_parse_byte_quantity ( value, & mstruct -> quantity ) )
75:261:	   {
75:262:		mstruct -> type 	=  0 ;
75:263:		
75:264:		return ( 1 ) ;
75:265:	    }
75:266:	    
75:267:	/* Then a percentage */
75:268:	if  ( thrak_ini_parse_percentage ( value, & mstruct -> percentage ) )
75:269:	   {
75:270:		mstruct -> type 	=  1 ;
75:271:
75:272:		return ( 1 ) ;
75:273:	    }
75:274:	    
75:275:	return ( 0 ) ;
75:276:    }
75:277:    76:1:/************************************************************************************************************
76:2:
76:3:    NAME
76:4:	memory_helpers.c
76:5:	
76:6:    DESCRIPTION
76:7:	Memory-related functions.
76:8:	
76:9:    AUTHOR
76:10:	Christian Vigh, 11/2014.
76:11:	
76:12:    HISTORY 
76:13:	tbd
76:14:
76:15: ************************************************************************************************************/
76:16:# include 	"thrak.h"
76:17:# include 	<zend_alloc.h>
76:18:
76:19:
76:20:/*===========================================================================================================
76:21:
76:22:    NAME
76:23:	thrak_memory_check_constraint - Checks if new allocation will fit into memory.
76:24:	
76:25:    PROTOTYPE 
76:26:	int 	thrak_memory_check_constraint ( long  memory_requested, 
76:27:						thrak_memory_quantity *  constraint TSRMLS_DC ) ;
76:28:	
76:29:    DESCRIPTION
76:30:	Checks if the requested amount of memory specified by the memory_requested parameter will satisfy the
76:31:	constraints specified by a thrak_memory_quantity structure.
76:32:	A constraint can be :
76:33:	- A minimum quantity of memory to be left after allocation
76:34:	- A minimum percentage of memory to be left
76:35:	
76:36:    PARAMETERS
76:37:	memory_requested (long) -
76:38:		Number of bytes to allocate.
76:39:		
76:40:	constraint (thrak_memory_quantity *) -
76:41:		Constraint on the available quantity of memory that must remain after allocation.
76:42:		
76:43:    RETURNS
76:44:	0 if constraint not satisfied, 1 otherwise.
76:45:	
76:46: *===========================================================================================================*/
76:47:THRAK_API int  	thrak_memory_check_constraint ( long  memory_requested, thrak_memory_quantity *  constraint TSRMLS_DC )
76:48:   {
76:49:	thrak_byte_quantity 		memory_limit ;
76:50:	size_t 				current_memory 		=  zend_memory_usage ( 1 TSRMLS_CC ) ;
76:51:	
76:52:	
76:53:	thrak_ini_parse_byte_quantity ( INI_STR ( "memory_limit" ), & memory_limit ) ;
76:54:	
76:55:	if  ( constraint -> type  ==  0 )
76:56:	   {
76:57:		if  ( memory_limit. bytes - ( current_memory + memory_requested )  >  constraint -> quantity. bytes )
76:58:			return ( 1 ) ;
76:59:		else
76:60:			return ( 0 ) ;
76:61:	    }
76:62:	else
76:63:	   {
76:64:		long 		min_memory_pc 	=  ( long ) ( memory_limit. bytes - ( ( memory_limit. bytes * constraint -> percentage ) / 100 ) ) ;
76:65:		
76:66:		if  ( current_memory + memory_requested  <  min_memory_pc )
76:67:			return ( 1 ) ;
76:68:		else
76:69:			return ( 0 ) ;
76:70:	    }
76:71:    }77:1:/************************************************************************************************************
77:2:
77:3:    NAME
77:4:	minify.c
77:5:	
77:6:    DESCRIPTION
77:7:	Minifying functions.
77:8:	
77:9:    AUTHOR
77:10:	Christian Vigh, 11/2014.
77:11:	
77:12:    HISTORY 
77:13:	tbd
77:14:
77:15: ************************************************************************************************************/
77:16:# include 	"php_vroom.h"
77:17:# include 	"minify.h"
77:18:
77:19:
77:20:/*===========================================================================================================
77:21:
77:22:    NAME
77:23:	minify_initialize - initializes the array_buffer module.
77:24:
77:25: *===========================================================================================================*/
77:26:void 	minify_initialize	( THRAK_INIT_FUNC_ARGS )
77:27:   {
77:28:    }
77:29:
77:30:    
77:31:/*===========================================================================================================
77:32:
77:33:    NAME
77:34:	minify_shutdown
77:35:	
77:36:    DESCRIPTION
77:37:	Sub-extension shutdown function.
77:38:	
77:39: *===========================================================================================================*/
77:40:void 	minify_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
77:41:   {
77:42:    }    
77:43:
77:44:    
77:45:    
77:46:/*===========================================================================================================
77:47:
77:48:    internal_minify_php -
77:49:	Does the actual minifying work.
77:50:	This function has been optimized and is around 300% faster than using php_strip_whitespace(). It is
77:51:	designed for fast easy compression of PHP files before autoload.
77:52:	
77:53: *===========================================================================================================*/
77:54: 
77:55:/* Customized character classification */
77:56:# define  	_SP 		1				/* Space 					*/
77:57:# define 	_VF		2				/* First letter of a variable 			*/
77:58:# define 	_VN		4				/* Next (from second) letter of a variable 	*/
77:59:# define 	_VA		( _VF | _VN )			/* Variable letter 				*/
77:60:
77:61:/* Debug macros */
77:62:# define 	MINIFY_PHP_DEBUG 		0
77:63:
77:64:# if  	MINIFY_PHP_DEBUG
77:65:# 	define 		DBGLINE()		php_printf ( "Current line = %d\n", current_line ) 
77:66:# 	define 		DBGCASE(name)		php_printf ( "Case %s, line %d\n", name, current_line ) 
77:67:# else
77:68:#	define 		DBGLINE()
77:69:#	define 		DBGCASE(name)
77:70:# endif
77:71:
77:72:/* Macros for failures on scanning here documents */
77:73:# define 	NOWHERE_DECLARE()				char * __nowhere_error 	=  "" ;
77:74:# define 	NOWHERE_FAILED(str)				{ __nowhere_error = str ; goto NOWHEREDOC ; }
77:75:# define 	NOWHERE_ERROR 					__nowhere_error 
77:76:
77:77:/* Customized character classification table */
77:78:static char 	internal_minify_php_classification [ 256 ] 	=
77:79:   {
77:80:	  0,   0,   0,   0,   0,   0,   0,   0,   0, _SP, _SP,   0,   0, _SP,   0,   0,		/* 0x00 - 0x0F */
77:81:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0x10 - 0x1F */
77:82:	_SP,   0,   0,   0, _VA,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0x20 - 0x2F */
77:83:	_VN, _VN, _VN, _VN, _VN, _VN, _VN, _VN, _VN, _VN,   0,   0,   0,   0,   0,   0,		/* 0x30 - 0x3F */
77:84:	  0, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA,		/* 0x40 - 0x4F */
77:85:	_VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA,   0,   0,   0,   0, _VA,		/* 0x50 - 0x5F */
77:86:	  0, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA,		/* 0x60 - 0x6F */
77:87:	_VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA, _VA,   0,   0,   0,   0,   0,		/* 0x70 - 0x7F */
77:88:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0x80 - 0x8F */
77:89:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0x90 - 0x9F */
77:90:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0xA0 - 0xAF */
77:91:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0xB0 - 0xBF */
77:92:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0xC0 - 0xCF */
77:93:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0xD0 - 0xDF */
77:94:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,		/* 0xE0 - 0xEF */
77:95:	  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0		/* 0xF0 - 0xFF */
77:96:    } ;
77:97:    
77:98:THRAK_API zend_bool 	internal_minify_php ( char *		filename,
77:99:					      char * 		input_content,
77:100:				              int 		input_content_length,
77:101:				              zend_bool 	preserve_newlines,
77:102:				              char **		output_content,
77:103:				              int *		output_content_length
77:104:				              TSRMLS_DC )
77:105:   {
77:106:	char *			buffer ; 					/* Max size, will be resized before leaving 			*/
77:107:	register char *		p,						/* Pointer to input buffer 					*/
77:108:		      *		p_end,						/* Pointer to the 1st char after the end of input buffer	*/
77:109:		      *		q ;						/* Pointer to output buffer 					*/
77:110:	int  			buffer_size ;					/* Actual output buffer size 					*/
77:111:	int 			current_line 		=  1,			/* Current line 						*/
77:112:				comment_line ;
77:113:	int 			last_token_was_name	=  0 ;			/* True when last token was a name or a variable name 		*/
77:114:	register char 		ch ;
77:115:	char  			delim ;
77:116:	NOWHERE_DECLARE ( ) ;
77:117:
77:118:	
77:119:	/* The right pointers to the right buffers */
77:120:	buffer 	=  input_content ;
77:121:	p 	=  buffer ;
77:122:	p_end 	=  buffer + input_content_length ;
77:123:	q 	=  buffer ;
77:124:		
77:125:	/* Main loop - We don't use ctype functions here because they cost la peau des couilles */
77:126:	while  ( p  <  p_end )
77:127:	   {
77:128:		DBGLINE ( ) ;
77:129:		
77:130:		/* Constructs such as : name$name2$name3 can cause buffer overflows because '$' signals the start of a new variable, which in 	*/
77:131:		/* this case follows a token and therefore needs a space to be inserted between both. 						*/
77:132:		if  ( ( int ) ( q - buffer )  >  input_content_length ) 
77:133:		   {
77:134:			php_error_docref ( NULL TSRMLS_CC, E_ERROR, "Unexpected buffer overflow with file %s",  filename ) ;
77:135:			return ( 0 ) ;
77:136:		    }
77:137:		    
77:138:		ch 			= * p ;
77:139:		
77:140:		/* Ignore spaces */
77:141:		if  ( internal_minify_php_classification [ ch ]  &  _SP ) 
77:142:		   {
77:143:			DBGCASE ( "Space" ) ;
77:144:			
77:145:			do
77:146:			   {
77:147:				if  ( * p  ==  '\n' )
77:148:				   {
77:149:					if  (  preserve_newlines )		// Still count newlines
77:150:						* q ++ 	=  '\n' ;
77:151:						
77:152:					current_line ++ ;
77:153:				    }
77:154:				    
77:155:				p ++ ;
77:156:			    }
77:157:			while ( p  <  p_end  &&  ( internal_minify_php_classification [ * p ]  &  _SP ) ) ;
77:158:		    }
77:159:		/* Variable or token name */
77:160:		else if  ( internal_minify_php_classification [ ch ]  &  _VA )
77:161:		   {
77:162:			DBGCASE ( "Token" ) ;
77:163:			
77:164:			/* Add a space if last token was a name */
77:165:			if  ( last_token_was_name )
77:166:				* q ++ = ' ' ;
77:167:				
77:168:			last_token_was_name	=  1 ;
77:169:			* q ++ 			=  ch ;
77:170:			p ++ ;
77:171:			
77:172:			/* Collect additional token/variable characters */
77:173:			while  ( p  <  p_end  &&  ( internal_minify_php_classification [ * p ]  &  _VN ) )
77:174:				* q ++ 	=  * p ++ ;
77:175:		    }
77:176:		/* Other stuff, such as operators, numbers, etc. */
77:177:		else if  ( ch  !=  '/'  &&  ch  !=  '"'  &&  ch  !=  '\''  &&  ch  !=  '<' )
77:178:		   {
77:179:			DBGCASE ( "Special char" ) ;
77:180:			last_token_was_name  	=  0 ;
77:181:			* q ++ 			=  ch ;
77:182:			p ++ ;
77:183:		    }
77:184:		/* Comment */
77:185:		else if  ( ch  ==  '/' )
77:186:		   {
77:187:			DBGCASE ( "Comment" ) ;
77:188:			p ++ ;
77:189:			
77:190:			if  ( p  <  p_end )
77:191:			   {
77:192:				/* C-style comment */
77:193:				if  ( * p  ==  '*' )
77:194:				   {
77:195:					comment_line 	=  current_line ;
77:196:					p ++ ;
77:197:					
77:198:					while  ( p + 1  <  p_end  &&  ( * p  !=  '*'  ||  * ( p + 1 )  !=  '/' ) )
77:199:					   {
77:200:						if  ( * p  ==  '\n' )
77:201:						   {
77:202:							if  ( preserve_newlines )
77:203:								* q ++ 	=  '\n' ;
77:204:								
77:205:							current_line ++ ;
77:206:						    }
77:207:							
77:208:						p ++ ;
77:209:					    }
77:210:						
77:211:					p  +=  2 ;
77:212:
77:213:					if  ( p  >=  p_end )
77:214:					   {
77:215:						php_error_docref ( NULL TSRMLS_CC, E_ERROR, "EOF inside a comment at line %d of file %s", 
77:216:									comment_line, filename ) ;
77:217:						return ( 0 ) ;
77:218:					    }
77:219:				    }
77:220:				/* C++-style comment */
77:221:				else if  ( * p  ==  '/' )
77:222:				   {
77:223:					p ++ ;
77:224:					
77:225:					while  ( p  <  p_end  &&  * p  !=  '\n' )
77:226:						p ++ ;
77:227:				    }
77:228:				/* No comment at all - simply write back the '/' character */
77:229:				else
77:230:				   {
77:231:					* q ++ 	=  '/' ;
77:232:					last_token_was_name 	=  0 ;
77:233:				    }
77:234:			    }
77:235:			/* Super special case where '/' is the last character of the file... */
77:236:			else
77:237:			   {
77:238:				* q ++ 			=  '/' ;
77:239:				last_token_was_name 	=  0 ;
77:240:			    }
77:241:		    }
77:242:		/* Quoted string */
77:243:		else if  ( ch  ==  '"'  ||  ch  ==  '\'' )
77:244:		   {
77:245:			DBGCASE ( "String" ) ;
77:246:			
77:247:			p ++ ;
77:248:			last_token_was_name 	=  0 ;	
77:249:			comment_line 		=  current_line ;
77:250:			delim	=  * q ++ 	=  ch ;
77:251:			
77:252:			while  ( p  <  p_end  &&  * p  !=  delim )
77:253:			   {
77:254:				if  ( * p  ==  '\n' )
77:255:				   {
77:256:					if (  preserve_newlines )
77:257:						* q ++ 	=  '\n' ;
77:258:						
77:259:					current_line ++ ;
77:260:				    }
77:261:					
77:262:				if  ( * p  ==  '\\' )
77:263:					* q ++ = * p ++  ;
77:264:					
77:265:				if  ( p  ==  p_end )
77:266:					break ;
77:267:					
77:268:				* q ++  =  * p ++ ;
77:269:			    }
77:270:			    
77:271:			if  ( p  ==  p_end )
77:272:			   {
77:273:				php_error_docref ( NULL TSRMLS_CC, E_ERROR, "EOF inside a string at line %d of file %s", 
77:274:							comment_line, filename ) ;
77:275:				return ( 0 ) ;
77:276:			    }
77:277:			    
77:278:			* q ++ 	=  * p ++ ;
77:279:		    }
77:280:		/* Check for HERE documents */
77:281:		else if  ( ch  ==  '<' )
77:282:		   {
77:283:			/*** 
77:284:				We need at least 4 remaining characters :
77:285:				- Two '<' signs
77:286:				- One character for the heredoc/nowdoc delimiting identifier
77:287:				- A newline
77:288:				Well, we could need much more than that...
77:289:			 ***/
77:290:			if  ( p + 3   <   p_end  &&  * ( p + 1 )  ==  '<'  &&  * ( p + 2 )  ==  '<' )
77:291:			   {
77:292:				char *		forward_p 	=  p + 3 ;
77:293:				char * 		here_start ;
77:294:				char * 		here_stop ;
77:295:				char 		terminator 	=  0 ;
77:296:				
77:297:				DBGCASE ( "HEREDOC" ) ;
77:298:				comment_line 	=  current_line ;
77:299:
77:300:				/* Skip spaces after the '<<<' construct */
77:301:				while  ( forward_p  <  p_end  &&  ( internal_minify_php_classification [ * forward_p ]  &  _SP ) )
77:302:					forward_p ++ ;
77:303:					
77:304:				if  ( forward_p  ==  p_end )
77:305:					NOWHERE_FAILED ( "EOF after the '<<<' construct" ) ;
77:306:					
77:307:				/* The heredoc may be surrounded by doublequotes (HEREDOC) or single quotes (NOWDOC) */
77:308:				if  ( * forward_p  ==  '"'  ||  * forward_p  ==  '\'' )
77:309:				   {
77:310:					terminator 	=  * forward_p ++ ;
77:311:					
77:312:					if  ( forward_p  ==  p_end )
77:313:						NOWHERE_FAILED ( "EOF after opening quote" ) ;
77:314:				    }
77:315:				    
77:316:				/* Now whe have to scan for the HEREDOC identifier, which must be a valid PHP token */
77:317:				if  ( internal_minify_php_classification [ * forward_p ]  &  _VF )
77:318:				   {
77:319:					char * 		here_string ;
77:320:					char *		end_string ;
77:321:					int  		size ;
77:322:					
77:323:					here_start	=  forward_p ++ ;
77:324:					
77:325:					while  ( forward_p  <  p_end  &&  internal_minify_php_classification [ * forward_p ]  & _VA )
77:326:						forward_p ++ ;
77:327:					
77:328:					if  ( forward_p  ==  p_end )
77:329:						NOWHERE_FAILED ( "EOF after HEREDOC identifier" ) ;
77:330:						
77:331:					here_stop 	=  forward_p ;
77:332:					
77:333:					/* We may have a trailing quote/double quote to process */
77:334:					if  ( terminator )
77:335:					   {
77:336:						/* Bad luck : HEREDOC identifier is at end of file or does not end with the starting delimiter... */
77:337:						if  ( forward_p  ==  p_end  ||  * forward_p  !=  terminator )
77:338:							NOWHERE_FAILED ( "no closing quote" ) ;
77:339:							
77:340:						forward_p ++ ;
77:341:					    }
77:342:					    
77:343:					/* Now we should have a newline after the HEREDOC identifier */
77:344:					if (  forward_p  <  p_end  &&  * forward_p  ==  '\r' )		/* Don't forget Dos-style line endings : ignore them */
77:345:						forward_p ++ ;
77:346:						
77:347:					if  ( forward_p  ==  p_end  ||  * forward_p  !=  '\n' )
77:348:						NOWHERE_FAILED ( "EOF after HEREDOC identifier" ) ;
77:349:					
77:350:					forward_p ++ ;
77:351:					
77:352:					if  ( forward_p  ==  p_end )
77:353:						NOWHERE_FAILED ( "EOF after HEREDOC start newline" ) ;
77:354:						
77:355:					/* Allocate space for the heredoc identifier ; we will search for identifier followed by a semicolon */
77:356:					size 		=  ( int ) ( here_stop - here_start ) ;
77:357:					here_string	=  emalloc ( size + 3 ) ;
77:358:					
77:359:					if  ( here_string  ==  NULL )
77:360:						NOWHERE_FAILED ( "memory allocation failed" ) ;
77:361:						
77:362:					memcpy ( here_string, here_start, size ) ;
77:363:					here_string [ size ]		=  ';' ;
77:364:					here_string [ size + 1 ]	=  0 ;
77:365:					
77:366:					/* Ok, let's search for the HEREDOC ending string */
77:367:					end_string 	=  strstr ( forward_p, here_string ) ;
77:368:					
77:369:					if  ( end_string  ==  NULL )
77:370:					   {
77:371:						efree ( here_string ) ;
77:372:						NOWHERE_FAILED ( "ending identifier not found" ) ;
77:373:					    }
77:374:					    
77:375:					/* Point to the character after the ending identifier */
77:376:					forward_p 	=  end_string + size + 1 ;
77:377:					
77:378:					/* Ignore Dos-style line endings */
77:379:					if  ( forward_p  <  p_end  &&  * forward_p  ==  '\r' )
77:380:						forward_p ++ ;
77:381:						
77:382:					/* We should have a newline after the ending identifier */
77:383:					if  ( forward_p  ==  p_end  ||  * forward_p  !=  '\n' )
77:384:						NOWHERE_FAILED ( "missing newline after ending HEREDOC identifier" ) ;
77:385:						
77:386:					current_line ++ ;
77:387:						
77:388:					/* End identifier found ; point to the character after it */
77:389:					size 		 =  size + 1 + ( int ) ( end_string - p ) ;
77:390:					
77:391:					/* And copy the whole stuff, from the initial '<<<' construct to the end of the ending identifier */
77:392:					while  ( size -- )
77:393:					   {
77:394:						switch  ( * p )
77:395:						   {
77:396:							case 	'\r' :  break ;
77:397:							case 	'\n' :  current_line ++ ;
77:398:							default :
77:399:								* q ++ 	=  * p ;
77:400:						    }
77:401:						    
77:402:						p ++ ;
77:403:					    }
77:404:					
77:405:					/* Don't forget the trailing newline after the HEREDOC ending identifier */
77:406:					if  ( * p  ==  '\r' )
77:407:						p ++ ;
77:408:						
77:409:					* q ++	=  '\n' ;
77:410:					p ++ ;
77:411:					
77:412:					efree ( here_string ) ;
77:413:				    }
77:414:				else
77:415:					NOWHERE_FAILED ( "invalid HEREDOC identifier character" )  ;
77:416:			    }
77:417:			else
77:418:			   {
77:419:				DBGCASE ( "Special char 2" ) ;
77:420:				* q ++ 	=  * p ++ ;
77:421:			    }
77:422:		    }
77:423:	    }
77:424:
77:425:	/* All done, return success */
77:426:	buffer_size 		=  ( int ) ( q - buffer ) ;
77:427:	* output_content 	=  buffer ;
77:428:	* output_content_length =  buffer_size ;
77:429:	
77:430:	return ( 1 ) ;
77:431:
77:432:	/* All "here document" parsing errors arrive here */
77:433:NOWHEREDOC :
77:434:	php_error_docref ( NULL TSRMLS_CC, E_ERROR, "Bad HEREDOC construct (reason : %s), at line %d of file %s", 
77:435:				NOWHERE_ERROR, comment_line, filename ) ;
77:436:	return ( 0 ) ;
77:437:    }
77:438:    
77:439:    
77:440:/*===========================================================================================================
77:441:
77:442:    NAME
77:443:	minify_php - Minifies a PHP file.
77:444:	
77:445:    PROTOTYPE 
77:446:	$string 	=  minify_php 		( $file [, $preserve_newlines = false ] ) ;
77:447:	$string 	=  minify_php_stream 	( $file [, $preserve_newlines = false 
77:448:							[, $use_include_path = false ] ] ) ;
77:449:	$string 	=  minify_php_string    ( $string [, $preserve_newlines = false ] ) ;
77:450:	
77:451:    DESCRIPTION
77:452:	Returns the minified contents of the specified PHP source file.
77:453:	minify_php_stream() behaves as file_get_contents() for opening files (thus, an http url could be 
77:454:	provided). There is a really low overhead compared to minify_php (around 2% on Windows).
77:455:	
77:456:    PARAMETERS 
77:457:	$file (string) -
77:458:		PHP source file to be minified.
77:459:		
77:460:	$preserve_newlines (boolean) -
77:461:		When true, line endings are preserved except for empty lines. When false, file contents are
77:462:		returned as a single line. 
77:463:		This is useful for debugging because errors will reflect the line in the original source
77:464:		file.
77:465:	
77:466:	$use_include_path (boolean) -
77:467:		See file_get_contents().
77:468:	
77:469:    RETURNS
77:470:	The minified contents of the specified PHP source file, or false if an error occurred.
77:471:	
77:472: *===========================================================================================================*/
77:473:PHP_FUNCTION ( minify_php_string )
77:474:   {
77:475:	char *			input_content ;						/* String contents & length			*/
77:476:	int 			input_content_length ;
77:477:	char *			minified_content ;					/* Output from internal_minify_php :		*/
77:478:	int 			minified_content_length ;				/* Contents and contents length 		*/
77:479:	zend_bool 		preserve_newlines 		=  0 ;			/* Whether to preserve newlines or not 		*/
77:480:	
77:481:	/* Parse arguments */
77:482:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "s|b", & input_content, & input_content_length, & preserve_newlines )  ==  FAILURE )
77:483:		return ;
77:484:
77:485:	/* Duplicate string */
77:486:	input_content 	=  estrndup ( input_content, input_content_length ) ;
77:487:	
77:488:	if  ( input_content  ==  NULL )
77:489:		RETURN_FALSE ;
77:490:		
77:491:	/* Abort if minifying error */
77:492:	if  ( internal_minify_php ( "(string)", input_content, input_content_length, preserve_newlines, & minified_content, & minified_content_length TSRMLS_CC ) )
77:493:	   {
77:494:		if  ( minified_content_length  <  input_content_length )
77:495:		   {
77:496:			minified_content 	=  erealloc ( minified_content, minified_content_length ) ;
77:497:			
77:498:			if  ( minified_content  ==  NULL )
77:499:				RETURN_FALSE ;
77:500:		    }
77:501:		    
77:502:		RETVAL_STRINGL ( minified_content, minified_content_length, 0 ) ;
77:503:	    }
77:504:	else
77:505:	   {
77:506:		efree ( input_content ) ;
77:507:		RETVAL_FALSE ;
77:508:	    }
77:509:    }
77:510:
77:511:    
77:512:PHP_FUNCTION ( minify_php )
77:513:   {
77:514:	char *			filename ;						/* Input filename 				*/
77:515:	int  			filename_length ;					/* Input filename length 			*/
77:516:	zend_bool 		preserve_newlines 		=  0 ;			/* Whether to preserve newlines or not 		*/
77:517:	char *			minified_content ;					/* Output from internal_minify_php :		*/
77:518:	int 			minified_content_length ;				/* Contents and contents length 		*/
77:519:	FILE *			fp ;							/* File pointer for input filename 		*/
77:520:	struct stat 		stat ;							/* Stat struct to retrieve its size 		*/
77:521:	char *			input_content ;						/* File contents & length			*/
77:522:	int 			input_content_length ;
77:523:	
77:524:	/* Parse arguments */
77:525:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "s|b", & filename, & filename_length, & preserve_newlines )  ==  FAILURE )
77:526:		return ;
77:527:
77:528:	/* Check that the supplied filename is not empty */
77:529: 	if  ( filename_length  ==  0 ) 
77:530:	   {
77:531:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Empty string specified as filename" ) ;
77:532:		RETURN_FALSE ;
77:533:	    }
77:534:	    
77:535:	/* Open the file */
77:536:	if  ( ( fp = fopen ( filename, "r" ) )  ==  NULL )
77:537:	   {
77:538:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Can't open file %s for reading", filename ) ;
77:539:		RETURN_FALSE ;
77:540:	    }
77:541:	    
77:542:	/* Get file size */
77:543:	if  ( fstat ( fileno ( fp ), & stat )  ==  -1 )
77:544:	   {
77:545:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Can't stat() file %s ", filename ) ;
77:546:		fclose ( fp ) ;
77:547:		RETURN_FALSE ;
77:548:	    }
77:549:	
77:550:	/* Allocate enough memory to read the file */
77:551:	input_content_length	=  stat. st_size ;
77:552:	input_content 		=  emalloc ( input_content_length + 128 ) ;
77:553:	
77:554:	if  ( input_content  ==  NULL )
77:555:	   {
77:556:		fclose ( fp ) ;
77:557:		RETURN_FALSE ;
77:558:	    }
77:559:	
77:560:	/* Read file contents */
77:561:	if  (  ! fread ( input_content, input_content_length, 1, fp ) )
77:562:	   {
77:563:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Failed to read contents of file %s ", filename ) ;
77:564:		fclose ( fp ) ;
77:565:		RETURN_FALSE ;
77:566:	    }
77:567:	
77:568:	/* All done, close the input file */
77:569:	fclose ( fp ) ;
77:570:	
77:571:	/* Abort if minifying error */
77:572:	if  ( internal_minify_php ( filename, input_content, input_content_length, preserve_newlines, & minified_content, & minified_content_length TSRMLS_CC ) )
77:573:	   {
77:574:		if  ( minified_content_length  <  input_content_length )
77:575:		   {
77:576:			minified_content 	=  erealloc ( minified_content, minified_content_length ) ;
77:577:			
77:578:			if  ( minified_content  ==  NULL )
77:579:				RETURN_FALSE ;
77:580:		    }
77:581:		    
77:582:		RETVAL_STRINGL ( minified_content, minified_content_length, 0 ) ;
77:583:	    }
77:584:	else
77:585:		RETVAL_FALSE ;
77:586:    }
77:587:    
77:588:    
77:589:PHP_FUNCTION ( minify_php_stream )
77:590:   {
77:591:	char *			filename ;						/* Input filename 				*/
77:592:	int  			filename_length ;					/* Input filename length 			*/
77:593:	zend_bool 		preserve_newlines 		=  1;			/* Whether to preserve newlines or not 		*/
77:594:	zend_bool 		use_include_path 		=  0 ;			/* Whether to use include path or not 		*/
77:595:	
77:596:	char 			resolved_path [ MAXPATHLEN + 1 ] ;			/* Expanded path 				*/
77:597:	php_stream *		stream ;						/* Input file stream 				*/
77:598:	char *			input_content ;						/* Input contents 				*/
77:599:	int 			input_content_length ;					/* Input contents length 			*/
77:600:	char *			minified_content ;					/* Output from internal_minify_php :		*/
77:601:	int 			minified_content_length ;				/* contents and contents length 		*/
77:602:	
77:603:	/* Parse arguments */
77:604:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "s|bb", & filename, & filename_length, & preserve_newlines, & use_include_path )  ==  FAILURE )
77:605:		return ;
77:606:
77:607:	/* Check that the supplied filename is not empty */
77:608: 	if  ( filename_length  ==  0 ) 
77:609:	   {
77:610:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Empty string specified as filename" ) ;
77:611:		RETURN_FALSE ;
77:612:	    }
77:613:	    
77:614:	/* Expand it ; update filename length if necessary */
77:615: 	if  ( ! expand_filepath ( filename, resolved_path TSRMLS_CC ) ) 
77:616:	   {
77:617:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Path expansion failed for file %s", filename ) ;
77:618:		RETURN_FALSE ;
77:619:	    }
77:620:	else
77:621:		filename_length 	=  ( long ) strlen ( resolved_path ) ;
77:622:		
77:623:	/* Open the file */
77:624:	stream 		=  php_stream_open_wrapper_ex ( resolved_path, "rb",
77:625:					( ( use_include_path ) ?  USE_PATH : 0 ) | REPORT_ERRORS,
77:626:					NULL, NULL ) ;
77:627:					
77:628:	if  ( ! stream ) 	/* Well, not really opened... */
77:629:	   {
77:630:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "Unable to open file %s", filename ) ;
77:631:		RETURN_FALSE ;
77:632:	    }
77:633:
77:634:	/* Read file data */
77:635:	if  ( ( input_content_length = ( long ) php_stream_copy_to_mem ( stream, & input_content, PHP_STREAM_COPY_ALL, 0 ) )  <  0 ) 
77:636:		RETURN_FALSE ;
77:637:		
77:638:	/* Data have been read, close the stream here since we are subject to encounter potential errors after that */
77:639:	php_stream_close ( stream ) ;
77:640:	
77:641:	/* Not very interesting on 32-bits flavors, but I got it from file_get_contents() */
77:642:	if  ( input_content_length  >  INT_MAX ) 
77:643:	   {
77:644:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "content truncated from %ld to %d bytes", input_content_length, INT_MAX ) ;
77:645:		input_content_length 	=  INT_MAX ;
77:646:	    }
77:647:	    
77:648:	/* Empty input file */
77:649:	if  ( ! input_content_length )
77:650:	   {
77:651:		php_error_docref ( NULL TSRMLS_CC, E_WARNING, "empty file" ) ;
77:652:		
77:653:		if  ( input_content )
77:654:			efree ( input_content ) ;
77:655:			
77:656:		RETURN_FALSE ;
77:657:	    }
77:658:	
77:659:	/* Abort if minifying error */
77:660:	/* Abort if minifying error */
77:661:	if  ( internal_minify_php ( filename, input_content, input_content_length, preserve_newlines, & minified_content, & minified_content_length TSRMLS_CC ) )
77:662:	   {
77:663:		if  ( minified_content_length  <  input_content_length )
77:664:		   {
77:665:			minified_content 	=  erealloc ( minified_content, minified_content_length ) ;
77:666:			
77:667:			if  ( minified_content  ==  NULL )
77:668:				RETURN_FALSE ;
77:669:		    }
77:670:		    
77:671:		RETVAL_STRINGL ( minified_content, minified_content_length, 0 ) ;
77:672:	    }
77:673:	else
77:674:		RETVAL_FALSE ;
77:675:    }    78:1:/************************************************************************************************************
78:2:
78:3:    NAME
78:4:	array.h
78:5:	
78:6:    DESCRIPTION
78:7:	Definitions for buffered arrays.
78:8:	
78:9:    AUTHOR
78:10:	Christian Vigh, 10/2014.
78:11:	
78:12:    HISTORY 
78:13:	tbd
78:14:
78:15: ************************************************************************************************************/
78:16:# ifndef 	__MINIFY_H__
78:17:# 	define	__MINIFY_H__
78:18:
78:19:language_block ( C ) ;
78:20:
78:21:/*-----------------------------------------------------------------------------------------------------------
78:22:
78:23:	External array functions.
78:24:	
78:25: *-----------------------------------------------------------------------------------------------------------*/
78:26:extern 				PHP_FUNCTION ( minify_php ) ; 
78:27:extern 				PHP_FUNCTION ( minify_php_stream ) ; 
78:28:extern 				PHP_FUNCTION ( minify_php_string ) ; 
78:29:
78:30:extern THRAK_API zend_bool 	internal_minify_php 			( char * 		filename,
78:31:									  char *		input_content,
78:32:									  int 			input_content_length,
78:33:									  zend_bool 		preserve_newlines,
78:34:									  char **		output_content,
78:35:									  int * 		output_content_length 
78:36:									  TSRMLS_DC ) ;
78:37: 
78:38:extern void 			minify_initialize			( THRAK_INIT_FUNC_ARGS ) ;
78:39:extern void 			minify_shutdown				( THRAK_SHUTDOWN_FUNC_ARGS ) ;
78:40:
78:41:end_language_block ( C ) ;
78:42:
78:43:# endif		/* __MINIFY_H__  */79:1:/************************************************************************************************************
79:2:
79:3:    NAME
79:4:	minify_statics.h
79:5:	
79:6:    DESCRIPTION
79:7:	Variables that must be initialized only once.
79:8:	
79:9:    AUTHOR
79:10:	Christian Vigh, 11/2014.
79:11:	
79:12:    HISTORY 
79:13:	tbd
79:14:
79:15: ************************************************************************************************************/
79:16:# ifndef 	__MINIFY_STATICS_H__
79:17:# 	define	__MINIFY_STATICS_H__
79:18:
79:19:language_block ( C ) ;
79:20:
79:21:/*-----------------------------------------------------------------------------------------------------------
79:22:
79:23:	Function arguments type information for minify.c.
79:24:	
79:25: *-----------------------------------------------------------------------------------------------------------*/
79:26:/* minify_php() */
79:27:THRAK_BEGIN_ARG_INFO ( minify_php, 0, 0, 1 )
79:28:	THRAK_ARG_INFO ( 0, file )
79:29:	THRAK_ARG_INFO ( 0, preserve_newlines )
79:30:THRAK_END_ARG_INFO ;
79:31:
79:32:/* minify_php_string() */
79:33:THRAK_BEGIN_ARG_INFO ( minify_php_string, 0, 0, 1 )
79:34:	THRAK_ARG_INFO ( 0, string )
79:35:	THRAK_ARG_INFO ( 0, preserve_newlines )
79:36:THRAK_END_ARG_INFO ;
79:37:
79:38:/* minify_php_stream() */
79:39:THRAK_BEGIN_ARG_INFO ( minify_php_stream, 0, 0, 1 )
79:40:	THRAK_ARG_INFO ( 0, file )
79:41:	THRAK_ARG_INFO ( 0, preserve_newlines )
79:42:	THRAK_ARG_INFO ( 0, use_include_path )
79:43:THRAK_END_ARG_INFO ;
79:44:
79:45:# endif 	/* __MINIFY_STATICS_H__ */80:1:/************************************************************************************************************
80:2:
80:3:    NAME
80:4:	vroom.c
80:5:	
80:6:    DESCRIPTION
80:7:	Vroom extension.
80:8:	
80:9:    AUTHOR
80:10:	Christian Vigh, 10/2014.
80:11:	
80:12:    HISTORY 
80:13:	tbd
80:14:
80:15: ************************************************************************************************************/
80:16:# ifdef 	HAVE_CONFIG_H
80:17:# 	include 	"config.h"
80:18:# endif
80:19:
80:20:# include 	"php_vroom.h"
80:21:# include	"array.h"
80:22:# include 	"data.h"
80:23:# include 	"minify.h"
80:24:# include 	"string.h"
80:25:# include 	"timer.h"
80:26:# include 	"zval.h"
80:27:
80:28:# include 	"array_statics.h"
80:29:# include 	"data_statics.h"
80:30:# include 	"minify_statics.h"
80:31:# include 	"string_statics.h"
80:32:# include 	"timer_statics.h"
80:33:# include	"zval_statics.h"
80:34:
80:35:
80:36:/*** 
80:37:	Module function table.
80:38: 
80:39:	{{{ vroom_functions[]
80:40: ***/
80:41:THRAK_BEGIN_FUNCTION_TABLE(vroom)
80:42:	/* array.c */
80:43:	THRAK_FE 	( array_flatten )
80:44:	THRAK_FE 	( array_ikey_exists )
80:45:	THRAK_FE	( iin_array )
80:46:	
80:47:   	/* array_buffer.c */
80:48:	THRAK_FE  	( array_buffer_clone )
80:49:	THRAK_FE  	( array_buffer_copy )
80:50:	THRAK_FE  	( array_buffer_create )
80:51:	THRAK_FE  	( array_buffer_destroy )
80:52:	THRAK_FE  	( array_buffer_resize )
80:53:	THRAK_FE  	( array_buffer_set )
80:54:	THRAK_FE  	( array_buffer_size )
80:55:    
80:56:	/* data.c */
80:57:	THRAK_FE  	( data_pack )
80:58:	THRAK_FE  	( data_unpack )
80:59:	
80:60:	THRAK_FEA  	( data_dwpack		, data_dxpack_arginfo )
80:61:	THRAK_FEA  	( data_dwlpack		, data_dxxpack_arginfo )
80:62:	THRAK_FEA  	( data_dwbpack		, data_dxxpack_arginfo )
80:63:	THRAK_FEA 	( data_dwmpack		, data_dxxpack_arginfo )
80:64:	
80:65:	THRAK_FEA  	( data_ddpack		, data_dxpack_arginfo )
80:66:	THRAK_FEA  	( data_ddlpack		, data_dxxpack_arginfo )
80:67:	THRAK_FEA  	( data_ddbpack		, data_dxxpack_arginfo )
80:68:	THRAK_FEA 	( data_ddmpack		, data_dxxpack_arginfo )
80:69:	
80:70:	THRAK_FEA  	( data_dqpack		, data_dxpack_arginfo )
80:71:	THRAK_FEA  	( data_dqlpack		, data_dxxpack_arginfo )
80:72:	THRAK_FEA  	( data_dqbpack		, data_dxxpack_arginfo )
80:73:	THRAK_FEA 	( data_dqmpack		, data_dxxpack_arginfo )
80:74:	
80:75:	THRAK_FEA  	( data_dwunpack		, data_dxunpack_arginfo )
80:76:	THRAK_FEA  	( data_dwlunpack	, data_dxxunpack_arginfo )
80:77:	THRAK_FEA  	( data_dwbunpack	, data_dxxunpack_arginfo )
80:78:	THRAK_FEA 	( data_dwmunpack	, data_dxxunpack_arginfo )
80:79:		
80:80:	THRAK_FEA  	( data_ddunpack		, data_dxunpack_arginfo )
80:81:	THRAK_FEA  	( data_ddlunpack	, data_dxxunpack_arginfo )
80:82:	THRAK_FEA  	( data_ddbunpack	, data_dxxunpack_arginfo )
80:83:	THRAK_FEA 	( data_ddmunpack	, data_dxxunpack_arginfo )
80:84:
80:85:	/* minify.c */
80:86:	THRAK_FE 	( minify_php )
80:87:	THRAK_FE 	( minify_php_stream )
80:88:	THRAK_FE 	( minify_php_string )
80:89:	
80:90:	/* string.c */
80:91:	THRAK_FE  	( string_append )
80:92:	THRAK_FE 	( string_atoi )
80:93:	THRAK_FE 	( string_explode )
80:94:	THRAK_FE 	( string_setbos )
80:95:	THRAK_FE  	( string_endswith )
80:96:	THRAK_FE 	( string_implode )
80:97:	THRAK_FE 	( string_seteos )
80:98:	THRAK_FE  	( string_startswith )
80:99:	
80:100:	/* timer.c */
80:101:	THRAK_FE 	( timer_clock )
80:102:	THRAK_FE 	( timer_ticks_to )
80:103:	THRAK_FE 	( timer_ticks_to_seconds )
80:104:	THRAK_FE 	( timer_ticks_to_milliseconds )
80:105:	THRAK_FE 	( timer_ticks_to_microseconds )
80:106:	THRAK_FE 	( timer_ticks_to_nanoseconds )
80:107:	THRAK_FE 	( timer_diff ) 
80:108:	THRAK_FE 	( timer_clock_delta )
80:109:	
80:110:	/* zval.c */
80:111:	THRAK_FE 	( zval_decref )
80:112:	THRAK_FE 	( zval_dump )
80:113:	THRAK_FE 	( zval_incref )
80:114:	THRAK_FE 	( zval_isref )
80:115:	THRAK_FE 	( zval_refcount )
80:116:	THRAK_FE 	( zval_setref )
80:117:	THRAK_FE 	( zval_swap )
80:118:	THRAK_FE 	( zval_type )
80:119:	THRAK_FE 	( zval_type_constant )
80:120:THRAK_END_FUNCTION_TABLE ;
80:121:/* }}} */
80:122:
80:123:
80:124:/***
80:125:	Module initialization structure.
80:126:	
80:127: 	{{{ vroom_module_entry
80:128: ***/
80:129:THRAK_BEGIN_MODULE ( vroom )
80:130:	STANDARD_MODULE_HEADER,
80:131:	PHP_VROOM_EXTENSION_NAME,
80:132:	vroom_functions,
80:133:	PHP_MINIT			(vroom),	/* Module initialization 		*/
80:134:	PHP_MSHUTDOWN			(vroom),	/* Module termination			*/
80:135:	PHP_RINIT			(vroom),	/* Request initialization 		*/
80:136:	PHP_RSHUTDOWN			(vroom),	/* Request termination			*/
80:137:	PHP_MINFO			(vroom),
80:138:	PHP_VROOM_VERSION,
80:139:	STANDARD_MODULE_PROPERTIES
80:140:THRAK_END_MODULE ;
80:141:/* }}} */
80:142:
80:143:
80:144:/***
80:145:	INI settings.
80:146: ***/
80:147:PHP_INI_BEGIN ( )
80:148:	PHP_INI_ENTRY ( ARRAY_BUFFER_MAX_SIZE_SETTING		, DEFAULT_ARRAY_BUFFER_MAX_SIZE		, PHP_INI_SYSTEM, NULL )
80:149:	PHP_INI_ENTRY ( ARRAY_BUFFER_MIN_FREE_MEMORY_SETTING	, DEFAULT_ARRAY_BUFFER_MIN_FREE_MEMORY	, PHP_INI_SYSTEM, NULL )
80:150:PHP_INI_END ( ) ;
80:151:
80:152:
80:153:/***
80:154:	Needed for shared libraries.
80:155: ***/
80:156:# ifdef 	COMPILE_DL_VROOM
80:157:THRAK_GET_MODULE_FUNCTION ( vroom )
80:158:   {
80:159:	
80:160:	THRAK_RETURN_MODULE_ENTRY ( vroom ) ;
80:161:    }
80:162:# else
80:163:#	error  This extension must be compiled as a shared 
80:164:# endif
80:165:
80:166:
80:167:/***
80:168:	Module initialization function.
80:169:	
80:170:	{{{ PHP_MINIT_FUNCTION
80:171: ***/
80:172:PHP_MINIT_FUNCTION ( vroom )
80:173:   {
80:174:	REGISTER_INI_ENTRIES ( ) ;
80:175:	
80:176:	thrak_initialize	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:177:	vroom_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:178:	
80:179:	array_initialize	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:180:	array_buffer_initialize	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:181:	data_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:182:	minify_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:183:	string_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:184:	timer_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:185:	zval_initialize 	( THRAK_INIT_FUNC_ARGS_PASSTHRU ) ;
80:186:	
80:187:	return ( SUCCESS ) ;
80:188:    }
80:189:/* }}} */
80:190:
80:191:
80:192:/***
80:193:	Module termination function.
80:194:	
80:195:	{{{ PHP_MSHUTDOWN_FUNCTION
80:196: ***/
80:197:PHP_MSHUTDOWN_FUNCTION ( vroom )
80:198:   {
80:199:	zval_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:200:	timer_shutdown	 	( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:201:	string_shutdown 	( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:202:	minify_initialize 	( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:203:	data_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:204:	array_buffer_shutdown 	( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:205:	array_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:206:	vroom_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:207:	thrak_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU ) ;
80:208:	
80:209:	UNREGISTER_INI_ENTRIES ( ) ;
80:210:	
80:211:	return ( SUCCESS ) ;
80:212:    }
80:213:/* }}} */
80:214:
80:215:
80:216:/***
80:217:	Module per-request initialization function.
80:218:	
80:219:	{{{ PHP_RINIT_FUNCTION
80:220: ***/
80:221:PHP_RINIT_FUNCTION ( vroom )
80:222:   {
80:223:	return ( SUCCESS ) ;
80:224:    }
80:225:/* }}} */
80:226:
80:227:
80:228:/***
80:229:	Module per-request shutdown function.
80:230:	
80:231:	{{{ PHP_RSHUTDOWN_FUNCTION
80:232: ***/
80:233:PHP_RSHUTDOWN_FUNCTION ( vroom )
80:234:   {
80:235:	return ( SUCCESS ) ;
80:236:    }
80:237:/* }}} */
80:238:
80:239:
80:240:
80:241:/***
80:242:	Module information function.
80:243:	
80:244:	{{{ PHP_MINFO_FUNCTION
80:245: ***/
80:246:PHP_MINFO_FUNCTION ( vroom )
80:247:   {
80:248:	php_info_print_table_start 	( ) ;
80:249:	php_info_print_table_header 	( 2, "vroom support"	, "enabled" ) ;
80:250:	php_info_print_table_header 	( 2, "version"		, PHP_VROOM_VERSION ) ;
80:251:	php_info_print_table_end  	( ) ;
80:252:    } 
80:253:/* }}} */
80:254:81:1:/************************************************************************************************************
81:2:
81:3:    NAME
81:4:	php_vroom.h
81:5:	
81:6:    DESCRIPTION
81:7:	General header file for the Vroom utility functions.
81:8:	
81:9:    AUTHOR
81:10:	Christian Vigh, 11/2014.
81:11:	
81:12:    HISTORY 
81:13:	tbd
81:14:
81:15: ************************************************************************************************************/
81:16:
81:17:# ifndef __PHP_VROOM_H__
81:18:# 	define 	__PHP_VROOM_H__
81:19:
81:20:/* Thrak helper API */
81:21:# include 	"thrak.h"
81:22:
81:23:
81:24:# define PHP_VROOM_VERSION 			"0.1.0"
81:25:# define PHP_VROOM_EXTENSION_NAME		"vroom" 
81:26:
81:27:
81:28:/*-----------------------------------------------------------------------------------------------------------
81:29:
81:30:	External variables.
81:31:	
81:32: *-----------------------------------------------------------------------------------------------------------*/
81:33:extern 		THRAK_MODULE ( vroom ) ;
81:34:extern 		THRAK_FUNCTION_TABLE ( vroom ) ;
81:35:
81:36:
81:37:/*-----------------------------------------------------------------------------------------------------------
81:38:
81:39:	External user functions.
81:40:	
81:41: *-----------------------------------------------------------------------------------------------------------*/
81:42:extern 	PHP_MINIT_FUNCTION 	( vroom ) ;
81:43:extern 	PHP_MSHUTDOWN_FUNCTION	( vroom ) ;
81:44:extern 	PHP_MINFO_FUNCTION 	( vroom ) ;
81:45:extern  PHP_RINIT_FUNCTION	( vroom ) ;
81:46:extern  PHP_RSHUTDOWN_FUNCTION	( vroom ) ;
81:47:
81:48:/*-----------------------------------------------------------------------------------------------------------
81:49:
81:50:	External functions.
81:51:	
81:52: *-----------------------------------------------------------------------------------------------------------*/
81:53:extern void 		vroom_initialize	( THRAK_INIT_FUNC_ARGS ) ;
81:54:extern void 		vroom_shutdown 		( THRAK_SHUTDOWN_FUNC_ARGS ) ;
81:55:
81:56:# endif		/* __PHP_VROOM_H__ */
81:57:82:1:# INTRODUCTION #
82:2:
82:3:The **Vroom** Php extension is an external library that provides various extension functions for the user-space area.
82:4:
82:5:# LIMITATIONS #
82:6:
82:7:- The current version has only been tested on Windows platforms.
82:8:- It has no object extensions yet.
82:9:
82:10:# FUNCTIONS #
82:11:
82:12:## Array Functions ##
82:13:
82:14:Miscellaneous array functions.
82:15:
82:16:### $result = array\_flatten ( $array, $copy\_keys = false ) ###
82:17:
82:18:Flattens an array so that it has only one nesting level.
82:19:
82:20:#### PARAMETERS ####
82:21:	$array (array) -
82:22:		Array to be flattened.
82:23:		
82:24:	copy_keys (boolean) -
82:25:		When true, array keys are copied into the flattened array, whenever possible.
82:26:		
82:27:#### RETURN VALUE ####
82:28:Returns the flattened array.
82:29:
82:30:#### NOTES ####
82:31:When both an outer array and a nested array contain the same associative key, the corresponding value in the outer array will be overridden by the one of the nested array.
82:32:
82:33:Example :
82:34:	  
82:35:		print_r ( array_flatten ( [ 'a' => 1, [ 'a' => 'nested value', 'b' => 1 ] ] ) ) ;
82:36:		
82:37:will output :
82:38:	  
82:39:		[ 'a' => 'nested value', 'b' => 1 ]
82:40:		
82:41:Keys will be lost during the flattening process if their value is a nested array :
82:42:	
82:43:		print_r ( array_flatten ( [ 1, 'nested_array' => [ 2, 3 ] ] ) ) ;
82:44:		
82:45:will output :
82:46:	  
82:47:		[ 1, 2, 3 ] 
82:48:
82:49:----------
82:50:### $bool 	=  iin\_array ( $needle, $haystack ) ###
82:51:Performs a case-insensitive search of the value $needle in the array $haystack.
82:52:
82:53:#### PARAMETERS ####
82:54:	$needle (mixed) -
82:55:		Value to be searched.
82:56:		
82:57:	$haystack (array) -
82:58:		Array to be searched.
82:59:
82:60:#### RETURN VALUE ####
82:61:True if the array contains the specified value, false otherwise.
82:62:
82:63:----------
82:64:
82:65:### $bool 	=  array\_ikey\_exists ( $needle, $haystack ) ###
82:66:Performs a case-insensitive search of the value $needle in the keys of the array $haystack.
82:67:
82:68:#### PARAMETERS ####
82:69:	$needle (mixed) -
82:70:		Key to be searched.
82:71:		
82:72:	$haystack (array) -
82:73:		Array to be searched.
82:74:
82:75:#### RETURN VALUE ####
82:76:True if the array contains the specified key, false otherwise.
82:77:
82:78:----------
82:79:
82:80:## Array buffer functions ##
82:81:
82:82:Array buffer functions are intended to create fixed-size arrays containing fixed-size elements.
82:83:This allows for significant improvements in memory management ; for example, a 10000-integers array will occupy 40Kb, while its PHP equivalent will consume up to 1,4Mb.
82:84:
82:85:In future versions of the Vroom library, an object interface will be implemented.
82:86:
82:87:Note that array buffers are seen as resources in the Php user-space area.
82:88:
82:89:### $new_resource = array\_buffer\_clone ( $resource ) ###
82:90:Clones an existing array buffer.
82:91:
82:92:#### PARAMETERS ####
82:93:	$resource (resource) -
82:94:		Array buffer resource to be cloned.
82:95:
82:96:#### RETURN VALUE ####
82:97:A resource that points to the clone of the specified input array buffer, or false if something went wrong.
82:98:
82:99:----------
82:100:
82:101:### $bytes_copied = array\_buffer\_copy ( $dst\_resource, $src\_resource, $num\_bytes = 0, dst\_offset = 0, $src\_offset = 0 ) ###
82:102:Copies the whole or a part of an array buffer over an existing one. Only the bytes that can fit into the destination buffer array will be copied.
82:103:
82:104:#### PARAMETERS ####
82:105:	$dst_resource (resource) -
82:106:		Destination array buffer.
82:107:		
82:108:	$src_resource (resource) -
82:109:		Source array buffer.
82:110:		
82:111:	$num_bytes (integer) -
82:112:		Number of bytes to copy. If unspecified or zero, the whole contents of the source array buffer
82:113:		will be copied (up to destination buffer size).
82:114:		
82:115:	$dst_offset (integer) -
82:116:		Offset where to start the copy in the destination buffer.
82:117:		Defaults to zero.
82:118:		
82:119:	$src_offset (integer) -
82:120:		Offset where to start the copy from the source buffer.
82:121:		Defaults to zero.
82:122:
82:123:#### RETURN VALUE ####
82:124:Returns the number of bytes copied, or false is some invalid parameters were specified.
82:125:
82:126:----------
82:127:
82:128:### $resource 	=  array\_buffer\_create ( $size ) ###
82:129:Creates an array buffer of the specified size.
82:130:
82:131:#### PARAMETERS ####
82:132:	$size (int) -
82:133:		Array buffer size, in bytes.
82:134:
82:135:#### RETURN VALUE ####
82:136:A resource identifying the allocated array buffer, or false if something went wrong.
82:137:
82:138:----------
82:139:
82:140:### array\_buffer\_free ( $resource ) ###
82:141:Frees the resources associated with the specified array buffer.
82:142:
82:143:#### PARAMETERS ####
82:144:	$resource (resource) -
82:145:		Array buffer resource.
82:146:
82:147:----------
82:148:
82:149:### array\_buffer\_get ( $resource, $offset, $num\_bytes = 1 ) ###
82:150:Retrieves one or more bytes from an array buffer starting at the specified offset.
82:151:
82:152:#### PARAMETERS ####
82:153:	$resource (resource) -
82:154:		Array buffer resource.
82:155:		
82:156:	$offset (int) -
82:157:		Offset of the byte to be retrieved.
82:158:		
82:159:	$num_bytes (integer) -
82:160:		Number of bytes to retrieve.
82:161:
82:162:#### RETURN VALUE ####
82:163:When $num\_bytes is 1 (the default), array\_buffer\_get() returns the byte value at the specified offset of the array buffer.
82:164:
82:165:When $num\_bytes is greater than 1, consecutive bytes are returned as a binary string.
82:166:This function returns false if the offset is invalid.
82:167:
82:168:----------
82:169:
82:170:### array\_buffer\_resize ( $resource, $new\_size ) ###
82:171:Resizes an array buffer.
82:172:
82:173:#### PARAMETERS ####
82:174:	$resource (resource) -
82:175:		Array buffer resource.
82:176:		
82:177:	$size (int) -
82:178:		New size for the array buffer. If less than the current size, existing values above will be	truncated.
82:179:
82:180:#### RETURN VALUE ####
82:181:True if the array buffer has been resized or remains unchanged because the new size is equal to the	actual size, false otherwise.
82:182:
82:183:----------
82:184:
82:185:### $bytes\_set = array\_buffer\_set ( $resource, $offset = 0, $init\_value = 0, $num\_bytes = 0  ) ###
82:186:Initializes a whole or range of an array buffer to the specified value.
82:187:
82:188:#### PARAMETERS ####
82:189:	$resource (resource) -
82:190:		Array buffer to be initialized.
82:191:		
82:192:	$init\_value (integer) -
82:193:		Initialization value.
82:194:		
82:195:	$num\_bytes (integer) -
82:196:		Number of bytes to initialize. If unspecified or zero, the whole contents of the array buffer
82:197:		are initialized.
82:198:		
82:199:	$offset (integer) -
82:200:		Offset where to start initialization from.
82:201:		Defaults to zero.
82:202:
82:203:#### RETURN VALUE ####
82:204:The number of bytes initialized, or false is some invalid parameters were specified.
82:205:
82:206:----------
82:207:### $size 	=  array\_buffer\_length ( $resource ) ###
82:208:Returns the size in bytes of the array buffer associated to the specified resource.
82:209:
82:210:#### PARAMETERS ####
82:211:	$resource (resource) -
82:212:		Array buffer resource.
82:213:
82:214:#### RETURN VALUE ####
82:215:Size in bytes of the array buffer.
82:216:
82:217:----------
82:218:### $binstr 	=  data\_dwpack ( $array, [ count, [ $endianness = DATA\_MACHINE\_ENDIANNESS ] ] ) ; ###
82:219:### $binstr 	=  data\_ddpack ( $array, [ count, [ $endianness = DATA\_MACHINE\_ENDIANNESS ] ] ) ; ###
82:220:### $binstr 	=  data\_dqpack ( $array, [ count, [ $endianness = DATA\_MACHINE\_ENDIANNESS ] ] ) ; ###
82:221:	
82:222:### $binstr 	=  data\_dwlpack ( $array, $count ) ; ###
82:223:### $binstr 	=  data\_ddlpack ( $array, $count ) ; ###
82:224:### $binstr 	=  data\_dqlpack ( $array, $count ) ; ###
82:225:	
82:226:### $binstr 	=  data\_dwbpack ( $array, $count ) ; ###
82:227:### $binstr 	=  data\_ddbpack ( $array, $count ) ; ###
82:228:### $binstr 	=  data\_dqbpack ( $array, $count ) ; ###
82:229:
82:230:### $binstr 	=  data\_dwmpack ( $array, $count ) ; ###
82:231:### $binstr 	=  data\_ddmpack ( $array, $count ) ; ###
82:232:### $binstr 	=  data\_dqmpack ( $array, $count ) ; ###
82:233:These functions pack word/dword/qwords quantities, respectively. The default endianness is the machine one.
82:234:
82:235:The groups of lpack/bpack/mpack functions packs values in little endian, big endian or machine endian format.
82:236:
82:237:#### PARAMETERS ####
82:238:	$array (array or scalar value) -
82:239:		Array of values to be packed, or a scalar value if only one value is to be packed.
82:240:		In this case, the $count parameter is ignored.
82:241:		
82:242:	$count (integer) -
82:243:		Number of values from $array to be packed. If not specified, all values will be packed.
82:244:		
82:245:	$endianness (integer) -
82:246:		Endianness of the packed values ; either DATA_LITTLE_ENDIAN, DATA_BIG_ENDIAN or 
82:247:		DATA_MACHINE_ENDIAN to use the machine endianness.
82:248:
82:249:#### RETURN VALUE ####
82:250:A binary string containing the packed values, or false if an error occurred, such as not enough memory.
82:251:
82:252:## Minifying functions ##
82:253:
82:254:This section describes fast minifying functions.
82:255:
82:256:----------
82:257:
82:258:### $string 	=  minify\_php 		( $file [, $preserve\_newlines = false ] ) ###
82:259:### $string 	=  minify\_php\_stream 	( $file [, $preserve\_newlines = false [, $use\_include\_path = false ] ] ) ###
82:260:### $string 	=  minify\_php\_string    ( $string [, $preserve\_newlines = false ] ) ###
82:261:Returns the minified contents of the specified PHP source file.
82:262:
82:263:minify\_php\_stream() behaves as file\_get\_contents() for opening files (thus, an http url could be provided). There is a really low overhead compared to minify\_php (around 2% on Windows).
82:264:
82:265:## String functions ##
82:266:
82:267:This section describes extended string functions.
82:268:
82:269:----------
82:270:### string_append ( &$value, ... ) ###
82:271:Appends series of values to the specified string.
82:272:
82:273:#### PARAMETERS ####
82:274:	$value (string) -
82:275:		String where to append values.
82:276:		
82:277:	$... (mixed) -
82:278:		Any argument that can be converted to a string and appended to $value.
82:279:
82:280:#### NOTES ####
82:281:This code is theorically faster than the inline string-catenation operator, except that calling a PHP_FUNCTION() from user-space has a cost.
82:282:
82:283:When catenating 100 000 times a set of value takes 170ms using the catenation operator, it takes 615ms	for string\_append(), 535 of them being consumed just by calling the PHP\_FUNCTION().
82:284:
82:285:----------
82:286:### $value 	=  string_atoi ( $str [, &$end = null ) ###
82:287:Provides an equivalent of the C atoi() function, interpreting the following codes :
82:288:
82:289:- Decimal numbers 	: [1-9][0-9]*
82:290:- Octal numbers 	: 0[1-7]* or 0?[oO][0-7]+
82:291:- Hexadecimals numbers  : 0?[xX][0-9a-f]+
82:292:- Binary numbers 	: 0?[bB][01]+
82:293:
82:294:#### PARAMETERS ####
82:295:	$str (string) -
82:296:		String where to append values.
82:297:		
82:298:	&$end (integer) -
82:299:		If specified, will receive the position in $str after the scanned value.
82:300:
82:301:#### RETURN VALUE ####
82:302:The decoded integer value, or false if no integer value was present in the input string.
82:303:
82:304:#### NOTES ####
82:305:Leading spaces are ignored.
82:306:
82:307:----------
82:308:### $bool 	=  string\_endswith ( $value, $suffix, $case\_insensitive = false ) ###
82:309:Checks if the specified string ends with the specified suffix.
82:310:
82:311:The case_insensitive parameter determines whether comparison should be case-sensitive or not.
82:312:
82:313:#### PARAMETERS ####
82:314:	$value (string) -
82:315:		String to be checked.
82:316:		
82:317:	$suffix (string) -
82:318:		String to be compared with the end of $value.
82:319:		
82:320:	$case_insensitive (boolean) -
82:321:		When true, comparison is case-insensitive.
82:322:
82:323:#### RETURN VALUE ####
82:324:True if the supplied strings ends with the specified parameter, false otherwise.
82:325:
82:326:----------
82:327:### $array 	=  string_explode ( $separator, $value [ [ [ , $left [, $right ] ], $options ], $callback ] ) ###
82:328:### $string	=  string_implode ( $separator, $array [ [ [ , $left [, $right ] ], $options ], $callback ] ) ###
82:329:Behaves similarly to the standard PHP functions implode()/explode(), with a few enhancements :
82:330:
82:331:- Multiple separators can be given (in this case, $separator must be an array, not a string)
82:332:- Values must be prepended or appended to the exploded string ($left / $right)
82:333:- Several operations can be applied to each expanded value ($options).
82:334:	
82:335:Note that the $left, $right, $options and $callback parameters can be specified in any order, the	only restriction being that $left must always be specified before $right.
82:336:
82:337:#### PARAMETERS ####
82:338:	$separator (string or array of strings) -
82:339:		Separator(s) to be used for string separation.
82:340:		
82:341:	$value (string) -
82:342:		String to be exploded or array to be imploded.
82:343:
82:344:	$left (string) -
82:345:		When specified, string to be prepended to each exploded/imploded value.
82:346:		
82:347:	$right (string) -
82:348:		When specified, string to be appended to each exploded/imploded value.
82:349:		
82:350:	$options (integer) -
82:351:		For string_explode(), one of the following bit options :
82:352:		- EXPLODE_TRIM_LEFT :
82:353:			Left trims each exploded string.
82:354:		- EXPLODE_TRIM_RIGHT :
82:355:			Right trims each exploded string.
82:356:		- EXPLODE_TRIM :
82:357:			Trims each exploded string left and right.
82:358:		- EXPLODE_ESCAPE_QUOTES :
82:359:			Escapes each single quote withing the exploded string.
82:360:		- EXPLODE_ESCAPE_DOUBLEQUOTES :
82:361:			Escapes each double quote withing the exploded string.
82:362:		- EXPLODE_NOCASE :
82:363:			When specified, separator(s) is(are) considered to be case-insensitive.
82:364:		- EXPLODE_IGNORE_EMPTY :
82:365:			When specified, empty strings, after processing, are ignored.
82:366:		- EXPLODE_TOLOWER :
82:367:			Converts the string to lowercase.
82:368:		- EXPLODE_TOUPPER :
82:369:			Converts the string to uppercase.
82:370:		- EXPLODE_UCFIRST :
82:371:			Uppercases the first character of the string, lowercases every other one.
82:372:		- EXPLODE_UCWORDS :
82:373:			Uppercases the first letter of each word.
82:374:		- EXPLODE_ESCAPE_QUOTES :
82:375:			Escapes quote characters.
82:376:		- EXPLODE_ESCAPE_DOUBLEQUOTES :
82:377:			Escapes doublequote characters.
82:378:
82:379:		For string_implode(), constants are the same except that EXPLODE_ is replaced by IMPLODE_.
82:380:		
82:381:	$callback (callback) -
82:382:		A callback function that have the following signature :
82:383:		
82:384:			mixed  callback ( $index, $value ) ;
82:385:			
82:386:		The callback function is called before any processing guided by the $options parameter is
82:387:		performed.
82:388:
82:389:		The function can return one of this values :
82:390:		- null or boolean false (or no value returned at all) :
82:391:			The input value is kept as is.
82:392:		- boolean true :
82:393:			The input value is discarded.
82:394:		- other (string or scalar type) :
82:395:			The input value is replaced by the returned one.
82:396:
82:397:#### RETURN VALUE ####
82:398:For string_explode(), an array containing the exploded strings.
82:399:
82:400:Note that the function behaves a little bit differently from explode() : if the input value is empty, then an empty array will be returned.
82:401:	
82:402:For string_implode(), a string containing the concatenated values.
82:403:	
82:404:Both functions return false if something went wrong (eg, invalid parameter type or memory allocation error).
82:405:
82:406:----------
82:407:### $bool 	=  string\_startswith ( $value, $prefix, $case\_insensitive = false ) ###
82:408:Checks if the specified string starts with the specified prefix.
82:409:The case_insensitive parameter determines whether comparison should be case-sensitive or not.
82:410:
82:411:#### PARAMETERS ####
82:412:	$value (string) -
82:413:		String to be checked.
82:414:		
82:415:	$prefix (string) -
82:416:		String to be compared with the start of $value.
82:417:		
82:418:	$case_insensitive (boolean) -
82:419:		When true, comparison is case-insensitive.
82:420:
82:421:#### RETURN VALUE ####
82:422:True if the specified string starts with the specified prefix, false otherwise.
82:423:
82:424:----------
82:425:### $bool 	=  string\_setbos ( &$value, $prefix, [ $case\_insensitive = false, [ $return\_value = false ] ] ) ###
82:426:Prepends the $prefix string to $value if not already present.
82:427:
82:428:#### PARAMETERS #### 
82:429:	$value (string) -
82:430:		String to be checked.
82:431:		
82:432:	$prefix (string) -
82:433:		String to be prepended to $value if $value does not start with that string.
82:434:		
82:435:	$case_insensitive (boolean) -
82:436:		When true, comparison is case-insensitive.
82:437:		
82:438:	$return_value (boolean) -
82:439:		When true, the new value is returned and $value is left as is.
82:440:		When false, $value is modified in-place.
82:441:
82:442:#### RETURN VALUE ####
82:443:When the $return\_value parameter is false, returns true if operation succeeded or false otherwise.
82:444:
82:445:When $return\_value is true, returns either the new string or false if operation failed or no update was performed.
82:446:
82:447:----------
82:448:### $bool 	=  string\_seteos ( &$value, $suffix, [ $case\_insensitive = false, [ $return\_value = false ] ] ) ###
82:449:Adds the $suffix string to $value if not already present.
82:450:
82:451:#### PARAMETERS ####
82:452:	$value (string) -
82:453:		String to be checked.
82:454:		
82:455:	$suffix (string) -
82:456:		String to be appended to $value if $value does not end with that string.
82:457:		
82:458:	$case_insensitive (boolean) -
82:459:		When true, comparison is case-insensitive.
82:460:		
82:461:	$return_value (boolean) -
82:462:		When true, the new value is returned and $value is left as is.
82:463:		When false, $value is modified in-place.
82:464:
82:465:#### RETURN VALUE ####
82:466:When the $return\_value parameter is false, returns true if operation succeeded or false otherwise.
82:467:
82:468:When $return\_value is true, returns either the new string or false if operation failed or no update was performed.
82:469:
82:470:## Timer functions ##
82:471:
82:472:### $value 	=  timer\_clock ( [ $resolution = TIMER\_RESOLUTION\_NATIVE ]) ####
82:473:Returns the current value of the high resolution clock.
82:474:
82:475:#### PARAMETERS ####
82:476:	$resolution (integer) -
82:477:		Indicates the resolution of the returned value :
82:478:		- TIMER_RESOLUTION_NATIVE :
82:479:			The natural number of ticks will be returned?
82:480:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
82:481:			The returned value will be converted to the specified unit.
82:482:
82:483:#### RETURN VALUE ####
82:484:The current value of the high resolution clock.
82:485:
82:486:----------
82:487:### $value 	=  timer\_ticks\_to ( $ticks [,  $resolution = TIMER\_RESOLUTION\_NATIVE ]) ###
82:488:### $value 	=  timer\_ticks\_to\_seconds ( $ticks ) ###
82:489:### $value 	=  timer\_ticks\_to__milliseconds ( $ticks ) ###
82:490:### $value 	=  timer\_ticks\_to\_microseconds ( $ticks ) ###
82:491:### $value 	=  timer\_ticks\_to\_nanoseconds ( $ticks ) ###
82:492:Converts timer ticks to the specified resolution.
82:493:
82:494:#### PARAMETERS ####
82:495:	$ticks (double) -
82:496:		Tick count to be converted.
82:497:		
82:498:	$resolution (integer) -
82:499:		Indicates the resolution of the returned value :
82:500:		- TIMER_RESOLUTION_NATIVE :
82:501:			The natural number of ticks will be returned.
82:502:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
82:503:			The supplied tick count value will be converted to the specified unit.
82:504:
82:505:#### RETURN VALUE ####
82:506:The number of ticks supplied, converted to the specified resolution.
82:507:
82:508:----------
82:509:### $value 	=  timer\_diff ( $current, $previous [, $resolution = TIMER\_RESOLUTION\_NATIVE ]) ###
82:510:Computes the differences between two timer clock values and returns the result, converted to the	specified resolution.
82:511:
82:512:#### PARAMETERS ####
82:513:	$current (double) -
82:514:		Current timer value.
82:515:		
82:516:	$previous (double) -
82:517:		Previous timer value.
82:518:		
82:519:	$resolution (integer) -
82:520:		Indicates the resolution of the returned value :
82:521:		- TIMER_RESOLUTION_NATIVE :
82:522:			The natural number of ticks will be returned?
82:523:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
82:524:			The returned value will be converted to the specified unit.
82:525:
82:526:#### RETURN VALUE ####
82:527:The delta between the current and previous timer values, converted to the specified resolution.
82:528:
82:529:----------
82:530:### $value 	=  timer\_clock\_delta ( [ $resolution = TIMER\_RESOLUTION\_NATIVE ]) ###
82:531:Returns the delta between the call of the last timer\_clock() or timer\_clock\_delta() functions.
82:532:
82:533:If none of these functions was called, returns the current clock value.
82:534:
82:535:#### PARAMETERS ####
82:536:	$resolution (integer) -
82:537:		Indicates the resolution of the returned value :
82:538:		- TIMER_RESOLUTION_NATIVE :
82:539:			The natural number of ticks will be returned?
82:540:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
82:541:			The returned value will be converted to the specified unit.
82:542:
82:543:#### RETURN VALUE ####
82:544:The delta between the current clock and the value of the clock during the last call to timer\_clock\_delta() or timer\_clock().
82:545:
82:546:## ZVAL functions ##
82:547:This section describes lots of uninteresting functions about PHP ZVALs.
82:548:
82:549:
82:550:----------
82:551:### $array 	= zval\_dump ( &$variable ) ###
82:552:Returns an associative array containing the fields of a zval structure.
82:553:
82:554:#### PARAMETERS ####
82:555:	$variable (mixed) -
82:556:		Variable to be dumped.
82:557:
82:558:#### RETURN VALUE ####
82:559:An associative array containing the following keys :
82:560:
82:561:- 'type' : zval value type.
82:562:- 'type-string' : zval value type, as a string.
82:563:- 'refcount' : Reference count. See notes below.
82:564:- 'isref' : 	A boolean indicating whether this zval is a reference or not. See notes below.
82:565:- 'value' : 	The underlying zval value.
82:566:- 'value-length' : For string values, contain the string length.
82:567:
82:568:#### NOTES ####
82:569:Since this function accepts a reference to a zval, its reference count field will be automatically incremented and the zval will be set to be a reference.
82:570:
82:571:We try to simulate how the original value was before calling this function :
82:572:
82:573:- Reference count is decremented by one
82:574:- The "isref" field of the zval is set to zero if the decremented reference count is one.
82:575:- 
82:576:This may not reflect the actual situation but it tends to be more accurate than debug\_zval\_dump() function.
82:577:
82:578:----------
82:579:### int  	zval_decref ( &$variable ) ###
82:580:### int  	zval_incref ( &$variable ) ###
82:581:### int  	zval_setref ( &$variable, $refcount ) ###
82:582:Manipulates a zval reference count :
82:583:
82:584:- zval_decref decrements the reference count
82:585:- zval_incref increments it
82:586:- and zval_setref assigns a new reference count
82:587:
82:588:#### PARAMETERS #### 
82:589:	$variable (mixed) -
82:590:		Variable whose reference count is to be returned.
82:591:		
82:592:	$refcount (int) -
82:593:		New reference count.
82:594:
82:595:#### RETURN VALUE ####
82:596:All functions return the previous reference count.
82:597:
82:598:----------
82:599:### bool  	zval_isref ( $variable ) ###
82:600:Returns a boolean indicating whether the specified variable is a reference or not.
82:601:
82:602:#### PARAMETERS ####
82:603:	$variable (mixed) -
82:604:		Variable whose type is to be retrieved.
82:605:
82:606:#### RETURN VALUE ####
82:607:True if the specified variable is a reference, false otherwise.
82:608:
82:609:----------
82:610:### zval_swap ( $value1, $value2 ) ###
82:611:Swaps the contents of two zvals.
82:612:
82:613:#### PARAMETERS ####
82:614:	$value1, $value2 (mixed) -
82:615:		Variables to be swapped.
82:616:
82:617:----------
82:618:### int  	zval_type ( $variable ) ###
82:619:Returns the type of a zval.
82:620:
82:621:#### PARAMETERS ####
82:622:	$variable (mixed) -
82:623:		Variable whose type is to be retrieved.
82:624:
82:625:#### RETURN VALUE ####
82:626:One of the constants ZVAL\_NULL, ZVAL\_BOOL, ZVAL\_LONG, ZVAL\_STRING, ZVAL\_RESOURCE, ZVAL\_ARRAY, ZVAL\_OBJECT, or ZVAL\_UNKNOWN if the zval type could not be determined.
82:627:
82:628:----------
82:629:### int  	zval_type_constant ( $variable ) ###
82:630:Returns the type of a zval as a string constant.
82:631:
82:632:#### PARAMETERS ####
82:633:	$variable (mixed) -
82:634:		Variable whose type is to be retrieved.
82:635:
82:636:#### RETURN VALUE ####
82:637:One of the constants "ZVAL\_NULL", "ZVAL\_BOOL", "ZVAL\_LONG", "ZVAL\_STRING", "ZVAL\_RESOURCE", "ZVAL\_ARRAY",	"ZVAL\_OBJECT", or "ZVAL\_UNKNOWN" if the zval type could not be determined.
82:638:83:1:/************************************************************************************************************
83:2:
83:3:    NAME
83:4:	string.c
83:5:	
83:6:    DESCRIPTION
83:7:	String-related operations.
83:8:	
83:9:    AUTHOR
83:10:	Christian Vigh, 11/2014.
83:11:	
83:12:    HISTORY 
83:13:	tbd
83:14:
83:15: ************************************************************************************************************/
83:16:# include 	"php_vroom.h"
83:17:# include 	"string.h"
83:18:
83:19:
83:20:/*===========================================================================================================
83:21:
83:22:    NAME
83:23:	string_initialize - Initializes the string functions.
83:24:		
83:25: *===========================================================================================================*/
83:26:void 	string_initialize ( THRAK_INIT_FUNC_ARGS )
83:27:   {
83:28:	/* string_explode() and string_implode() options */
83:29:	REGISTER_LONG_CONSTANT ( "EXPLODE_NONE"			, EXPLODE_NONE			, CONST_CS | CONST_PERSISTENT ) ;
83:30:	REGISTER_LONG_CONSTANT ( "EXPLODE_TRIM_LEFT"		, EXPLODE_TRIM_LEFT		, CONST_CS | CONST_PERSISTENT ) ;
83:31:	REGISTER_LONG_CONSTANT ( "EXPLODE_TRIM_RIGHT"		, EXPLODE_TRIM_RIGHT		, CONST_CS | CONST_PERSISTENT ) ;
83:32:	REGISTER_LONG_CONSTANT ( "EXPLODE_TRIM"			, EXPLODE_TRIM			, CONST_CS | CONST_PERSISTENT ) ;
83:33:	REGISTER_LONG_CONSTANT ( "EXPLODE_ESCAPE_QUOTES"	, EXPLODE_ESCAPE_QUOTES		, CONST_CS | CONST_PERSISTENT ) ;
83:34:	REGISTER_LONG_CONSTANT ( "EXPLODE_ESCAPE_DOUBLEQUOTES"	, EXPLODE_ESCAPE_DOUBLEQUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:35:	REGISTER_LONG_CONSTANT ( "EXPLODE_NOCASE"		, EXPLODE_NOCASE		, CONST_CS | CONST_PERSISTENT ) ;
83:36:	REGISTER_LONG_CONSTANT ( "EXPLODE_IGNORE_EMPTY"		, EXPLODE_IGNORE_EMPTY		, CONST_CS | CONST_PERSISTENT ) ;
83:37:	REGISTER_LONG_CONSTANT ( "EXPLODE_TOUPPER"		, EXPLODE_TOUPPER		, CONST_CS | CONST_PERSISTENT ) ;
83:38:	REGISTER_LONG_CONSTANT ( "EXPLODE_TOLOWER"		, EXPLODE_TOLOWER		, CONST_CS | CONST_PERSISTENT ) ;
83:39:	REGISTER_LONG_CONSTANT ( "EXPLODE_UCFIRST"		, EXPLODE_UCFIRST		, CONST_CS | CONST_PERSISTENT ) ;
83:40:	REGISTER_LONG_CONSTANT ( "EXPLODE_UCWORDS"		, EXPLODE_UCWORDS		, CONST_CS | CONST_PERSISTENT ) ;
83:41:	REGISTER_LONG_CONSTANT ( "EXPLODE_UNESCAPE_QUOTES"	, EXPLODE_UNESCAPE_QUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:42:	REGISTER_LONG_CONSTANT ( "EXPLODE_UNESCAPE_DOUBLEQUOTES", EXPLODE_UNESCAPE_DOUBLEQUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:43:
83:44:	REGISTER_LONG_CONSTANT ( "IMPLODE_NONE"			, IMPLODE_NONE			, CONST_CS | CONST_PERSISTENT ) ;
83:45:	REGISTER_LONG_CONSTANT ( "IMPLODE_TRIM_LEFT"		, IMPLODE_TRIM_LEFT		, CONST_CS | CONST_PERSISTENT ) ;
83:46:	REGISTER_LONG_CONSTANT ( "IMPLODE_TRIM_RIGHT"		, IMPLODE_TRIM_RIGHT		, CONST_CS | CONST_PERSISTENT ) ;
83:47:	REGISTER_LONG_CONSTANT ( "IMPLODE_TRIM"			, IMPLODE_TRIM			, CONST_CS | CONST_PERSISTENT ) ;
83:48:	REGISTER_LONG_CONSTANT ( "IMPLODE_ESCAPE_QUOTES"	, IMPLODE_ESCAPE_QUOTES		, CONST_CS | CONST_PERSISTENT ) ;
83:49:	REGISTER_LONG_CONSTANT ( "IMPLODE_ESCAPE_DOUBLEQUOTES"  , IMPLODE_ESCAPE_DOUBLEQUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:50:	REGISTER_LONG_CONSTANT ( "IMPLODE_NOCASE"	  	, IMPLODE_NOCASE 		, CONST_CS | CONST_PERSISTENT ) ;
83:51:	REGISTER_LONG_CONSTANT ( "IMPLODE_IGNORE_EMPTY"		, IMPLODE_IGNORE_EMPTY		, CONST_CS | CONST_PERSISTENT ) ;
83:52:	REGISTER_LONG_CONSTANT ( "IMPLODE_TOUPPER"		, IMPLODE_TOUPPER		, CONST_CS | CONST_PERSISTENT ) ;
83:53:	REGISTER_LONG_CONSTANT ( "IMPLODE_TOLOWER"		, IMPLODE_TOLOWER		, CONST_CS | CONST_PERSISTENT ) ;
83:54:	REGISTER_LONG_CONSTANT ( "IMPLODE_UCFIRST"		, IMPLODE_UCFIRST		, CONST_CS | CONST_PERSISTENT ) ;
83:55:	REGISTER_LONG_CONSTANT ( "IMPLODE_UCWORDS"		, IMPLODE_UCWORDS		, CONST_CS | CONST_PERSISTENT ) ;
83:56:	REGISTER_LONG_CONSTANT ( "IMPLODE_UNESCAPE_QUOTES"	, IMPLODE_UNESCAPE_QUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:57:	REGISTER_LONG_CONSTANT ( "IMPLODE_UNESCAPE_DOUBLEQUOTES", IMPLODE_UNESCAPE_DOUBLEQUOTES	, CONST_CS | CONST_PERSISTENT ) ;
83:58:    }
83:59:
83:60:
83:61:/*===========================================================================================================
83:62:
83:63:    NAME
83:64:	string_shutdown
83:65:	
83:66:    DESCRIPTION
83:67:	Sub-extension shutdown function.
83:68:	
83:69: *===========================================================================================================*/
83:70:void 	string_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
83:71:   {
83:72:    }
83:73:
83:74:
83:75:    
83:76:/*===========================================================================================================
83:77:
83:78:    NAME
83:79:	string_append - Fast string concatenation.
83:80:	
83:81:    PROTOTYPE
83:82:	string_append ( &$value, ... ) ;
83:83:	
83:84:    DESCRIPTION
83:85:	Appends series of values to the specified string.
83:86:	
83:87:    PARAMETERS
83:88:	$value (string) -
83:89:		String where to append values.
83:90:		
83:91:	$... (mixed) -
83:92:		Any argument that can be converted to a string and appended to $value.
83:93:	
83:94:    NOTE 
83:95:	This code is theorically faster than the inline string-catenation operator, except that calling a
83:96:	PHP_FUNCTION() has a cost.
83:97:	When catenating 100 000 times a set of value takes 170ms using the catenation operator, it takes 615ms
83:98:	for string_append(), 535 of them being consumed just by calling the PHP_FUNCTION().
83:99:	
83:100: *===========================================================================================================*/
83:101:THRAK_API zend_bool 	internal_string_append ( zval *  z_string, int  argc, zval **  argv, char **  result, int *  result_length )
83:102:    {
83:103:	char *		data,
83:104:	     *		p ;
83:105:	int  		size 		=  Z_STRLEN_P ( z_string ) ;
83:106:	int  		i ;
83:107:	
83:108:	// Compute the size needed to hold all the appended strings
83:109:	for (  i = 0 ; i  <  argc ; i ++ )
83:110:	   {
83:111:		if  ( Z_ISREF_P ( argv [i] ) )
83:112:			SEPARATE_ZVAL ( & argv [i] ) ;
83:113:			
83:114:		convert_to_string ( argv [i] ) ;
83:115:		size 	+=  Z_STRLEN_P ( argv [i] ) ;
83:116:	    }
83:117:	    
83:118:	// Allocate enough memory for it (just reallocate existing data, this will avoid to copy the appended variable
83:119:	// initial value)
83:120:	data = p = erealloc ( Z_STRVAL_P ( z_string ), size + 1 ) ;
83:121:	
83:122:	if  ( data  ==  NULL )
83:123:		return ( 0 ) ;
83:124:		
83:125:	// Point at the end of initial value
83:126:	p += Z_STRLEN_P ( z_string ) ;
83:127:	
83:128:	for  ( i = 0 ; i  <  argc ; i ++, argv ++ )
83:129:	   {
83:130:		memcpy ( p, Z_STRVAL_PP ( argv ), Z_STRLEN_PP ( argv ) ) ;
83:131:		p += Z_STRLEN_PP ( argv ) ;
83:132:	    }
83:133:	 
83:134:	/* Useless but makes me happy */
83:135:	* p = 0 ;
83:136:	
83:137:	// Give the resulting string to the caller
83:138:	* result 		=  data ;
83:139:	* result_length 	=  size ;
83:140:	
83:141:	return ( 1 ) ;
83:142:     }
83:143:     
83:144:     
83:145: PHP_FUNCTION ( string_append )
83:146:    {
83:147:	zval *		z_string ;
83:148:	zval ***	argv 		=  NULL ;
83:149:	int  		argc 		=  0 ;
83:150:	char *		result ;
83:151:	int 		result_length ;
83:152:	
83:153:	
83:154:	/* Parse arguments */
83:155:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z+", & z_string, & argv, & argc )  ==  FAILURE )
83:156:		return;
83:157:
83:158:	// First arg must be a string
83:159:	if  ( Z_TYPE_P ( z_string )  !=  IS_STRING )
83:160:		convert_to_string ( z_string ) ;
83:161:	
83:162:	// Perform the append operation
83:163:	if  ( internal_string_append ( z_string, argc, * argv, & result, & result_length ) )
83:164:	   {
83:165:		RETVAL_TRUE ;
83:166:		ZVAL_STRINGL ( z_string, result, result_length, 0 ) ;
83:167:	    }
83:168:	else
83:169:		RETVAL_FALSE ;
83:170:		
83:171:	efree ( argv ) ;
83:172:    }
83:173:
83:174:    
83:175:/*===========================================================================================================
83:176:
83:177:    NAME
83:178:	string_atoi - C atoi() equivalent.
83:179:	
83:180:    PROTOTYPE
83:181:	$value 	=  string_atoi ( $str [, &$end = null ) ;
83:182:	
83:183:    DESCRIPTION
83:184:	Provides an equivalent of the C atoi() function, interpreting the following codes :
83:185:	- Decimal numbers 	: [1-9][0-9]*
83:186:	- Octal numbers 	: 0[1-7]* or 0?[oO][0-7]+
83:187:	- Hexadecimals numbers  : 0?[xX][0-9a-f]+
83:188:	- Binary numbers 	: 0?[bB][01]+
83:189:	
83:190:    PARAMETERS
83:191:	$str (string) -
83:192:		String where to append values.
83:193:		
83:194:	&$end (integer) -
83:195:		If specified, will receive the position in $str after the scanned value.
83:196:	
83:197:    RETURN VALUE
83:198:	The decoded integer value, or false if no integer value was present in the input string.
83:199:    
83:200:    NOTES
83:201:	Leading spaces are ignored.
83:202:	
83:203: *===========================================================================================================*/
83:204:PHP_FUNCTION ( string_atoi ) 
83:205:   {
83:206:	char *			value ;
83:207:	int  			value_length ;
83:208:	zval * 			output_index 		=  NULL ;
83:209:	char * 			output_position ;
83:210:	int64			decoded_value ;
83:211:	zend_bool		status ;
83:212:	
83:213:	
83:214:	/* Get parameters */
83:215:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "s|z", & value, & value_length, & output_index )  ==  FAILURE )
83:216:		return ;
83:217:	
83:218:	/* Decode */
83:219:	status 	=  thrak_atoi ( value, & output_position, & decoded_value, 0 ) ;
83:220:	
83:221:	/* Return false if no integer is represented in the value */
83:222:	if  ( ! status )
83:223:		RETURN_FALSE ;
83:224:		
83:225:	/* If the $end parameter is supplied, set it to the numeric index of the first position after the decoded value */
83:226:	if  ( output_index  !=  NULL )
83:227:	   {
83:228:		Z_TYPE_P ( output_index )	=  IS_LONG ;
83:229:		Z_LVAL_P ( output_index ) 	=  ( int ) ( output_position - value ) ;
83:230:	    }
83:231:	    
83:232:	/* All done, return the decode value (take into account the size of long on Windows) */
83:233:# if  	( LONG_SIZE  ==  4 )
83:234:	RETVAL_DOUBLE ( ( double ) decoded_value ) ;
83:235:# else
83:236:	RETVAL_LONG ( decoded_value ) ;
83:237:# endif
83:238:    }
83:239:    
83:240:    
83:241:/*===========================================================================================================
83:242:
83:243:    NAME
83:244:	string_endswith - Checks if a string ends with another string.
83:245:	
83:246:    PROTOTYPE
83:247:	$bool 	=  string_endswith ( $value, $suffix, $case_insensitive = false ) ;
83:248:	
83:249:    DESCRIPTION
83:250:	Checks if the specified string ends with the specified suffix.
83:251:	The case_insensitive parameter determines whether comparison should be case-sensitive or not.
83:252:	
83:253:    PARAMETERS
83:254:	$value (string) -
83:255:		String to be checked.
83:256:		
83:257:	$suffix (string) -
83:258:		String to be compared with the end of $value.
83:259:		
83:260:	$case_insensitive (boolean) -
83:261:		When true, comparison is case-insensitive.
83:262:		
83:263: *===========================================================================================================*/
83:264:THRAK_API zend_bool 	internal_string_endswith  ( const char *  value, int  value_length, const char *  suffix, int  suffix_length, int  case_insensitive )
83:265:   {
83:266:	zend_bool 	status 		=  0 ;
83:267:	int 		( *cmpfunc ) ( const char *  a, const char *  b, size_t  count )	=  ( case_insensitive ) ? strnicmp : strncmp ;
83:268:	
83:269:	
83:270:	if  ( suffix_length  <=  value_length )
83:271:	   {
83:272:		value	+=  ( value_length - suffix_length ) ;
83:273:		status 	 =  ( * cmpfunc ) ( value, suffix, suffix_length ) ?  0 : 1 ;
83:274:	    }
83:275:	    
83:276:	return ( status ) ;
83:277:    }
83:278:
83:279:    
83:280:PHP_FUNCTION(string_endswith)
83:281:   {
83:282:	char *		value ;
83:283:	int 		value_length ;
83:284:	char *		suffix ;
83:285:	int 		suffix_length ;
83:286:	int 		case_insensitive 	=  0 ;
83:287:	
83:288:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "ss|b", &value, &value_length, &suffix, &suffix_length, &case_insensitive )  ==  FAILURE )
83:289:		return ;
83:290:	
83:291:	RETURN_BOOL ( internal_string_endswith ( value, value_length, suffix, suffix_length, case_insensitive ) ) ;
83:292:   }
83:293:
83:294:   
83:295:   
83:296:/*===========================================================================================================
83:297:
83:298:    NAME
83:299:	string_explode, string_implode - Similar to the explode()/implode functions.
83:300:	
83:301:    PROTOTYPE
83:302:	$array 	=  string_explode ( $separator, $value [ [ [ , $left [, $right ] ], $options ], $callback ] ) ;
83:303:	$string	=  string_implode ( $separator, $array [ [ [ , $left [, $right ] ], $options ], $callback ] ) ;
83:304:	
83:305:    DESCRIPTION
83:306:	Behaves similarly to the standard PHP functions implode()/explode(), with a few enhancements :
83:307:	- Multiple separators can be given (in this case, $separator must be an array, not a string)
83:308:	- Values must be prepended or appended to the exploded string ($left / $right)
83:309:	- Several operations can be applied to each expanded value ($options).
83:310:	
83:311:	Note that the $left, $right, $options and $callback parameters can be specified in any order, the
83:312:	only restriction being that $left must always be specified before $right.
83:313:	
83:314:    PARAMETERS
83:315:	$separator (string or array of strings) -
83:316:		Separator(s) to be used for string separation.
83:317:		
83:318:	$value (string) -
83:319:		String to be exploded or array to be imploded.
83:320:
83:321:	$left (string) -
83:322:		When specified, string to be prepended to each exploded/imploded value.
83:323:		
83:324:	$right (string) -
83:325:		When specified, string to be appended to each exploded/imploded value.
83:326:		
83:327:	$options (integer) -
83:328:		For string_explode(), one of the following bit options :
83:329:		- EXPLODE_TRIM_LEFT :
83:330:			Left trims each exploded string.
83:331:		- EXPLODE_TRIM_RIGHT :
83:332:			Right trims each exploded string.
83:333:		- EXPLODE_TRIM :
83:334:			Trims each exploded string left and right.
83:335:		- EXPLODE_ESCAPE_QUOTES :
83:336:			Escapes each single quote withing the exploded string.
83:337:		- EXPLODE_ESCAPE_DOUBLEQUOTES :
83:338:			Escapes each double quote withing the exploded string.
83:339:		- EXPLODE_NOCASE :
83:340:			When specified, separator(s) is(are) considered to be case-insensitive.
83:341:		- EXPLODE_IGNORE_EMPTY :
83:342:			When specified, empty strings, after processing, are ignored.
83:343:		- EXPLODE_TOLOWER :
83:344:			Converts the string to lowercase.
83:345:		- EXPLODE_TOUPPER :
83:346:			Converts the string to uppercase.
83:347:		- EXPLODE_UCFIRST :
83:348:			Uppercases the first character of the string, lowercases every other one.
83:349:		- EXPLODE_UCWORDS :
83:350:			Uppercases the first letter of each word.
83:351:		- EXPLODE_ESCAPE_QUOTES :
83:352:			Escapes quote characters.
83:353:		- EXPLODE_ESCAPE_DOUBLEQUOTES :
83:354:			Escapes doublequote characters.
83:355:
83:356:		For string_implode(), constants are the same except that EXPLODE_ is replaced by IMPLODE_.
83:357:		
83:358:	$callback (callback) -
83:359:		A callback function that have the following signature :
83:360:		
83:361:			mixed  callback ( $index, $value ) ;
83:362:			
83:363:		The callback function is called before any processing guided by the $options parameter is
83:364:		performed.
83:365:
83:366:		The function can return one of this values :
83:367:		- null or boolean false (or no value returned at all) :
83:368:			The input value is kept as is.
83:369:		- boolean true :
83:370:			The input value is discarded.
83:371:		- other (string or scalar type) :
83:372:			The input value is replaced by the returned one.
83:373:		
83:374:    RETURN VALUE
83:375:	For string_explode(), an array containing the exploded strings.
83:376:	Note that the function behaves a little bit differently from explode() : if the input value is empty,
83:377:	then an empty array will be returned.
83:378:	
83:379:	For string_implode(), a string containing the concatenated values.
83:380:	
83:381:	Both functions return false if something went wrong (eg, invalid parameter type or memory allocation
83:382:	error).
83:383:	
83:384: *===========================================================================================================*/
83:385: 
83:386:/* Extra arguments that can be specified in any order are stored in a zval array of EXTRA_ARG_COUNT elements.		*/
83:387:/* Each slot in this array corresponds to a specified arg in the following order : left, right, options and callback.	*/
83:388:# define 	EXTRA_ARG_COUNT 		4
83:389:# define 	EXTRA_ARG_LEFT 			0
83:390:# define 	EXTRA_ARG_RIGHT 		1
83:391:# define 	EXTRA_ARG_OPTIONS		2
83:392:# define 	EXTRA_ARG_CALLBACK		3 
83:393:
83:394:/* Generic value processing - called by __process_explode_options() and __process_implode_options() */ 
83:395:static zend_always_inline void	__process_options 	  ( int  		index,
83:396:							    char *  		value, 
83:397:							    int  		value_length, 
83:398:							    zval *  		options_zval, 
83:399:							    zval *  		left_string, 
83:400:							    zval *  		right_string, 
83:401:							    zval *  		callback,
83:402:							    char **		output_value,
83:403:							    int *		output_value_length,
83:404:							    int * 		duplicate
83:405:							    TSRMLS_DC )
83:406:   {
83:407:	char * 		value_end 	=  value + value_length ;
83:408:	char * 		original_value 	=  value ;
83:409:	int 		options 	=  ( options_zval  ==  NULL ) ?  0 : Z_LVAL_P ( options_zval ) ;
83:410:	char *		p,
83:411:	     *		q ;
83:412:	char * 		new_value ;
83:413:	int 		realloc_extra	=  0 ;
83:414:	zval 		callback_result ;			
83:415:	int 		free_value 	=  0 ;
83:416:	int 		length ;
83:417:
83:418:
83:419:	/* EXPLODE_TRIM_LEFT option : trim left space characters */
83:420:	if  ( options  &  EXPLODE_TRIM_LEFT )
83:421:	   {
83:422:		while  ( value  <  value_end  &&  isspace ( * value ) )
83:423:			value ++, value_length -- ;
83:424:	    }
83:425:	    
83:426:	/* EXPLODE_TRIM_RIGHT : trim right space characters */
83:427:	if  ( options  &  EXPLODE_TRIM_RIGHT )
83:428:	   {
83:429:		while  ( value_end  >  value  &&  isspace ( * ( value_end - 1 ) ) )
83:430:			value_end --, value_length -- ;
83:431:	    }
83:432:
83:433:	/* EXPLODE_IGNORE_EMPTY : ignore empty strings */
83:434:	if  ( options  &  EXPLODE_IGNORE_EMPTY )
83:435:	   {
83:436:		if  ( ! value_length )
83:437:		   {
83:438:			if  ( free_value ) 
83:439:				zval_dtor ( & callback_result ) ;
83:440:				
83:441:			return ;
83:442:		    }
83:443:	    }
83:444:	    
83:445:	/* Process callback if any */
83:446:	if  ( callback  !=  NULL )
83:447:	   {
83:448:		zval 		retval ;				/* Callback return value 			        */
83:449:		zval *		callback_params [3] ;			/* Callback parameters : index and string value 	*/
83:450:		zval  		index_zval ;				/* A zval for the index parameter			*/
83:451:		zval 	  	value_zval ;				/* Another one for the value parameter 			*/
83:452:		
83:453:		/* Build the $index and $value callback parameters */
83:454:		INIT_ZVAL ( index_zval ) ;
83:455:		ZVAL_LONG ( & index_zval, index ) ;
83:456:
83:457:		/***
83:458:			The zend_call_function() function in zend_execute_API.c always calls zend_vm_stack_clear_multiple() which 
83:459:			in turn calls zval_dtor() for each of the function arguments. The call is systematic, so every supplied 
83:460:			string zval will get undonditionnally freed.
83:461:			For that reason, we must allocate a copy of the supplied value in value_zval before calling the function.
83:462:		 ***/
83:463:		INIT_ZVAL ( value_zval ) ;
83:464:		ZVAL_STRINGL ( & value_zval, value, value_length, 1 ) ;
83:465:		
83:466:		/* Initialize the callback parameters array */
83:467:		callback_params [0] 	=  & index_zval ;
83:468:		callback_params [1] 	=  & value_zval ;
83:469:		callback_params [2]	=  NULL ;
83:470:		
83:471:		/* Call it */
83:472:		if  ( call_user_function ( CG ( function_table ), NULL, callback, & retval, 2, callback_params TSRMLS_CC )  ==  FAILURE )
83:473:			return ;
83:474:			
83:475:		efree ( Z_STRVAL ( value_zval ) ) ;
83:476:
83:477:		/* Process return value */
83:478:		switch  ( Z_TYPE ( retval ) )
83:479:		   {
83:480:			/* Forbidden return value types */
83:481:			case 	IS_RESOURCE :
83:482:			case 	IS_OBJECT :
83:483:			case 	IS_ARRAY :
83:484:				php_error_docref ( NULL TSRMLS_CC, E_ERROR, "invalid return value type from user callback" ) ;
83:485:				return ;
83:486:				
83:487:			/* NULL return value : callback leaves the current value as is */
83:488:			case 	IS_NULL :
83:489:				callback_result 	=  retval ;		/* Keep original return value, we will need to free it */
83:490:				break ;
83:491:				
83:492:			/* Boolean false : same as NULL ; boolean true : the value is discarded */
83:493:			case 	IS_BOOL :
83:494:				if  ( Z_BVAL ( retval ) )
83:495:				   {
83:496:					zval_dtor ( & retval ) ;
83:497:					return ;
83:498:				    }
83:499:				    
83:500:				callback_result 	=  retval ;		/* Keep original return value, we will need to free it */
83:501:				break ;
83:502:				
83:503:			/* Other types : make sure to have a string here */
83:504:			default :
83:505:				callback_result 	=  retval ;		/* Keep original return value, we will need to free it */
83:506:				convert_to_string ( & retval ) ;
83:507:				value 			=  Z_STRVAL ( retval ) ;
83:508:				value_length 		=  Z_STRLEN ( retval ) ;
83:509:				value_end 		=  value + value_length ;
83:510:				free_value 		=  1 ;
83:511:		    }
83:512:	     }
83:513:	
83:514:	/* EXPLODE_TOLOWER : Converts letters to lower case */
83:515:	if  ( ( options  &  EXPLODE_TOLOWER )  ==  EXPLODE_TOLOWER )
83:516:	   {
83:517:		for  ( p = value ; p < value_end ; p ++ )
83:518:			* p 	=  tolower ( * p ) ;
83:519:	    }
83:520:	    
83:521:	/* EXPLODE_TOUPPER : Converts letters to upper case */
83:522:	if  ( ( options  &  EXPLODE_TOUPPER )  ==  EXPLODE_TOUPPER )
83:523:	   {
83:524:		for  ( p = value ; p < value_end ; p ++ )
83:525:			* p 	=  toupper ( * p ) ;
83:526:	    }
83:527:	
83:528:	/* EXPLODE_UCFIRST : Converts the first letter of the string to uppercase, lowercases the rest */
83:529:	if  ( options  &  EXPLODE_UCFIRST )
83:530:	   {
83:531:		* value 	=  toupper ( * value ) ;
83:532:		
83:533:		for  ( p = value + 1 ; p < value_end ; p ++ )
83:534:			* p 	=  tolower ( * p ) ;
83:535:	    }
83:536:	
83:537:	/* EXPLODE_UCWORDS : Converts the first letter of every word in the string to uppercase, lowercases the rest */
83:538:	if  ( options  &  EXPLODE_UCWORDS )
83:539:	   {
83:540:		char 		prev_ch 	=  * value ;
83:541:		
83:542:		* value 	=  toupper ( * value ) ;
83:543:		
83:544:		
83:545:		for  ( p = value + 1 ; p < value_end ; p ++ )
83:546:		   {
83:547:			if  ( isalpha ( prev_ch ) )
83:548:				* p 	=  tolower ( * p ) ;
83:549:			else
83:550:				* p 	=  toupper ( * p ) ;
83:551:				
83:552:			prev_ch 	=  * p ;
83:553:		    }
83:554:	    }
83:555:	    
83:556:	/* EXPLODE_ESCAPE_QUOTES/DOUBLEQUOTES : escapes quotes/double quotes during processing */
83:557:	if  ( options  &  ( EXPLODE_ESCAPE_QUOTES | EXPLODE_ESCAPE_DOUBLEQUOTES )  &&  ! ( options  &  UNESCAPE_FLAG ) )
83:558:	   {
83:559:		char 	quote 	=  ( options & EXPLODE_ESCAPE_QUOTES ) ?  '\'' : '"' ;
83:560:		
83:561:		p 	=  strchr ( value, quote ) ;
83:562:		
83:563:		while  ( p  !=  NULL )
83:564:		   {
83:565:			realloc_extra ++ ;
83:566:			
83:567:			if  ( ++ p  ==  value_end )
83:568:				break ;
83:569:				
83:570:			p 	=  strchr ( p, quote ) ;
83:571:		    }
83:572:	    }
83:573:	    
83:574:   
83:575:	/* Count potential space used for left- and right-strings */
83:576:	if  ( left_string  !=  NULL )
83:577:		realloc_extra 	+=  Z_STRLEN_P ( left_string ) ;
83:578:		
83:579:	if  ( right_string  !=  NULL )
83:580:		realloc_extra   +=  Z_STRLEN_P ( right_string ) ;
83:581:	
83:582:	/* If some space is to be added, due to left/right strings or character escaping, allocate it */
83:583:	if  ( realloc_extra )
83:584:	   {
83:585:		/* realloc_extra contains additional bytes to reserve, such as space for escaping quotes or also strings to prepend/append */
83:586:		new_value 	=  emalloc ( value_length + realloc_extra ) ;
83:587:		
83:588:		if  ( new_value  ==  NULL )
83:589:			return ;
83:590:			
83:591:		q		=  new_value ;
83:592:		
83:593:		/* Prepend "left" string, if any */
83:594:		if  ( left_string  !=  NULL )
83:595:		   {
83:596:			length		=  Z_STRLEN_P ( left_string ) ;
83:597:			
83:598:			if  ( length )
83:599:			   {
83:600:				memcpy ( q, Z_STRVAL_P ( left_string ), length ) ;
83:601:				q += length ;
83:602:			    }
83:603:		    }
83:604:		    
83:605:		/* Copy the initial value, but take into account the case where quotes are to be escaped */
83:606:		if  ( options  &  ( EXPLODE_ESCAPE_QUOTES | EXPLODE_ESCAPE_DOUBLEQUOTES )  &&  ! ( options  &  UNESCAPE_FLAG ) )
83:607:		   {
83:608:			char 	quote 	=  ( options & EXPLODE_ESCAPE_QUOTES ) ?  '\'' : '"' ;
83:609:			
83:610:			length 		=  value_length ;
83:611:			p 		=  value ;
83:612:			
83:613:			while  ( length -- )
83:614:			   {
83:615:				if  ( * p  ==  quote )
83:616:					* q ++ 	=  '\\' ;
83:617:					
83:618:				* q ++ 	=  * p ++ ;
83:619:			    }
83:620:		    }
83:621:		/* Otherwise, perform a raw copy */
83:622:		else
83:623:		   {
83:624:			memcpy ( q, value, value_length ) ;
83:625:			q += value_length ;
83:626:		    }
83:627:		    
83:628:		/* Append right string, if any */
83:629:		if  ( right_string  !=  NULL )
83:630:		   {
83:631:			length 		=  Z_STRLEN_P ( right_string ) ;    
83:632:			
83:633:			if  ( length )
83:634:				memcpy ( q, Z_STRVAL_P ( right_string ), length ) ;
83:635:		    }
83:636:			
83:637:		/* Ok, here we have a new value and a new length */
83:638:		value 		=  new_value ;
83:639:		value_length   +=  realloc_extra ;
83:640:	    }
83:641:	
83:642:	/* Free callback result if any, but only if the buffer has been reallocated */
83:643:	if  ( free_value  &&  realloc_extra )
83:644:		zval_dtor ( & callback_result ) ;
83:645:		
83:646:	/* Set the output result */
83:647:	* output_value 		=  value ;
83:648:	* output_value_length 	=  value_length ;
83:649:	* duplicate 		=  ! realloc_extra ;
83:650:    }
83:651:
83:652:
83:653:/* Process current value for string_explode() */
83:654:static zend_always_inline void	__process_explode_options ( zval *  		array, 
83:655:							    int 		index,
83:656:							    char *  		value, 
83:657:							    int  		value_length, 
83:658:							    zval *  		options_zval, 
83:659:							    zval *  		left_string, 
83:660:							    zval *  		right_string, 
83:661:							    zval *  		callback
83:662:							    TSRMLS_DC )
83:663:   {
83:664:	char *		output_value ;
83:665:	int 		output_value_length ;
83:666:	int 		duplicate ;
83:667:	
83:668:	
83:669:	/* Process the options to apply on the current value */
83:670:	__process_options ( index, value, value_length, options_zval, left_string, right_string, callback,
83:671:				& output_value, & output_value_length, & duplicate TSRMLS_CC ) ;
83:672:				
83:673:	/* Add the value to the returned array ; do not duplicate it if we already did it */
83:674:	add_next_index_stringl ( array, output_value, output_value_length, duplicate ) ;
83:675:    }    
83:676:    
83:677:
83:678:PHP_FUNCTION ( string_explode )
83:679:   {
83:680:	zval *			separator_zval ;				/* Variables used for parameter retrieval 					*/
83:681:	char * 			value ;						
83:682:	int 			value_length ;
83:683:	zval ***		argv ;
83:684:	int 			argc 			=  0 ;
83:685:	zval *			extra_args [ EXTRA_ARG_COUNT ] ;		/* Extra args, in the following order : left, right, options and callback 	*/
83:686:	char **			separator_values ;				/* Separators used for exploding 						*/
83:687:	int *			separator_lengths ;				/* their respectives lengths 							*/
83:688:	int 			separator_count ;				/* and their count								*/
83:689:	char *			separator_buffer ;				/* All of that stored in that buffer 						*/
83:690:	char * 			callback_name ;
83:691:	char *			p,
83:692:	     *			p_end,
83:693:	     * 			q ;
83:694:	int 			i ;
83:695:	int  			index 			=  0 ;
83:696:	int 			found ;
83:697:	int 			( * cmpfunc ) 	  ( const char *  a, const char *  b, size_t  length ) ;
83:698:	char * 			( * searchfunc )  ( const char *  a, int  ch ) ;
83:699:	
83:700:	  
83:701:	     
83:702:
83:703:	/* Parse parameters */
83:704:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zs*", & separator_zval, & value, & value_length, & argv, & argc )  ==  FAILURE )
83:705:		RETURN_FALSE ;
83:706:	
83:707:	if  ( argc  >  4 )
83:708:	   {
83:709:		php_error_docref ( NULL TSRMLS_CC, E_ERROR, "string_explode() expects at most 6 arguments, %d provided", argc + 2 ) ;
83:710:		
83:711:		if  ( argc )
83:712:			efree ( argv ) ;
83:713:			
83:714:		RETURN_FALSE ;
83:715:	    }
83:716:	    
83:717:	/* Check parameter type for $separator */
83:718:	switch  ( Z_TYPE_P ( separator_zval ) )
83:719:	   {
83:720:		case 	IS_OBJECT :
83:721:		case 	IS_RESOURCE :
83:722:			php_error_docref ( NULL TSRMLS_CC, E_ERROR, "the type of the $separator argument cannot be an object nor a resource" ) ;
83:723:			
83:724:			if  ( argc )
83:725:				efree ( argv ) ;
83:726:				
83:727:			RETURN_FALSE ;
83:728:	    }
83:729:	    
83:730:	/* Collect extra arguments from argv[] and reorder them into extra_args */
83:731:	memset ( extra_args, 0, sizeof ( extra_args ) ) ;
83:732:
83:733:	for  ( i = 0 ; i  <  argc ; i ++ )
83:734:	   {
83:735:		switch ( Z_TYPE_P ( * argv [i] ) )
83:736:		   {
83:737:			/* Forbidden value types */
83:738:			case 	IS_RESOURCE :
83:739:				php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect resource data type for parameter #%d", i + 3 ) ;
83:740:				efree ( argv ) ;
83:741:					
83:742:				RETURN_FALSE ;
83:743:
83:744:			case 	IS_ARRAY :
83:745:				if  ( extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL  ||  zend_hash_num_elements ( Z_ARRVAL_P ( * argv [i] ) )  !=  2 )
83:746:				   {
83:747:					php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect array data type for parameter #%d", i + 3 ) ;
83:748:					efree ( argv ) ;
83:749:						
83:750:					RETURN_FALSE ;
83:751:				    }
83:752:				    
83:753:				extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:754:				break ;
83:755:			
83:756:			/* If an object is specified, it must be a closure */
83:757:			case  	IS_OBJECT :
83:758:				callback_name 	=  NULL ;
83:759:				
83:760:				if  ( ! zend_is_callable ( * argv [i], 0, & callback_name TSRMLS_CC )  ||  extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL )
83:761:				   {
83:762:					php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect object data type for parameter #%d", i + 3 ) ;
83:763:					
83:764:					if  ( callback_name  !=  NULL )
83:765:						efree ( callback_name ) ;
83:766:						
83:767:					efree ( argv ) ;
83:768:						
83:769:					RETURN_FALSE ;
83:770:				    }
83:771:
83:772:				if  ( callback_name  !=  NULL )
83:773:					efree ( callback_name ) ;
83:774:				   
83:775:				extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:776:				break ;
83:777:			
83:778:			/* A long is reserved for the $options parameter */
83:779:			case 	IS_LONG :
83:780:				if  ( extra_args [ EXTRA_ARG_OPTIONS ]  ==  NULL )
83:781:				   {
83:782:					extra_args [ EXTRA_ARG_OPTIONS ]	=  * argv [i] ;
83:783:					break ;
83:784:				    }
83:785:				/* Break intentionnally missing to fall through the next case */
83:786:				
83:787:			/* All other types are for either $left, $right or $callback (when specified as a string) */
83:788:			case 	IS_BOOL :
83:789:			case 	IS_DOUBLE :
83:790:			case 	IS_STRING :
83:791:				convert_to_string_ex ( argv [i] ) ;
83:792:				
83:793:				if  ( extra_args [ EXTRA_ARG_LEFT ]  !=  NULL )
83:794:				   {
83:795:					if ( extra_args [ EXTRA_ARG_RIGHT ]  !=  NULL )
83:796:					   {
83:797:						if  ( extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL )
83:798:						   {
83:799:							php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect data type for parameter #%d", i + 3 ) ;
83:800:							efree ( argv ) ;
83:801:								
83:802:							RETURN_FALSE ;
83:803:						    }
83:804:						else
83:805:							extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:806:					    }
83:807:					else
83:808:						extra_args [ EXTRA_ARG_RIGHT ] 	=  * argv [i] ;
83:809:				    }
83:810:				else
83:811:					extra_args [ EXTRA_ARG_LEFT ] 	=  * argv [i] ;
83:812:				break ;
83:813:		    }
83:814:	    }
83:815:	    
83:816:	/* Explode the input string */
83:817:	separator_buffer 	=  thrak_array_to_char ( separator_zval, & separator_values, & separator_count, & separator_lengths ) ;
83:818:	p 			=  value ;
83:819:	p_end 			=  value + value_length ;
83:820:
83:821:	/* Make sure we could convert input separator array to an array of strings */
83:822:	if  ( separator_buffer  ==  NULL )
83:823:	   {
83:824:		if  ( argc )
83:825:			efree ( argv ) ;
83:826:			
83:827:		RETURN_FALSE ;
83:828:	    }
83:829:		
83:830:	/* Compare function */
83:831:	if  ( extra_args [ EXTRA_ARG_OPTIONS ]  !=  NULL  &&  ( Z_LVAL_P ( extra_args [ EXTRA_ARG_OPTIONS ] )  &  EXPLODE_NOCASE ) )
83:832:	   {
83:833:		cmpfunc 	=  strnicmp ;
83:834:		searchfunc 	=  thrak_strichr ;
83:835:	    }
83:836:	else
83:837:	   {
83:838:		cmpfunc 	=  strncmp ;
83:839:		searchfunc 	=  strchr ;
83:840:	    }
83:841:	
83:842:	/* Initialize return value */
83:843:	array_init ( return_value ) ;
83:844:	index 	=  0 ;
83:845:
83:846:	/* Loop through string to explode */
83:847:	while  ( p  <  p_end )
83:848:	   {
83:849:		/* Search for the next occurrence of a separator */
83:850:		found 	=  0 ;
83:851:		
83:852:		for  ( i = 0 ; i  <  separator_count ; i ++ )
83:853:		   {
83:854:			q 	=  searchfunc ( p, separator_values [i] [0] ) ;
83:855:			
83:856:			if  ( q  !=  NULL )
83:857:			   {
83:858:				if  ( ! cmpfunc ( q, separator_values [i], separator_lengths [i] ) )
83:859:				   {
83:860:					found 	=  1 ;
83:861:					break ;
83:862:				    }
83:863:			    }
83:864:		    }
83:865:
83:866:		/* Separator found */
83:867:		if  ( found )
83:868:		   {
83:869:			__process_explode_options ( return_value, index ++, p, ( int ) ( q - p ), 
83:870:					extra_args [ EXTRA_ARG_OPTIONS ], extra_args [ EXTRA_ARG_LEFT ], extra_args [ EXTRA_ARG_RIGHT ], 
83:871:					extra_args [ EXTRA_ARG_CALLBACK ] TSRMLS_CC ) ;
83:872:			p 	= q + separator_lengths [i] ;
83:873:		    }
83:874:		/* This string contains none of the supplied separator_values : no more search to be done */
83:875:		else
83:876:			break ;
83:877:	    }
83:878:
83:879:	/* Maybe a last item ? */
83:880:	if  ( p  <  p_end )
83:881:	   {
83:882:		__process_explode_options ( return_value, index, p, ( int ) ( p_end - p ), 
83:883:					extra_args [ EXTRA_ARG_OPTIONS ], extra_args [ EXTRA_ARG_LEFT ], extra_args [ EXTRA_ARG_RIGHT ], 
83:884:					extra_args [ EXTRA_ARG_CALLBACK ] TSRMLS_CC ) ;
83:885:	    }
83:886:	    
83:887:	/* Free allocated resources */
83:888:	thrak_free_array_to_char ( separator_buffer ) ;
83:889:	
83:890:	if  ( argc )
83:891:		efree ( argv ) ;
83:892:    }
83:893:
83:894:    
83:895:/* Process current value for string_implode() */
83:896:static zend_always_inline void	__process_implode_options ( int 		index,
83:897:							    char *  		value, 
83:898:							    int  		value_length, 
83:899:							    zval *  		options_zval, 
83:900:							    zval *  		left_string, 
83:901:							    zval *  		right_string, 
83:902:							    zval *  		callback,
83:903:							    char **		output_value,
83:904:							    int *		output_value_length,
83:905:							    int * 		duplicate 
83:906:							    TSRMLS_DC )
83:907:   {
83:908:	/* Process the options to apply on the current value */
83:909:	__process_options ( index, value, value_length, options_zval, left_string, right_string, callback,
83:910:				output_value, output_value_length, duplicate TSRMLS_CC ) ;
83:911:    }    
83:912:    
83:913:
83:914:/* Holds information about a processed item */
83:915:typedef struct  processed_item
83:916:   {
83:917:	char *		value ;			/* Value 									*/
83:918:	int 		value_length ;		/* Value length 								*/
83:919:	int 		needs_duplicate ;	/* = 1 when value points to an original buffer and has not been strdup'ed 	*/
83:920:    }  processed_item ;
83:921:    
83:922:PHP_FUNCTION ( string_implode )
83:923:   {
83:924:	char * 			separator_value ;				/* Parameter values 								*/
83:925:	int 			separator_length ;
83:926:	zval * 			array ;
83:927:	zval ***		argv ;
83:928:	int 			argc 			=  0 ;
83:929:	zval *			extra_args [ EXTRA_ARG_COUNT ] ;		/* Extra args, in the following order : left, right, options and callback 	*/
83:930:	char * 			callback_name ;
83:931:	char * 			return_buffer 		=  NULL ;		/* Return value ; reallocated upon temp buffer overflows 			*/
83:932:	char * 			p ;
83:933:	processed_item *	processed_items ;				/* Processed input items							*/
83:934:	int  			processed_item_count ;
83:935:	int  			total_size 		=  0 ;			/* Total processed items size 							*/
83:936:	int 			i ;
83:937:	int  			index 			=  0 ;
83:938:	HashTable *		array_hash ;					/* Used for looping through the array of strings to be imploded 		*/
83:939:	zval ** 		item ;
83:940:
83:941:	     
83:942:
83:943:	/* Parse parameters */
83:944:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "sa*", & separator_value, & separator_length, & array, & argv, & argc )  ==  FAILURE )
83:945:		RETURN_FALSE ;
83:946:	
83:947:	if  ( argc  >  4 )
83:948:	   {
83:949:		php_error_docref ( NULL TSRMLS_CC, E_ERROR, "string_implode() expects at most 6 arguments, %d provided", argc + 2 ) ;
83:950:		efree ( argv ) ;
83:951:			
83:952:		RETURN_FALSE ;
83:953:	    }
83:954:	    
83:955:	/* Collect extra arguments from argv[] and reorder them into extra_args */
83:956:	memset ( extra_args, 0, sizeof ( extra_args ) ) ;
83:957:
83:958:	for  ( i = 0 ; i  <  argc ; i ++ )
83:959:	   {
83:960:		switch ( Z_TYPE_P ( * argv [i] ) )
83:961:		   {
83:962:			/* Forbidden value types */
83:963:			case 	IS_RESOURCE :
83:964:				php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect resource data type for parameter #%d", i + 3 ) ;
83:965:				efree ( argv ) ;
83:966:					
83:967:				RETURN_FALSE ;
83:968:
83:969:			case 	IS_ARRAY :
83:970:				if  ( extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL  ||  zend_hash_num_elements ( Z_ARRVAL_P ( * argv [i] ) )  !=  2 )
83:971:				   {
83:972:					php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect array data type for parameter #%d", i + 3 ) ;
83:973:					efree ( argv ) ;
83:974:						
83:975:					RETURN_FALSE ;
83:976:				    }
83:977:				    
83:978:				extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:979:				break ;
83:980:			
83:981:			/* If an object is specified, it must be a closure */
83:982:			case  	IS_OBJECT :
83:983:				callback_name 	=  NULL ;
83:984:				
83:985:				if  ( ! zend_is_callable ( * argv [i], 0, & callback_name TSRMLS_CC )  ||  extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL )
83:986:				   {
83:987:					php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect object data type for parameter #%d", i + 3 ) ;
83:988:					
83:989:					if  ( callback_name  !=  NULL )
83:990:						efree ( callback_name ) ;
83:991:						
83:992:					efree ( argv ) ;
83:993:						
83:994:					RETURN_FALSE ;
83:995:				    }
83:996:
83:997:				if  ( callback_name  !=  NULL )
83:998:					efree ( callback_name ) ;
83:999:				   
83:1000:				extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:1001:				break ;
83:1002:			
83:1003:			/* A long is reserved for the $options parameter */
83:1004:			case 	IS_LONG :
83:1005:				if  ( extra_args [ EXTRA_ARG_OPTIONS ]  ==  NULL )
83:1006:				   {
83:1007:					extra_args [ EXTRA_ARG_OPTIONS ]	=  * argv [i] ;
83:1008:					break ;
83:1009:				    }
83:1010:				/* Break intentionnally missing to fall through the next case */
83:1011:				
83:1012:			/* All other types are for either $left, $right or $callback (when specified as a string) */
83:1013:			case 	IS_BOOL :
83:1014:			case 	IS_DOUBLE :
83:1015:			case 	IS_STRING :
83:1016:				convert_to_string_ex ( argv [i] ) ;
83:1017:				
83:1018:				if  ( extra_args [ EXTRA_ARG_LEFT ]  !=  NULL )
83:1019:				   {
83:1020:					if ( extra_args [ EXTRA_ARG_RIGHT ]  !=  NULL )
83:1021:					   {
83:1022:						if  ( extra_args [ EXTRA_ARG_CALLBACK ]  !=  NULL )
83:1023:						   {
83:1024:							php_error_docref ( NULL TSRMLS_CC, E_ERROR, "incorrect data type for parameter #%d", i + 3 ) ;
83:1025:							efree ( argv ) ;
83:1026:								
83:1027:							RETURN_FALSE ;
83:1028:						    }
83:1029:						else
83:1030:							extra_args [ EXTRA_ARG_CALLBACK ] 	=  * argv [i] ;
83:1031:					    }
83:1032:					else
83:1033:						extra_args [ EXTRA_ARG_RIGHT ] 	=  * argv [i] ;
83:1034:				    }
83:1035:				else
83:1036:					extra_args [ EXTRA_ARG_LEFT ] 	=  * argv [i] ;
83:1037:				break ;
83:1038:		    }
83:1039:	    }
83:1040:
83:1041:	/* Allocate an array for the input array items after they have been processed */
83:1042:	array_hash 		=  Z_ARRVAL_P ( array ) ;
83:1043:	processed_item_count	=  zend_hash_num_elements ( array_hash ) ;
83:1044:	
83:1045:	if  ( ! processed_item_count )
83:1046:	   {
83:1047:		if  ( argc )
83:1048:			efree ( argv ) ;
83:1049:			
83:1050:		RETURN_BOOL ( 0 ) ;
83:1051:	    }
83:1052:	    
83:1053:	processed_items 	=  emalloc ( sizeof ( processed_item ) * processed_item_count ) ;
83:1054:	
83:1055:	if  ( processed_items  ==  NULL )
83:1056:	   {
83:1057:		if  ( argc )
83:1058:			efree ( argv ) ;
83:1059:			
83:1060:		RETURN_BOOL ( 0 ) ;
83:1061:	    }
83:1062:	
83:1063:	/* Loop through input array to be imploded */
83:1064:	for  ( zend_hash_internal_pointer_reset ( array_hash ) ; 
83:1065:			zend_hash_get_current_data ( array_hash, ( void ** ) & item )  ==  SUCCESS ; 
83:1066:			zend_hash_move_forward ( array_hash ) ) 
83:1067:	   {
83:1068:		/* Systematically convert value to string */
83:1069:		convert_to_string_ex ( item ) ;
83:1070:		
83:1071:		/* Process implode options for this value */
83:1072:		__process_implode_options ( index, Z_STRVAL_PP ( item ), Z_STRLEN_PP ( item ),
83:1073:					extra_args [ EXTRA_ARG_OPTIONS ], extra_args [ EXTRA_ARG_LEFT ], extra_args [ EXTRA_ARG_RIGHT ], 
83:1074:					extra_args [ EXTRA_ARG_CALLBACK ],
83:1075:					& processed_items [ index ]. value, & processed_items [ index ]. value_length, & processed_items [ index ]. needs_duplicate
83:1076:					TSRMLS_CC ) ;
83:1077:
83:1078:		total_size 	+=  processed_items [ index ]. value_length ;
83:1079:		index ++ ;
83:1080:	    }
83:1081:	    
83:1082:	/* Allocate buffer for the return value (concatenation of all the processed items) */
83:1083:	return_buffer 	=  emalloc ( total_size ) ;
83:1084:	
83:1085:	if  ( return_buffer  ==  NULL )
83:1086:	   {
83:1087:		RETVAL_FALSE ;
83:1088:		goto  FreeResources ;
83:1089:	    }
83:1090:	    
83:1091:	/* Catenate the processed items */
83:1092:	p	=  return_buffer ;
83:1093:	
83:1094:	for  ( i = 0 ; i  <  processed_item_count ; i ++ )
83:1095:	   {
83:1096:		memcpy ( p, processed_items [i]. value, processed_items [i]. value_length ) ;
83:1097:		p += processed_items [i]. value_length ;
83:1098:	    }
83:1099:	    
83:1100:	RETVAL_STRINGL ( return_buffer, total_size, 0 ) ;
83:1101:	    
83:1102:	/* Free allocated resources */
83:1103:FreeResources :
83:1104:	for  ( i = 0 ;  i  <  processed_item_count ; i ++ )
83:1105:	   {
83:1106:		if  ( ! processed_items [i]. needs_duplicate )
83:1107:			efree ( processed_items [i]. value ) ;
83:1108:	    }
83:1109:	    
83:1110:	efree ( processed_items ) ;
83:1111:	
83:1112:	if  ( argc )
83:1113:		efree ( argv ) ;
83:1114:    }
83:1115:    
83:1116: 
83:1117:/*===========================================================================================================
83:1118:
83:1119:    NAME
83:1120:	string_startswith - Checks if a string starts with another string.
83:1121:	
83:1122:    PROTOTYPE
83:1123:	$bool 	=  string_startswith ( $value, $prefix, $case_insensitive = false ) ;
83:1124:	
83:1125:    DESCRIPTION
83:1126:	Checks if the specified string starts with the specified prefix.
83:1127:	The case_insensitive parameter determines whether comparison should be case-sensitive or not.
83:1128:	
83:1129:    PARAMETERS
83:1130:	$value (string) -
83:1131:		String to be checked.
83:1132:		
83:1133:	$prefix (string) -
83:1134:		String to be compared with the start of $value.
83:1135:		
83:1136:	$case_insensitive (boolean) -
83:1137:		When true, comparison is case-insensitive.
83:1138:		
83:1139: *===========================================================================================================*/
83:1140:THRAK_API zend_bool 	internal_string_startswith  ( const char *  value, int  value_length, const char *  prefix, int  prefix_length, int  case_insensitive )
83:1141:   {
83:1142:	zend_bool 	status 		=  0 ;
83:1143:	int 		( *cmpfunc ) ( const char *  a, const char *  b, size_t  count )	=  ( case_insensitive ) ? strnicmp : strncmp ;
83:1144:	
83:1145:	
83:1146:	if  ( prefix_length  <=  value_length )
83:1147:		status 	 =  ( * cmpfunc ) ( value, prefix, prefix_length ) ?  0 : 1 ;
83:1148:	    
83:1149:	return ( status ) ;
83:1150:    }
83:1151:
83:1152:    
83:1153:PHP_FUNCTION(string_startswith)
83:1154:   {
83:1155:	char *		value ;
83:1156:	int 		value_length ;
83:1157:	char *		suffix ;
83:1158:	int 		suffix_length ;
83:1159:	int 		case_insensitive 	=  0 ;
83:1160:	
83:1161:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "ss|b", &value, &value_length, &suffix, &suffix_length, &case_insensitive )  ==  FAILURE )
83:1162:		return ;
83:1163:	
83:1164:	RETURN_BOOL ( internal_string_startswith ( value, value_length, suffix, suffix_length, case_insensitive ) ) ;
83:1165:   }
83:1166:
83:1167:    
83:1168:
83:1169:/*===========================================================================================================
83:1170:
83:1171:    NAME
83:1172:	string_setbos - Prepends a prefix to a string if it does not exist.
83:1173:	
83:1174:    PROTOTYPE
83:1175:	$bool 	=  string_setbos ( &$value, $prefix, [ $case_insensitive = false, [ $return_value = false ] ] ) ;
83:1176:	
83:1177:    DESCRIPTION
83:1178:	Prepends the $prefix string to $value if not already present.
83:1179:	
83:1180:    PARAMETERS
83:1181:	$value (string) -
83:1182:		String to be checked.
83:1183:		
83:1184:	$prefix (string) -
83:1185:		String to be prepended to $value if $value does not start with that string.
83:1186:		
83:1187:	$case_insensitive (boolean) -
83:1188:		When true, comparison is case-insensitive.
83:1189:		
83:1190:	$return_value (boolean) -
83:1191:		When true, the new value is returned and $value is left as is.
83:1192:		When false, $value is modified in-place.
83:1193:		
83:1194:    RETURN VALUE
83:1195:	When the $return_value parameter is false, returns true if operation succeeded or false otherwise.
83:1196:	When $return_value is true, returns either the new string or false if operation failed or no update
83:1197:	was performed.
83:1198:		
83:1199: *===========================================================================================================*/
83:1200:THRAK_API zend_bool 	internal_string_setbos  (  char *  		value, 
83:1201:						  int  			value_length, 
83:1202:						  char *  		prefix, 
83:1203:						  int  			prefix_length, 
83:1204:						  zend_bool  		case_insensitive, 
83:1205:						  char **  		result, 
83:1206:						  int *  		result_length, 
83:1207:						  zend_bool *  		modified )
83:1208:   {
83:1209:	int 		( * cmpfunc ) ( const char *  a, const char *  b, size_t  count ) ;
83:1210:	char * 		p ;
83:1211:	
83:1212:	
83:1213:	/* If input string or prefix is empty, or prefix length is greater than input string length, then we have nothing to do */
83:1214:	if  ( ! value_length  ||  ! prefix_length )
83:1215:	   {
83:1216:		* result 		=  value ;
83:1217:		* result_length 	=  value_length ;
83:1218:		* modified 		=  0 ;
83:1219:		
83:1220:		return ( 1 ) ;
83:1221:	    }
83:1222:	    
83:1223:	/* Compare function and comparison start in input string */
83:1224:	cmpfunc 	=  ( case_insensitive ) ?  strnicmp : strncmp ;
83:1225:	
83:1226:	/* If input string ends with the supplied prefix, then we have nothing to do */
83:1227:	if  ( prefix_length  <=  value_length  &&  ! cmpfunc ( value, prefix, prefix_length ) )
83:1228:	   {
83:1229:		* result 		=  value ;
83:1230:		* result_length 	=  value_length ;
83:1231:		* modified 		=  0 ;
83:1232:		
83:1233:		return ( 1 ) ;
83:1234:	    }
83:1235:	
83:1236:	/* Input string does not end with the specified prefix : allocate enough room to append it */
83:1237:	p		=  emalloc ( value_length + prefix_length ) ;
83:1238:	
83:1239:	if  ( p  ==  NULL )
83:1240:		return ( 0 ) ;
83:1241:		
83:1242:	strncpy ( p, prefix, prefix_length ) ;
83:1243:	strncpy ( p + prefix_length, value, value_length ) ;
83:1244:	
83:1245:	/* Tell the caller about the new string and the fact that we modified the initial string and an malloc() took place */
83:1246:	* result 		=  p ;
83:1247:	* result_length 	=  value_length + prefix_length ;
83:1248:	* modified 		=  1 ;
83:1249:	
83:1250:	/* All done, report everything is ok */
83:1251:	return ( 1 ) ;
83:1252:    }
83:1253:
83:1254:    
83:1255:PHP_FUNCTION(string_setbos)
83:1256:   {
83:1257:	zval * 		z_value ;
83:1258:	char *		value ;
83:1259:	int 		value_length ;
83:1260:	char *		prefix ;
83:1261:	int 		prefix_length ;
83:1262:	char *		new_value ;
83:1263:	int 		new_value_length ;
83:1264:	zend_bool	case_insensitive 	=  0 ;
83:1265:	zend_bool 	retval	 		=  0 ;
83:1266:	zend_bool 	modified ;
83:1267:	
83:1268:	
83:1269:	/* Get parameters */
83:1270:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zs|bb", & z_value, & prefix, & prefix_length, & case_insensitive, & retval )  ==  FAILURE )
83:1271:		return ;
83:1272:
83:1273:	// First arg must be a string
83:1274:	if  ( Z_TYPE_P ( z_value )  !=  IS_STRING )
83:1275:		convert_to_string ( z_value ) ;
83:1276:		
83:1277:	value 		=  Z_STRVAL_P ( z_value ) ;
83:1278:	value_length	=  Z_STRLEN_P ( z_value ) ;
83:1279:		
83:1280:	// Check input string and prefix lengths */
83:1281:	if  ( ! value_length )
83:1282:	   {
83:1283:		/* If $return_value = true, return a copy of the input string */
83:1284:		if  ( retval )
83:1285:		   {
83:1286:			RETURN_STRINGL ( value, value_length, 1 ) ;
83:1287:		    }
83:1288:		/* Otherwise, leave the input string as is */
83:1289:		else
83:1290:			RETURN_FALSE ;
83:1291:	    }
83:1292:	    
83:1293:	/* The same case happens when the prefix string is empty */
83:1294:	if  ( ! prefix_length )
83:1295:	   {
83:1296:		if  ( retval )
83:1297:		   {
83:1298:			RETURN_STRINGL ( value, value_length, 1 ) ;
83:1299:		    }
83:1300:		else
83:1301:			RETURN_FALSE ;
83:1302:	    }
83:1303:	    
83:1304:	    
83:1305:	/* Perform the prefix appending */
83:1306:	if  ( internal_string_setbos ( value, value_length, prefix, prefix_length, case_insensitive, & new_value, & new_value_length, & modified ) )
83:1307:	   {
83:1308:		/* If we need to return a value instead of modifying the supplied input value in-place... */
83:1309:		if (  retval )
83:1310:		   {
83:1311:			/* ... if the string was modified, then internal_string_seteos() returned a newly malloc'ed strings, so no need to duplicate it */
83:1312:			if  ( modified )
83:1313:			   {
83:1314:				RETURN_STRINGL ( new_value, new_value_length, 0 ) ;
83:1315:			    }
83:1316:			/* Otherwise, the original value was returned so we do need to duplicate it */
83:1317:			else
83:1318:			   {
83:1319:				RETURN_STRINGL ( new_value, new_value_length, 1 ) ;
83:1320:			    }
83:1321:		    }
83:1322:		/* Otherwise, we need to perform an in-place modification of the supplied input value */
83:1323:		else
83:1324:		   {
83:1325:			/* ... but only if the string was modified (ie, the prefix was appended to the original value) */
83:1326:			if (  modified )
83:1327:			   {
83:1328:				zval_dtor ( z_value ) ;
83:1329:				ZVAL_STRINGL ( z_value, new_value, new_value_length, 0 ) ;
83:1330:			    }
83:1331:			    
83:1332:			RETURN_TRUE ;
83:1333:		    }
83:1334:	    }
83:1335:	/* Something bad happened in internal_string_seteos(), such as memory allocation error */
83:1336:	else
83:1337:		RETURN_FALSE ;
83:1338:   }
83:1339:
83:1340:   
83:1341:   
83:1342:/*===========================================================================================================
83:1343:
83:1344:    NAME
83:1345:	string_seteos - Appends a suffix to a string if it does not exist.
83:1346:	
83:1347:    PROTOTYPE
83:1348:	$bool 	=  string_seteos ( &$value, $suffix, [ $case_insensitive = false, [ $return_value = false ] ] ) ;
83:1349:	
83:1350:    DESCRIPTION
83:1351:	Adds the $suffix string to $value if not already present.
83:1352:	
83:1353:    PARAMETERS
83:1354:	$value (string) -
83:1355:		String to be checked.
83:1356:		
83:1357:	$suffix (string) -
83:1358:		String to be appended to $value if $value does not end with that string.
83:1359:		
83:1360:	$case_insensitive (boolean) -
83:1361:		When true, comparison is case-insensitive.
83:1362:		
83:1363:	$return_value (boolean) -
83:1364:		When true, the new value is returned and $value is left as is.
83:1365:		When false, $value is modified in-place.
83:1366:		
83:1367:    RETURN VALUE
83:1368:	When the $return_value parameter is false, returns true if operation succeeded or false otherwise.
83:1369:	When $return_value is true, returns either the new string or false if operation failed or no update
83:1370:	was performed.
83:1371:		
83:1372: *===========================================================================================================*/
83:1373:THRAK_API zend_bool 	internal_string_seteos  (  char *  		value, 
83:1374:						  int  			value_length, 
83:1375:						  char *  		suffix, 
83:1376:						  int  			suffix_length, 
83:1377:						  zend_bool  		case_insensitive, 
83:1378:						  char **  		result, 
83:1379:						  int *  		result_length, 
83:1380:						  zend_bool *  		modified )
83:1381:   {
83:1382:	int 		( * cmpfunc ) ( const char *  a, const char *  b, size_t  count ) ;
83:1383:	char * 		p ;
83:1384:	
83:1385:	
83:1386:	/* If input string or suffix is empty */
83:1387:	if  ( ! value_length  ||  ! suffix_length  )
83:1388:	   {
83:1389:		* result 		=  value ;
83:1390:		* result_length 	=  value_length ;
83:1391:		* modified 		=  0 ;
83:1392:		
83:1393:		return ( 1 ) ;
83:1394:	    }
83:1395:	    
83:1396:	/* Compare function and comparison start in input string */
83:1397:	cmpfunc 	=  ( case_insensitive ) ?  strnicmp : strncmp ;
83:1398:	p 		=  value + max ( value_length - suffix_length, 0 ) ;
83:1399:	
83:1400:	/* If input string ends with the supplied suffix, then we have nothing to do */
83:1401:	if  ( suffix_length  <=  value_length  &&  ! cmpfunc ( p, suffix, suffix_length ) )
83:1402:	   {
83:1403:		* result 		=  value ;
83:1404:		* result_length 	=  value_length ;
83:1405:		* modified 		=  0 ;
83:1406:		
83:1407:		return ( 1 ) ;
83:1408:	    }
83:1409:	
83:1410:	/* Input string does not end with the specified suffix : allocate enough room to append it */
83:1411:	p		=  emalloc ( value_length + suffix_length ) ;
83:1412:	
83:1413:	if  ( p  ==  NULL )
83:1414:		return ( 0 ) ;
83:1415:		
83:1416:	strncpy ( p, value, value_length ) ;
83:1417:	strncpy ( p + value_length, suffix, suffix_length ) ;
83:1418:	
83:1419:	/* Tell the caller about the new string and the fact that we modified the initial string and an malloc() took place */
83:1420:	* result 		=  p ;
83:1421:	* result_length 	=  value_length + suffix_length ;
83:1422:	* modified 		=  1 ;
83:1423:	
83:1424:	/* All done, report everything is ok */
83:1425:	return ( 1 ) ;
83:1426:    }
83:1427:
83:1428:    
83:1429:PHP_FUNCTION(string_seteos)
83:1430:   {
83:1431:	zval * 		z_value ;
83:1432:	char *		value ;
83:1433:	int 		value_length ;
83:1434:	char *		suffix ;
83:1435:	int 		suffix_length ;
83:1436:	char *		new_value ;
83:1437:	int 		new_value_length ;
83:1438:	zend_bool	case_insensitive 	=  0 ;
83:1439:	zend_bool 	retval	 		=  0 ;
83:1440:	zend_bool 	modified ;
83:1441:	
83:1442:	
83:1443:	/* Get parameters */
83:1444:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zs|bb", & z_value, & suffix, & suffix_length, & case_insensitive, & retval )  ==  FAILURE )
83:1445:		return ;
83:1446:
83:1447:	// First arg must be a string
83:1448:	if  ( Z_TYPE_P ( z_value )  !=  IS_STRING )
83:1449:		convert_to_string ( z_value ) ;
83:1450:		
83:1451:	value 		=  Z_STRVAL_P ( z_value ) ;
83:1452:	value_length	=  Z_STRLEN_P ( z_value ) ;
83:1453:		
83:1454:	// Check input string and suffix lengths */
83:1455:	if  ( ! value_length )
83:1456:	   {
83:1457:		/* If $return_value = true, return a copy of the input string */
83:1458:		if  ( retval )
83:1459:		   {
83:1460:			RETURN_STRINGL ( value, value_length, 1 ) ;
83:1461:		    }
83:1462:		/* Otherwise, leave the input string as is */
83:1463:		else
83:1464:			RETURN_FALSE ;
83:1465:	    }
83:1466:	    
83:1467:	/* the same case happens when the suffix string is empty */
83:1468:	if  ( ! suffix_length )
83:1469:	   {
83:1470:		if  ( retval )
83:1471:		   {
83:1472:			RETURN_STRINGL ( value, value_length, 1 ) ;
83:1473:		    }
83:1474:		else
83:1475:			RETURN_FALSE ;
83:1476:	    }
83:1477:	    
83:1478:	/* Perform the suffix appending */
83:1479:	if  ( internal_string_seteos ( value, value_length, suffix, suffix_length, case_insensitive, & new_value, & new_value_length, & modified ) )
83:1480:	   {
83:1481:		/* If we need to return a value instead of modifying the supplied input value in-place... */
83:1482:		if (  retval )
83:1483:		   {
83:1484:			/* ... if the string was modified, then internal_string_seteos() returned a newly malloc'ed strings, so no need to duplicate it */
83:1485:			if  ( modified )
83:1486:			   {
83:1487:				RETURN_STRINGL ( new_value, new_value_length, 0 ) ;
83:1488:			    }
83:1489:			/* Otherwise, the original value was returned so we do need to duplicate it */
83:1490:			else
83:1491:			   {
83:1492:				RETURN_STRINGL ( new_value, new_value_length, 1 ) ;
83:1493:			    }
83:1494:		    }
83:1495:		/* Otherwise, we need to perform an in-place modification of the supplied input value */
83:1496:		else
83:1497:		   {
83:1498:			/* ... but only if the string was modified (ie, the suffix was appended to the original value) */
83:1499:			if (  modified )
83:1500:			   {
83:1501:				zval_dtor ( z_value ) ;
83:1502:				ZVAL_STRINGL ( z_value, new_value, new_value_length, 0 ) ;
83:1503:			    }
83:1504:			    
83:1505:			RETURN_TRUE ;
83:1506:		    }
83:1507:	    }
83:1508:	/* Something bad happened in internal_string_seteos(), such as memory allocation error */
83:1509:	else
83:1510:		RETURN_FALSE ;
83:1511:   }
83:1512:
83:1513:    
83:1514:   84:1:/************************************************************************************************************
84:2:
84:3:    NAME
84:4:	string.h
84:5:	
84:6:    DESCRIPTION
84:7:	Definitions for string-related functions.
84:8:	
84:9:    AUTHOR
84:10:	Christian Vigh, 11/2014.
84:11:	
84:12:    HISTORY 
84:13:	tbd
84:14:
84:15: ************************************************************************************************************/
84:16:# ifndef 	__STRING_H__
84:17:# 	define	__STRING_H__
84:18:
84:19:language_block ( C ) ;
84:20:
84:21:
84:22:/*-----------------------------------------------------------------------------------------------------------
84:23:	
84:24:	Macros & constants.
84:25:	
84:26: *-----------------------------------------------------------------------------------------------------------*/
84:27:
84:28:/* Implode / explode constants */
84:29:# define 	UNESCAPE_FLAG						0x80000000
84:30:
84:31:# define 	EXPLODE_NONE 						0x00000000
84:32:# define 	EXPLODE_TRIM_LEFT 					0x00000001
84:33:# define 	EXPLODE_TRIM_RIGHT 					0x00000002
84:34:# define 	EXPLODE_TRIM						( EXPLODE_TRIM_LEFT | EXPLODE_TRIM_RIGHT )
84:35:# define 	EXPLODE_ESCAPE_QUOTES 					0x00000004
84:36:# define 	EXPLODE_ESCAPE_DOUBLEQUOTES 				0x00000008
84:37:# define 	EXPLODE_NOCASE	 					0x00000010
84:38:# define 	EXPLODE_IGNORE_EMPTY 					0x00000020
84:39:# define 	EXPLODE_TOLOWER 					0x00000040
84:40:# define 	EXPLODE_TOUPPER 					0x000000C0
84:41:# define 	EXPLODE_UCFIRST 					0x00000100
84:42:# define 	EXPLODE_UCWORDS						0x00000200
84:43:# define 	EXPLODE_UNESCAPE_QUOTES 				( EXPLODE_ESCAPE_QUOTES | UNESCAPE_FLAG )
84:44:# define 	EXPLODE_UNESCAPE_DOUBLEQUOTES 				( EXPLODE_ESCAPE_DOUBLEQUOTES | UNESCAPE_FLAG )
84:45:
84:46:
84:47:# define 	IMPLODE_NONE 						EXPLODE_NONE
84:48:# define 	IMPLODE_TRIM_LEFT 					EXPLODE_TRIM_LEFT
84:49:# define 	IMPLODE_TRIM_RIGHT 					EXPLODE_TRIM_RIGHT
84:50:# define 	IMPLODE_TRIM						EXPLODE_TRIM
84:51:# define 	IMPLODE_ESCAPE_QUOTES 					EXPLODE_ESCAPE_QUOTES
84:52:# define 	IMPLODE_ESCAPE_DOUBLEQUOTES 				EXPLODE_ESCAPE_DOUBLEQUOTES
84:53:# define 	IMPLODE_NOCASE		 				EXPLODE_NOCASE
84:54:# define 	IMPLODE_IGNORE_EMPTY					EXPLODE_IGNORE_EMPTY
84:55:# define 	IMPLODE_TOLOWER 					EXPLODE_TOLOWER
84:56:# define 	IMPLODE_TOUPPER 					EXPLODE_TOUPPER
84:57:# define 	IMPLODE_UCFIRST 					EXPLODE_UCFIRST
84:58:# define 	IMPLODE_UCWORDS						EXPLODE_UCWORDS
84:59:# define 	IMPLODE_UNESCAPE_QUOTES 				( IMPLODE_ESCAPE_QUOTES | UNESCAPE_FLAG )
84:60:# define 	IMPLODE_UNESCAPE_DOUBLEQUOTES 				( IMPLODE_ESCAPE_DOUBLEQUOTES | UNESCAPE_FLAG )
84:61:
84:62: 
84:63:/*-----------------------------------------------------------------------------------------------------------
84:64:
84:65:	External functions.
84:66:	
84:67: *-----------------------------------------------------------------------------------------------------------*/
84:68:extern 				PHP_FUNCTION ( string_atoi ) ;
84:69:
84:70:extern 				PHP_FUNCTION ( string_append ) ;
84:71:extern THRAK_API zend_bool	internal_string_append 			( zval * 		z_string,
84:72:									  int  			argc, 
84:73:									  zval **		argv,
84:74:									  char ** 		result,
84:75:									  int * 		result_length ) ;
84:76:
84:77:extern 				PHP_FUNCTION ( string_endswith ) ;
84:78:extern THRAK_API zend_bool	internal_string_endswith 		( const char *		value,
84:79:									  int  			value_length,
84:80:									  const char * 		suffix,
84:81:									  int 			suffix_length,
84:82:									  int 			case_insensitive ) ;
84:83:
84:84:extern 				PHP_FUNCTION ( string_explode ) ;
84:85:extern THRAK_API zend_bool	internal_string_explode 		( zval *		separator,
84:86:									  char *		value,
84:87:									  int 			value_length,
84:88:									  zval *		left_string,
84:89:									  zval *		right_string,
84:90:									  int 			options,
84:91:									  zval *		return_value
84:92:									  TSRMLS_DC ) ;
84:93:									  
84:94:extern 				PHP_FUNCTION ( string_implode ) ;
84:95:extern THRAK_API zend_bool	internal_string_implode 		( zval *		separator,
84:96:									  char *		value,
84:97:									  int 			value_length,
84:98:									  zval *		left_string,
84:99:									  zval *		right_string,
84:100:									  int 			options,
84:101:									  zval *		return_value
84:102:									  TSRMLS_DC ) ;
84:103:									  
84:104:extern 				PHP_FUNCTION ( string_setbos ) ;
84:105:extern THRAK_API zend_bool 	internal_string_setbos			( char *  		value, 
84:106:									  int  			value_length, 
84:107:									  char *  		prefix, 
84:108:									  int  			prefix_length, 
84:109:									  zend_bool 		case_insensitive,
84:110:									  char **  		result, 
84:111:									  int *  		result_length,
84:112:									  zend_bool *		modified ) ;
84:113:
84:114:extern 				PHP_FUNCTION ( string_startswith ) ;
84:115:extern THRAK_API zend_bool	internal_string_startswith 		( const char *		value,
84:116:									  int  			value_length,
84:117:									  const char * 		preffix,
84:118:									  int 			prefix_length,
84:119:									  int 			case_insensitive ) ;
84:120:									  
84:121:extern 				PHP_FUNCTION ( string_seteos ) ;
84:122:extern THRAK_API zend_bool 	internal_string_seteos			( char *  		value, 
84:123:									  int  			value_length, 
84:124:									  char *  		suffix, 
84:125:									  int  			suffix_length, 
84:126:									  zend_bool 		case_insensitive,
84:127:									  char **  		result, 
84:128:									  int *  		result_length,
84:129:									  zend_bool *		modified ) ;
84:130:
84:131:extern void 		string_initialize				( THRAK_INIT_FUNC_ARGS ) ;
84:132:extern void 		string_shutdown					( THRAK_SHUTDOWN_FUNC_ARGS ) ;
84:133:
84:134:
84:135:end_language_block ( C ) ;
84:136:
84:137:# endif		/* __STRING_H__  */85:1:/************************************************************************************************************
85:2:
85:3:    NAME
85:4:	string_helpers.c
85:5:	
85:6:    DESCRIPTION
85:7:	Helper functions for string manipulations.
85:8:	
85:9:    AUTHOR
85:10:	Christian Vigh, 11/2014.
85:11:	
85:12:    HISTORY 
85:13:	tbd
85:14:
85:15: ************************************************************************************************************/
85:16:# include 	"thrak.h"
85:17:# include 	<ctype.h>
85:18:# include 	<math.h>
85:19:
85:20:
85:21:
85:22:/*===========================================================================================================
85:23:
85:24:    thrak_atoi - 
85:25:	Extended atoi implementation. The output_position parameter can be null.
85:26:	When escape_only is non-zero, a leading sign is forbidden and the value cannot exceed 255.
85:27:	
85:28: *===========================================================================================================*/
85:29:THRAK_API zend_bool 	thrak_atoi ( char *  input_value, char **  output_position, int64 *  output_value, int  escape_only )
85:30:   {
85:31:	char *		p 		=  input_value ;		/* Pointer to current char of input value 		*/
85:32:	int 		sign 		=  0 ;				/* Sign (0 = unspecified) 				*/
85:33:	int 		base 		=  10 ;				/* Conversion base 					*/
85:34:	int64		value 		=  0 ;				/* Current conversion value 				*/
85:35:	int 		digit_count 	=  0 ;				/* Number of digits processed (0 = conversion error)	*/
85:36:	
85:37:	
85:38:	/* Allow leading sign only for real integers, not escape sequences */
85:39:	if  ( ! escape_only )
85:40:	   {
85:41:		/* Facility : ignore leading spaces */
85:42:		while  ( * p  &&  isspace ( * p ) )
85:43:			p ++ ;
85:44:	
85:45:		/* If a sign is present, remember it */
85:46:		if  ( * p  ==  '-' )
85:47:			sign = -1, p ++ ;
85:48:		else if  ( * p  ==  '+' ) 
85:49:			p ++, sign = 1 ;
85:50:			
85:51:		/* Facility II : ignore spaces between sign and first digits */
85:52:		while  ( * p  &&  isspace ( * p ) )
85:53:			p ++ ;
85:54:	    }
85:55:	
85:56:	/* If a number starts with zero, it may be specified in octal... */
85:57:	if  ( * p  ==  '0' )
85:58:	   {
85:59:		base 		=  8 ;
85:60:		p ++ ;
85:61:	    }
85:62:	    
85:63:	/* ... unless the character following is a base specifier */
85:64:	switch  ( tolower ( * p ) )
85:65:	   {
85:66:		case 	'b' :
85:67:			base 		 =  2 ;
85:68:			p ++ ;
85:69:			break ;
85:70:			
85:71:		case 	'o' :
85:72:			base 		 =  8 ;
85:73:			p ++ ;
85:74:			break ;
85:75:			
85:76:		case 	'd' :
85:77:			base 		 =  10 ;
85:78:			p ++ ;
85:79:			break ;
85:80:			
85:81:		case 	'x' :
85:82:			base 		 =  16 ;
85:83:			p ++ ;
85:84:			break ;
85:85:	    }
85:86:	    
85:87:	/* Loop through digits */
85:88:	while  ( isxdigit ( * p ) )
85:89:	   {
85:90:		char  		ch	=  ( * p  >  '9' ) ?  toupper ( * p ) - 'A' + 10 : * p - '0' ;
85:91:		int64  		tmpval ;
85:92:		
85:93:		/* Stop on first digit not belonging to the current base */
85:94:		if  ( ch  >=  base )
85:95:			break ;
85:96:		
85:97:		/* If we interpret an escaped character sequence, make sure we don't overflow */
85:98:		tmpval 	=  ( value * base ) + ch ;
85:99:		
85:100:		if  ( escape_only  &&  tmpval  >  255 )
85:101:			break ;
85:102:			
85:103:		/* Proceed with next character */
85:104:		value 	=  tmpval ;
85:105:		digit_count ++ ;
85:106:		p ++ ;
85:107:	    }
85:108:
85:109:	/* No digit found : signal a conversion error */
85:110:	if  ( ! digit_count )
85:111:	   {
85:112:		if  ( output_position  !=  NULL )
85:113:			* output_position 	=  input_value ;
85:114:	
85:115:		return ( 0 ) ;
85:116:	    }
85:117:	    
85:118:	/* If an output position pointer has been supplied, set it to the first character after the last digit */
85:119:	if  ( output_position  !=  NULL )
85:120:		* output_position	 =  p ;
85:121:	
85:122:	/* Don't forget the leading sign, if any */
85:123:	if  ( sign )
85:124:		value 	*=  sign ;
85:125:		
85:126:	/* All done, return */
85:127:	* output_value 	=  value ;
85:128:	return ( 1 ) ;
85:129:    }
85:130:    
85:131:
85:132:/*===========================================================================================================
85:133:
85:134:    thrak_strichr - 
85:135:	strichr() implementation for systems that don't support it/
85:136:	
85:137: *===========================================================================================================*/
85:138:THRAK_API char *  thrak_strichr ( const char *  p, int  ch )
85:139:   {
85:140:	ch 	=  toupper ( ch ) ;
85:141:	
85:142:	while  ( * p )
85:143:	   {
85:144:		if  ( toupper ( * p )  ==  ch )
85:145:			return ( ( char * ) p ) ;
85:146:			
85:147:		p ++ ;
85:148:	    }
85:149:	    
85:150:	return ( NULL ) ;
85:151:    }
85:152:    
85:153:    
85:154:/*===========================================================================================================
85:155:
85:156:    thrak_trim/ltrim/rtrim - 
85:157:	Trims a value. Puts the result in the "output" parameter if specified, or returns a newly
85:158:	allocated string.
85:159:	
85:160: *===========================================================================================================*/
85:161:static char *  __thrak_trim ( char *  p, int  mode, char *  output )
85:162:   {
85:163:	char * 		start 	=  p,
85:164:	     *		end 	=  p + strlen ( p ) - 1 ;
85:165:	long 		size ;
85:166:	     
85:167:	if  ( mode  &  1 )
85:168:	   {
85:169:		while  ( * start  &&  isspace ( * start ) )
85:170:			start ++ ;
85:171:	    }
85:172:	    
85:173:	    
85:174:	if  ( mode  &  2 )
85:175:	   {
85:176:		while  ( end  >  start  &&  isspace ( * end ) )
85:177:			end -- ;
85:178:	    }
85:179:	
85:180:	size 	=  ( long ) ( end - start + 1 ) ;
85:181:	
85:182:	if  ( output  !=  NULL )
85:183:	   {
85:184:		strncpy ( output, start, size ) ;
85:185:		* ( end + 1 )	=  '\0' ;
85:186:		
85:187:		return  ( output ) ;
85:188:	    }
85:189:	else
85:190:		return  ( estrndup ( start, size ) ) ;
85:191:    }
85:192:
85:193:THRAK_API char *  thrak_trim ( char *  p, char *  output )
85:194:   { return  ( __thrak_trim ( p, 0x03, output ) ) ; }
85:195:   
85:196:   
85:197:THRAK_API char *  thrak_ltrim ( char *  p, char *  output )
85:198:   { return  ( __thrak_trim ( p, 0x01, output ) ) ; }    
85:199:   
85:200:THRAK_API char *  thrak_rtrim ( char *  p, char *  output )
85:201:   { return  ( __thrak_trim ( p, 0x02, output ) ) ; }
85:202:   
85:203:86:1:/************************************************************************************************************
86:2:
86:3:    NAME
86:4:	string_statics.h
86:5:	
86:6:    DESCRIPTION
86:7:	Variables that must be initialized only once.
86:8:	
86:9:    AUTHOR
86:10:	Christian Vigh, 11/2014.
86:11:	
86:12:    HISTORY 
86:13:	tbd
86:14:
86:15: ************************************************************************************************************/
86:16:# ifndef 	__STRING_STATICS_H__
86:17:# 	define	__STRING_STATICS_H__
86:18:
86:19:language_block ( C ) ;
86:20:
86:21:/*-----------------------------------------------------------------------------------------------------------
86:22:
86:23:	Function arguments type information for data.c.
86:24:	
86:25: *-----------------------------------------------------------------------------------------------------------*/
86:26:/* string_atoi() */
86:27:THRAK_BEGIN_ARG_INFO_EX(string_atoi, 0, 0, 1)
86:28:	THRAK_BYVAL_ARG_INFO(value)
86:29:	THRAK_BYREF_ARG_INFO(end)
86:30:THRAK_END_ARG_INFO ;
86:31:
86:32:/* string_append() */
86:33:THRAK_BEGIN_ARG_INFO_EX(string_append, 0, 0, 2)
86:34:	THRAK_BYREF_ARG_INFO(value)
86:35:	THRAK_BYVAL_ARG_VARIADIC_INFO(args)
86:36:THRAK_END_ARG_INFO ;
86:37:
86:38:/* string_endswith() */
86:39:THRAK_BEGIN_ARG_INFO_EX(string_endswith, 0, 0, 2)
86:40:	THRAK_BYVAL_ARG_INFO(str)
86:41:	THRAK_BYVAL_ARG_INFO(suffix)
86:42:	THRAK_BYVAL_ARG_INFO(case_insensitive)
86:43:THRAK_END_ARG_INFO ;
86:44:
86:45:/* string_explode() */
86:46:THRAK_BEGIN_ARG_INFO_EX(string_explode, 0, 0, 2)
86:47:	THRAK_BYVAL_ARG_INFO(separator)
86:48:	THRAK_BYVAL_ARG_INFO(value)
86:49:	THRAK_BYVAL_ARG_INFO(left)
86:50:	THRAK_BYVAL_ARG_INFO(right)
86:51:	THRAK_BYVAL_ARG_INFO(option)
86:52:	THRAK_BYVAL_ARG_INFO(callback)
86:53:THRAK_END_ARG_INFO ;
86:54:
86:55:/* string_implode() */
86:56:THRAK_BEGIN_ARG_INFO_EX(string_implode, 0, 0, 2)
86:57:	THRAK_BYVAL_ARG_INFO(separator)
86:58:	THRAK_BYVAL_ARG_INFO(value)
86:59:	THRAK_BYVAL_ARG_INFO(left)
86:60:	THRAK_BYVAL_ARG_INFO(right)
86:61:	THRAK_BYVAL_ARG_INFO(option)
86:62:	THRAK_BYVAL_ARG_INFO(callback)
86:63:THRAK_END_ARG_INFO ;
86:64:
86:65:/* string_startswith() */
86:66:THRAK_BEGIN_ARG_INFO_EX(string_startswith, 0, 0, 2)
86:67:	THRAK_BYVAL_ARG_INFO(str)
86:68:	THRAK_BYVAL_ARG_INFO(prefix)
86:69:	THRAK_BYVAL_ARG_INFO(case_insensitive)
86:70:THRAK_END_ARG_INFO ;
86:71:
86:72:/* string_seteos() */
86:73:THRAK_BEGIN_ARG_INFO_EX(string_seteos, 0, 0, 2)
86:74:	THRAK_BYREF_ARG_INFO(str)
86:75:	THRAK_BYVAL_ARG_INFO(suffix)
86:76:	THRAK_BYVAL_ARG_INFO(case_insensitive)
86:77:	THRAK_BYVAL_ARG_INFO(return_value)
86:78:THRAK_END_ARG_INFO ;
86:79:
86:80:/* string_setbos() */
86:81:THRAK_BEGIN_ARG_INFO_EX(string_setbos, 0, 0, 2)
86:82:	THRAK_BYREF_ARG_INFO(str)
86:83:	THRAK_BYVAL_ARG_INFO(prefix)
86:84:	THRAK_BYVAL_ARG_INFO(case_insensitive)
86:85:	THRAK_BYVAL_ARG_INFO(return_value)
86:86:THRAK_END_ARG_INFO ;
86:87:
86:88:end_language_block ( C ) ;
86:89:
86:90:# endif		/* __STRING_STATICS_H__  */87:1:/************************************************************************************************************
87:2:
87:3:    NAME
87:4:	thrak.c
87:5:	
87:6:    DESCRIPTION
87:7:	Helper functions for writing PHP extensions.
87:8:	
87:9:    AUTHOR
87:10:	Christian Vigh, 11/2014.
87:11:	
87:12:    HISTORY 
87:13:	tbd
87:14:
87:15: ************************************************************************************************************/
87:16:# include 	"thrak.h"
87:17:# include 	<zend_alloc.h>
87:18:
87:19:
87:20:/*-----------------------------------------------------------------------------------------------------------
87:21:
87:22:	Global variables.
87:23:	
87:24: *-----------------------------------------------------------------------------------------------------------*/
87:25:int 		thrak_machine_endianness ;
87:26:
87:27:
87:28:/*===========================================================================================================
87:29:
87:30:    NAME
87:31:	thrak_initialize - initializes the thrak utility package.
87:32:		
87:33: *===========================================================================================================*/
87:34:void   thrak_initialize ( THRAK_INIT_FUNC_ARGS )
87:35:   {
87:36:	thrak_machine_endianness 	=  thrak_get_machine_endianness ( ) ;
87:37:    }
87:38:
87:39:    
87:40:/*===========================================================================================================
87:41:
87:42:    NAME
87:43:	thrak_shutdown - Shutdows the thrak utility package.
87:44:		
87:45: *===========================================================================================================*/
87:46:void 	thrak_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
87:47:   {
87:48:    }
87:49:    
87:50:
87:51:/*===========================================================================================================
87:52:
87:53:    NAME
87:54:	thrak_get_machine_endianness - Returns the machine endianness.
87:55:	
87:56:    PROTOTYPE 
87:57:	endianness 	=  thrak_machine_endianness ( ) ;
87:58:	
87:59:    DESCRIPTION
87:60:	Returns the endianness of the current machine.
87:61:	
87:62:    RETURNS
87:63:	One of the constants LITTLE_ENDIAN or BIG_ENDIAN.
87:64:	
87:65: *===========================================================================================================*/
87:66:int 	thrak_get_machine_endianness ( )
87:67:   {
87:68:	unsigned char 		bytes [ sizeof ( unsigned int ) ] ;
87:69:	unsigned int		test_value 		=  0 ;
87:70:	unsigned int 		current_value 		=  0x00 ;
87:71:	int 			i ;
87:72:	
87:73:
87:74:	for  ( i = 0 ; i  <  sizeof ( unsigned int ) ; i ++ )
87:75:	   {
87:76:		current_value ++ ;
87:77:		test_value 	=  ( test_value  <<  8 )  |  current_value ;
87:78:	    }
87:79:	    
87:80:	* ( ( unsigned int * ) bytes ) 	=  test_value ;
87:81:	
87:82:	if  ( bytes [0]  ==  current_value )
87:83:		return ( LITTLE_ENDIAN ) ;
87:84:	else
87:85:		return ( BIG_ENDIAN ) ;
87:86:    }88:1:# Microsoft Developer Studio Project File - Name="extname" - Package Owner=<4>
88:2:# Microsoft Developer Studio Generated Build File, Format Version 6.00
88:3:# ** DO NOT EDIT **
88:4:
88:5:# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
88:6:
88:7:CFG=extname - Win32 Release_TS
88:8:!MESSAGE This is not a valid makefile. To build this project using NMAKE,
88:9:!MESSAGE use the Export Makefile command and run
88:10:!MESSAGE 
88:11:!MESSAGE NMAKE /f "extname.mak".
88:12:!MESSAGE 
88:13:!MESSAGE You can specify a configuration when running NMAKE
88:14:!MESSAGE by defining the macro CFG on the command line. For example:
88:15:!MESSAGE 
88:16:!MESSAGE NMAKE /f "extname.mak" CFG="extname - Win32 Release_TS"
88:17:!MESSAGE 
88:18:!MESSAGE Possible choices for configuration are:
88:19:!MESSAGE 
88:20:!MESSAGE "extname - Win32 Release_TS" (based on "Win32 (x86) Dynamic-Link Library")
88:21:!MESSAGE "extname - Win32 Debug_TS" (based on "Win32 (x86) Dynamic-Link Library")
88:22:!MESSAGE 
88:23:
88:24:# Begin Project
88:25:# PROP AllowPerConfigDependencies 0
88:26:# PROP Scc_ProjName ""
88:27:# PROP Scc_LocalPath ""
88:28:CPP=cl.exe
88:29:MTL=midl.exe
88:30:RSC=rc.exe
88:31:
88:32:!IF  "$(CFG)" == "extname - Win32 Release_TS"
88:33:
88:34:# PROP BASE Use_MFC 0
88:35:# PROP BASE Use_Debug_Libraries 0
88:36:# PROP BASE Output_Dir "Release_TS"
88:37:# PROP BASE Intermediate_Dir "Release_TS"
88:38:# PROP BASE Ignore_Export_Lib 0
88:39:# PROP BASE Target_Dir ""
88:40:# PROP Use_MFC 0
88:41:# PROP Use_Debug_Libraries 0
88:42:# PROP Output_Dir "Release_TS"
88:43:# PROP Intermediate_Dir "Release_TS"
88:44:# PROP Ignore_Export_Lib 0
88:45:# PROP Target_Dir ""
88:46:# ADD BASE CPP /nologo /MT /W3 /GX /O2 /I "..\.." /I "..\..\..\Zend" /I "..\..\..\bindlib_w32" /I "..\..\..\TSRM" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "COMPILE_DL_EXTNAME" /D ZTS=1 /YX /FD /c
88:47:# ADD CPP /nologo /MD /W3 /GX /O2 /I "..\.." /I "..\..\main" /I "..\..\Zend" /I "..\..\..\bindlib_w32" /I "..\..\TSRM" /D ZEND_DEBUG=0 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "EXTNAME_EXPORTS" /D "COMPILE_DL_EXTNAME" /D ZTS=1 /D "ZEND_WIN32" /D "PHP_WIN32" /D HAVE_EXTNAME=1 /D "LIBZEND_EXPORTS" /FR /YX /FD /c
88:48:# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
88:49:# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
88:50:# ADD BASE RSC /l 0x406 /d "NDEBUG"
88:51:# ADD RSC /l 0x406 /d "NDEBUG"
88:52:BSC32=bscmake.exe
88:53:# ADD BASE BSC32 /nologo
88:54:# ADD BSC32 /nologo
88:55:LINK32=link.exe
88:56:# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib php5ts.lib /nologo /dll /machine:I386
88:57:# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib php5ts.lib /nologo /dll /machine:I386 /out:"..\..\Release_TS/php_extname.dll" /libpath:"..\..\Release_TS" /libpath:"..\..\Release_TS_Inline"
88:58:
88:59:!ELSEIF  "$(CFG)" == "extname - Win32 Debug_TS"
88:60:
88:61:# PROP BASE Use_MFC 0
88:62:# PROP BASE Use_Debug_Libraries 0
88:63:# PROP BASE Output_Dir "Debug_TS"
88:64:# PROP BASE Intermediate_Dir "Debug_TS"
88:65:# PROP BASE Ignore_Export_Lib 0
88:66:# PROP BASE Target_Dir ""
88:67:# PROP Use_MFC 0
88:68:# PROP Use_Debug_Libraries 0
88:69:# PROP Output_Dir "Debug_TS"
88:70:# PROP Intermediate_Dir "Debug_TS"
88:71:# PROP Ignore_Export_Lib 0
88:72:# PROP Target_Dir ""
88:73:# ADD BASE CPP /nologo /MT /W3 /GX /O2 /I "..\.." /I "..\..\Zend" /I "..\..\..\bindlib_w32" /I "..\..\TSRM" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "COMPILE_DL_EXTNAME" /D ZTS=1 /YX /FD /c
88:74:# ADD CPP /nologo /MDd /W3 /GX /O2 /I "..\.." /I "..\..\main" /I "..\..\Zend" /I "..\..\..\bindlib_w32" /I "..\..\TSRM" /D ZEND_DEBUG=1 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "EXTNAME_EXPORTS" /D "COMPILE_DL_EXTNAME" /D ZTS=1 /D "ZEND_WIN32" /D "PHP_WIN32" /D HAVE_EXTNAME=1 /D "LIBZEND_EXPORTS" /YX /FD /c
88:75:# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
88:76:# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
88:77:# ADD BASE RSC /l 0x406 /d "NDEBUG"
88:78:# ADD RSC /l 0x406 /d "NDEBUG"
88:79:BSC32=bscmake.exe
88:80:# ADD BASE BSC32 /nologo
88:81:# ADD BSC32 /nologo
88:82:LINK32=link.exe
88:83:# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib php5ts.lib /nologo /dll /machine:I386
88:84:# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib php5ts_debug.lib /nologo /dll /machine:I386 /out:"..\..\Debug_TS/php_extname.dll" /libpath:"..\..\Debug_TS"
88:85:
88:86:!ENDIF 
88:87:
88:88:# Begin Target
88:89:
88:90:# Name "extname - Win32 Release_TS"
88:91:# Name "extname - Win32 Debug_TS"
88:92:# Begin Group "Source Files"
88:93:
88:94:# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
88:95:# Begin Source File
88:96:
88:97:SOURCE=.\extname.c
88:98:# End Source File
88:99:# End Group
88:100:# Begin Group "Header Files"
88:101:
88:102:# PROP Default_Filter "h;hpp;hxx;hm;inl"
88:103:# Begin Source File
88:104:
88:105:SOURCE=.\php_extname.h
88:106:# End Source File
88:107:# End Group
88:108:# Begin Group "Resource Files"
88:109:
88:110:# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
88:111:# End Group
88:112:# End Target
88:113:# End Project
88:114:89:1:/************************************************************************************************************
89:2:
89:3:    NAME
89:4:	thrak.h
89:5:	
89:6:    DESCRIPTION
89:7:	General header file for the thrak API for developing PHP extensions.
89:8:	
89:9:    AUTHOR
89:10:	Christian Vigh, 11/2014.
89:11:	
89:12:    HISTORY 
89:13:	tbd
89:14:
89:15: ************************************************************************************************************/
89:16:
89:17:# ifndef __THRAK_H__
89:18:# 	define 	__THRAK_H__
89:19:
89:20:/*-----------------------------------------------------------------------------------------------------------
89:21:
89:22:	Compiler/platform specific macros.
89:23:	
89:24: *-----------------------------------------------------------------------------------------------------------*/
89:25:
89:26:# if 	__cplusplus
89:27:#	define 		language(C) 		extern ##C
89:28:# 	define 		language_block(C)	language (C)  {
89:29:# 	define 		end_language_block(C) 	}
89:30:# else
89:31:# 	define 		language(C)
89:32:# 	define 		language_block(C)
89:33:#	define 		end_language_block(C)
89:34:# endif		
89:35:
89:36:language_block(C) ;
89:37:
89:38: 
89:39:/*-----------------------------------------------------------------------------------------------------------
89:40:
89:41:	PHP includes.
89:42:	
89:43: *-----------------------------------------------------------------------------------------------------------*/
89:44:# ifdef 	PHP_WIN32
89:45:# 	pragma 		warning ( disable : 4267 )
89:46:# endif
89:47:
89:48:# include 	<php.h>
89:49:# include 	<php_ini.h>
89:50:# include 	<ext/standard/info.h>
89:51:
89:52:# ifdef 	PHP_WIN32
89:53:# 	pragma 		warning ( default : 4267 )
89:54:# endif
89:55:
89:56:# ifdef ZTS
89:57:#	include 	"TSRM.h"
89:58:# endif
89:59:
89:60:
89:61:/*-----------------------------------------------------------------------------------------------------------
89:62:
89:63:	Machine-related constants & types.
89:64:	
89:65: *-----------------------------------------------------------------------------------------------------------*/
89:66:# define 	BIG_ENDIAN 					1
89:67:# define 	LITTLE_ENDIAN 					0
89:68:# define 	MACHINE_ENDIAN					2
89:69:
89:70:# if  ( ULONG_MAX == 0xFFFFFFFF )
89:71:# 	if  ( ULLONG_MAX  >  ULONG_MAX )
89:72:#		define 	LONG_SIZE 		4
89:73:		typedef short int 		int16 ;
89:74:		typedef int 			int32 ;
89:75:		typedef long long int 		int64 ;
89:76:		typedef unsigned short int 	uint16 ;
89:77:		typedef unsigned int 		uint32 ;
89:78:		typedef unsigned long long int 	uint64 ;
89:79:# 	else
89:80:# 		error Cannot compile on platforms that do not support 64-bit integers.
89:81:#	endif
89:82:# else
89:83:#		define 	LONG_SIZE 		8
89:84:		typedef short int 		int16 ;
89:85:		typedef int 			int32 ;
89:86:		typedef long int 		int64 ;
89:87:		typedef unsigned short int 	uint16 ;
89:88:		typedef unsigned int 		uint32 ;
89:89:		typedef unsigned long int 	uint64 ;
89:90:# endif
89:91:
89:92:/* May need some adjustments */ 
89:93:typedef 	unsigned short int 				MACHINE_WORD ;
89:94:typedef 	unsigned int 					MACHINE_DWORD ;
89:95:typedef 	unsigned long long int				MACHINE_QWORD ;
89:96:
89:97:
89:98:/*-----------------------------------------------------------------------------------------------------------
89:99:
89:100:	Platform-dependent defines.
89:101:	
89:102: *-----------------------------------------------------------------------------------------------------------*/
89:103:# define 	THRAK_API					ZEND_API
89:104:
89:105:# define 	PLATFORM_WINDOWS 				0 
89:106:# define 	PLATFORM_APPLE 					0 
89:107:# define 	PLATFORM_POSIX 					0 
89:108:
89:109:
89:110:# if 	defined ( _WIN32 ) ||  defined (  _WIN64 ) 
89:111:
89:112:#  	undef  	PLATFORM_WINDOWS 
89:113:#  	define 	PLATFORM_WINDOWS 				1 
89:114:#  	define 	WIN32_LEAN_AND_MEAN 
89:115:
89:116:# 	include 	<windows.h> 
89:117:
89:118:# elif 	defined ( __APPLE__ ) 
89:119:
89:120:#  	undef  	PLATFORM_APPLE 
89:121:#  	define 	PLATFORM_APPLE 					1 
89:122:
89:123:# 	include 	<string.h> 
89:124:#	include 	<stdint.h> 
89:125:
89:126:# else 
89:127:
89:128:#  	undef  	PLATFORM_POSIX 
89:129:#  	define 	PLATFORM_POSIX 					1 
89:130:
89:131:#  	include 	<unistd.h> 
89:132:#  	include 	<string.h> 
89:133:#	include 	<stdint.h> 
89:134:
89:135:# endif 
89:136:
89:137:/*-----------------------------------------------------------------------------------------------------------
89:138:
89:139:	Misc macros & constants for Zend.
89:140:	
89:141: *-----------------------------------------------------------------------------------------------------------*/
89:142: 
89:143:/* Shortcuts for returning a string in a PHP_FUNCTION, either by duplicating it or using the existing pointer */
89:144:# define 	RETURN_STRING_CONSTANT(str)			RETURN_STRING ( str, 1 )	
89:145:# define 	RETURN_STRING_VARIABLE(str)			RETURN_STRING ( str, 0 )
89:146:
89:147:/* Substitute in argument list with a string and its size */
89:148:# define 	STRLC(strconst)					( strconst ), ( sizeof ( strconst ) )	
89:149:# define 	STRLC0(strconst)				( strconst ), ( sizeof ( strconst ) -  1 )	
89:150:# define 	STRLZ(strp)					( strp ), strlen ( strp )
89:151:# define 	STRLZ0(strp)					( strp ), ( strlen ( strp ) - 1 )
89:152:
89:153:
89:154:/*-----------------------------------------------------------------------------------------------------------
89:155:
89:156:	Shortcuts for shared module definition.
89:157:	
89:158: *-----------------------------------------------------------------------------------------------------------*/
89:159:# define 	THRAK_MODULE_ENTRY(name)			name##_module_entry
89:160:# define	THRAK_GET_MODULE(name) 				ZEND_GET_MODULE ( name )
89:161:# define 	THRAK_GET_MODULE_FUNCTION(name)			ZEND_DLEXPORT zend_module_entry *	get_module ( void )
89:162:# define 	THRAK_RETURN_MODULE_ENTRY(name)			return ( & THRAK_MODULE_ENTRY ( name ) )
89:163:
89:164:
89:165:/*-----------------------------------------------------------------------------------------------------------
89:166:
89:167:	Shortcuts for function table definition.
89:168:	
89:169: *-----------------------------------------------------------------------------------------------------------*/
89:170:# define 	THRAK_FUNCTION_TABLE(name)			const zend_function_entry 	name##_functions []
89:171:# define 	THRAK_BEGIN_FUNCTION_TABLE(name)		THRAK_FUNCTION_TABLE ( name ) = {
89:172:# define 	THRAK_FE(name)					PHP_FE ( name, name##_arginfo )
89:173:# define 	THRAK_FEA(name,arginfo)				PHP_FE ( name, arginfo )
89:174:# define        THRAK_FE_ALIAS(alias,name)			ZEND_FENTRY ( alias, ZEND_FN(name), name##arg_info, 0)
89:175:# define 	THRAK_FE_END					PHP_FE_END
89:176:# define 	THRAK_END_FUNCTION_TABLE			THRAK_FE_END } ;
89:177:
89:178:
89:179:/*-----------------------------------------------------------------------------------------------------------
89:180:
89:181:	Shortcuts for module definition.
89:182:	
89:183: *-----------------------------------------------------------------------------------------------------------*/
89:184:# define 	THRAK_MODULE(name)				zend_module_entry 	name##_module_entry
89:185:# define 	THRAK_BEGIN_MODULE(name)			THRAK_MODULE ( name ) = {
89:186:# define 	THRAK_END_MODULE				} ;
89:187:
89:188: 
89:189:/*-----------------------------------------------------------------------------------------------------------
89:190:
89:191:	Shortcuts for function argument definition.
89:192:	
89:193: *-----------------------------------------------------------------------------------------------------------*/
89:194:# define 	THRAK_ARG_DECLARE(name)				const zend_arg_info 	name##_arginfo []			
89:195:# define 	THRAK_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)	\
89:196:								static THRAK_ARG_DECLARE ( name ) = {					\
89:197:									{ NULL, 0, NULL, required_num_args, 0, return_reference, 0, 0 },
89:198:
89:199:# define 	THRAK_BEGIN_ARG_INFO(name,_unused,retval,required)				\
89:200:								THRAK_BEGIN_ARG_INFO_EX ( name, _unused, retval, required )
89:201:# define 	THRAK_ARG_INFO(byref,name)			ZEND_ARG_INFO ( byref, name )
89:202:# define 	THRAK_BYREF_ARG_INFO(name)			THRAK_ARG_INFO ( 1, name )
89:203:# define 	THRAK_BYVAL_ARG_INFO(name)			THRAK_ARG_INFO ( 0, name )
89:204:
89:205:# define 	THRAK_ARG_VARIADIC_INFO(byref,name)		ZEND_ARG_VARIADIC_INFO ( byref, name )
89:206:# define 	THRAK_BYREF_ARG_VARIADIC_INFO(name)		THRAK_ARG_VARIADIC_INFO ( 1, name )
89:207:# define 	THRAK_BYVAL_ARG_VARIADIC_INFO(name)		THRAK_ARG_VARIADIC_INFO ( 0, name )
89:208:
89:209:# define 	THRAK_END_ARG_INFO				ZEND_END_ARG_INFO() ;
89:210:
89:211:
89:212:/*-----------------------------------------------------------------------------------------------------------
89:213:
89:214:	Macros to declare/access module globals. The same macros should work well in both thread-safe and non thread-safe
89:215:	environments.
89:216:	
89:217: *-----------------------------------------------------------------------------------------------------------*/
89:218:# ifdef 	ZTS
89:219:#	define  THRAK_GLOBALS_NAME(name)			name##_globals_id
89:220:# 	define  THRAK_GLOBALS_TYPE(name)			zend_##name##_globals	
89:221:#	define 	THRAK_GLOBAL(name,v) 				TSRMG ( THRAK_GLOBALS_NAME ( name ), THRAK_GLOBALS_TYPE ( name ) *, v )
89:222:# 	define 	THRAK_INIT_GLOBALS(name,callback)		ZEND_INIT_MODULE_GLOBALS ( name, callback, NULL )
89:223:# 	define  THRAK_FETCH_GLOBALS()				TSRMLS_FETCH ( )
89:224:# else
89:225:#	define 	THRAK_GLOBALS_NAME(name)			name
89:226:# 	define  THRAK_GLOBALS_TYPE(name)			zend_##name##_globals	
89:227:#	define 	THRAK_GLOBAL(name,v) 				( name. ( v ) )
89:228:# 	define 	THRAK_INIT_GLOBALS(name,callback)		callback ( & name )
89:229:# 	define  THRAK_FETCH_GLOBALS()
89:230:# endif
89:231:
89:232:
89:233:/*-----------------------------------------------------------------------------------------------------------
89:234:
89:235:	Definitions for submodules.
89:236:	
89:237: *-----------------------------------------------------------------------------------------------------------*/
89:238:# define 	THRAK_INIT_FUNC_ARGS 				INIT_FUNC_ARGS
89:239:# define 	THRAK_SHUWTDOWN_FUNC_ARGS 			SHUTDOWN_FUNC_ARGS
89:240:# define 	THRAK_INFO_FUNC_ARGS 				ZEND_MODULE_INFO_FUNC_ARGS
89:241:
89:242:# define 	THRAK_INIT_FUNC_ARGS_PASSTHRU 			INIT_FUNC_ARGS_PASSTHRU
89:243:# define 	THRAK_SHUTDOWN_FUNC_ARGS_PASSTHRU 		SHUTDOWN_FUNC_ARGS_PASSTHRU
89:244:# define 	THRAK_INFO_FUNC_ARGS_PASSTHRU 			ZEND_MODULE_INFO_FUNC_ARGS_PASSTHRU
89:245: 
89:246:
89:247:/*-----------------------------------------------------------------------------------------------------------
89:248:
89:249:	Ini settings helpers.
89:250:	
89:251: *-----------------------------------------------------------------------------------------------------------*/
89:252:/* Defines a byte quantity, such as "1Mb", "256Kb", etc. */
89:253:typedef struct thrak_byte_quantity
89:254:   {
89:255:	long 		bytes ;					/* Actual byte count 		*/
89:256:	long		quantity ;				/* Specified quantity 		*/
89:257:	long 		multiplier ;				/* Multiplier quantity 		*/
89:258:	char *		multiplier_string ;			/* Specified multiplier 	*/
89:259:    }  thrak_byte_quantity ;
89:260:
89:261:/* Defines a byte quantity, such as "1Mb", "256Kb", etc. or a percentage */
89:262:typedef struct thrak_memory_quantity
89:263:   {
89:264:	char 		type ; 					/* 0 = quantity, 1 = percentage */
89:265:	union							
89:266:	   {
89:267:		double 			percentage ;
89:268:		thrak_byte_quantity	quantity ;
89:269:	    } ;						/* Quantity or percentage       */
89:270:    }  thrak_memory_quantity ;
89:271:
89:272:    
89:273:/*-----------------------------------------------------------------------------------------------------------
89:274:
89:275:	External functions.
89:276:	
89:277: *-----------------------------------------------------------------------------------------------------------*/
89:278:
89:279:/* thrak.c */
89:280:extern void 			thrak_initialize			( THRAK_INIT_FUNC_ARGS ) ;
89:281:extern void 			thrak_shutdown				( THRAK_SHUTDOWN_FUNC_ARGS ) ;
89:282:
89:283:extern int 			thrak_get_machine_endianness 		( ) ;
89:284: 
89:285:/* string_helpers.c */
89:286:extern  THRAK_API zend_bool	thrak_atoi 				( char *  			input_value, 
89:287:									  char **  			output_position,
89:288:									  int64 * 			output_value,
89:289:									  int 				is_escape ) ;
89:290:extern  THRAK_API char *	thrak_strichr 				( const char *			p,
89:291:									  int 				ch ) ;
89:292:
89:293:extern  THRAK_API char *	thrak_trim  				( char *  			p, 
89:294:									  char *  			output ) ;
89:295:extern  THRAK_API char * 	thrak_ltrim  				( char *  			p, 
89:296:									  char *  			output ) ;
89:297:extern  THRAK_API char * 	thrak_rtrim  				( char *  			p, 
89:298:									  char *  			output ) ;
89:299:									  
89:300:/* array_helpers.c */
89:301:extern  THRAK_API char * 	thrak_array_to_char 			( zval * 			array,
89:302:									  char *** 			argv,
89:303:									  int *				argc,
89:304:									  int ** 			argl ) ;
89:305:extern  THRAK_API  zend_bool	thrak_free_array_to_char 		( char * 			data ) ;
89:306:
89:307:/* ini_helpers.c */
89:308:extern  THRAK_API char * 	thrak_ini_get_string 			( char *  			setting, 
89:309:									  char *  			default_value ) ;
89:310:extern  THRAK_API int 		thrak_ini_parse_byte_quantity 		( char *  			value, 
89:311:									  thrak_byte_quantity *  	quantity ) ;
89:312:extern  THRAK_API int 		thrak_ini_parse_percentage 		( char *  			value, 
89:313:									  double *  			percentage ) ;
89:314:extern  THRAK_API int 		thrak_ini_parse_memory_quantity 	( char *  			value, 
89:315:									  thrak_memory_quantity *  	quantity ) ;
89:316:
89:317:/* memory_helpers.c */
89:318:extern  THRAK_API int  		thrak_memory_check_constraint 		( long  			memory_requested, 
89:319:									  thrak_memory_quantity *  	constraint
89:320:									  TSRMLS_DC ) ;
89:321:								  
89:322:/*-----------------------------------------------------------------------------------------------------------
89:323:
89:324:	External variables.
89:325:	
89:326: *-----------------------------------------------------------------------------------------------------------*/
89:327:extern int 		thrak_machine_endianness ;
89:328:
89:329:end_language_block ( C ) ;
89:330:
89:331:# endif 	/* __THRAK_H__ */
89:332:90:1:/************************************************************************************************************
90:2:
90:3:    NAME
90:4:	timer.c
90:5:	
90:6:    DESCRIPTION
90:7:	timer-related operations.
90:8:	
90:9:    AUTHOR
90:10:	Christian Vigh, 11/2014.
90:11:	
90:12:    HISTORY 
90:13:	tbd
90:14:
90:15: ************************************************************************************************************/
90:16:# include 	"php_vroom.h"
90:17:# include 	"timer.h"
90:18:
90:19:
90:20:/*-----------------------------------------------------------------------------------------------------------
90:21:
90:22:	Platform-dependent variables.
90:23:	
90:24: *-----------------------------------------------------------------------------------------------------------*/
90:25:# if 	PLATFORM_APPLE
90:26:static mach_timebase_info_data_t 		__timebase_info; 
90:27:
90:28:static zend_always_inline void  absolutetime_to_nanoseconds ( uint64_t  mach_time, uint64_t *  clock ) 
90:29:   { 
90:30:	*clock 	= ( mach_time * _timebase_info. numer ) / _timebase_info. denom ; 
90:31:    }
90:32:# endif    
90:33:
90:34:
90:35:/*-----------------------------------------------------------------------------------------------------------
90:36:
90:37:	Global variables.
90:38:	
90:39: *-----------------------------------------------------------------------------------------------------------*/
90:40:static tick_t 			__timer_ticks_per_second    		=  0 ; 		/* Timer frequency 		*/
90:41:static double 			__timer_frequency  			=  0 ; 		/* 1 / timer frequency		*/
90:42:static double 			__last_timer_clock 			=  0 ;		/* Last clock value		*/
90:43:
90:44:
90:45:/*===========================================================================================================
90:46:
90:47:    NAME
90:48:	timer_initialize - Initializes the time functions.
90:49:		
90:50: *===========================================================================================================*/
90:51:void 	timer_initialize ( THRAK_INIT_FUNC_ARGS )
90:52:   {
90:53:	int  			status 		=  1 ;
90:54:# if 	PLATFORM_WINDOWS 
90:55:	tick_t 			unused ;
90:56:# elif  PLATFORM_POSIX 
90:57:	struct timespec 	ts 		=  { .tv_sec = 0, .tv_nsec = 0 } ; 	
90:58:# endif
90:59:	
90:60:	/* Register time resolution constants */
90:61:	REGISTER_LONG_CONSTANT ( "TIMER_RESOLUTION_SECOND"		, TIMER_RESOLUTION_SECOND	, CONST_CS | CONST_PERSISTENT ) ;
90:62:	REGISTER_LONG_CONSTANT ( "TIMER_RESOLUTION_MILLISECOND"		, TIMER_RESOLUTION_MILLISECOND	, CONST_CS | CONST_PERSISTENT ) ;
90:63:	REGISTER_LONG_CONSTANT ( "TIMER_RESOLUTION_MICROSECOND"		, TIMER_RESOLUTION_MICROSECOND	, CONST_CS | CONST_PERSISTENT ) ;
90:64:	REGISTER_LONG_CONSTANT ( "TIMER_RESOLUTION_NANOSECOND"		, TIMER_RESOLUTION_NANOSECOND	, CONST_CS | CONST_PERSISTENT ) ;
90:65:
90:66:	/* Get the timer frequency */
90:67:# if 	PLATFORM_WINDOWS 
90:68:        if ( ! QueryPerformanceFrequency ( ( LARGE_INTEGER * ) & __timer_ticks_per_second ) || 
90:69:             ! QueryPerformanceCounter   ( ( LARGE_INTEGER * ) & unused ) ) 
90:70:		status 	=  0 ;
90:71:# elif 	PLATFORM_APPLE 
90:72:        if (  mach_timebase_info ( & __timebase_info ) ) 
90:73:		status 	=  0 ;
90:74:	else
90:75:		__timer_ticks_per_second 	=  1000000000ULL ; 
90:76:# elif 	PLATFORM_POSIX 
90:77:        if ( clock_gettime ( CLOCK_MONOTONIC, & ts ) ) 
90:78:		status 	=  0 ;
90:79:	else
90:80:		__timer_ticks_per_second 	=  1000000000ULL ; 
90:81:# endif 
90:82:
90:83:	if  ( ! status )
90:84:		php_error_docref ( NULL TSRMLS_CC, E_ERROR, "Unable to determine high-resolution clock frequency." ) ;
90:85:		
90:86:	__timer_frequency 	=  1.0 / ( double ) __timer_ticks_per_second ;
90:87:	
90:88:	/* Register time frequency constants */
90:89:	REGISTER_DOUBLE_CONSTANT ( "TIMER_TICKS_PER_SECOND"	, ( double ) __timer_ticks_per_second	, CONST_CS | CONST_PERSISTENT ) ;
90:90:	REGISTER_DOUBLE_CONSTANT ( "TIMER_FREQUENCY"		, __timer_frequency			, CONST_CS | CONST_PERSISTENT ) ;
90:91:    }
90:92:
90:93:    
90:94:/*===========================================================================================================
90:95:
90:96:    NAME
90:97:	timer_shutdown - Shutdowns the time functions submodule.
90:98:		
90:99: *===========================================================================================================*/
90:100:void 	timer_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
90:101:   {
90:102:    }
90:103:    
90:104:    
90:105:/*===========================================================================================================
90:106:
90:107:    NAME
90:108:	timer_clock - Returns the current value of the system high-resolution clock.
90:109:	
90:110:    PROTOTYPE
90:111:	$value 	=  timer_clock ( [ $resolution = TIMER_RESOLUTION_NATIVE ]) ;
90:112:	
90:113:    DESCRIPTION 
90:114:	Returns the current value of the high resolution clock.
90:115:	
90:116:    PARAMETERS
90:117:	$resolution (integer) -
90:118:		Indicates the resolution of the returned value :
90:119:		- TIMER_RESOLUTION_NATIVE :
90:120:			The natural number of ticks will be returned?
90:121:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
90:122:			The returned value will be converted to the specified unit.
90:123:			
90:124:    RETURNS
90:125:	The current value of the high resolution clock.
90:126:		
90:127: *===========================================================================================================*/
90:128:THRAK_API double 	internal_timer_clock  ( void )
90:129:   {
90:130:	double 		ticks ;
90:131:	
90:132:	
90:133:# if 	PLATFORM_WINDOWS 
90:134:        tick_t 		current_clock ; 
90:135:
90:136:        QueryPerformanceCounter ( ( LARGE_INTEGER * ) & current_clock ) ; 
90:137:	
90:138:        ticks 	=  ( double ) current_clock ; 
90:139:	
90:140:# elif  PLATFORM_APPLE 
90:141:        tick_t 		current_clock	=  0 ; 
90:142:
90:143:        absolutetime_to_nanoseconds ( mach_absolute_time ( ), & current_clock ) ; 
90:144:
90:145:        ticks 	=  ( double ) current_clock ;
90:146:	
90:147:# elif 	PLATFORM_POSIX 
90:148:        struct timespec 	ts 	= { .tv_sec = 0, .tv_nsec = 0 } ; 
90:149:
90:150:        clock_gettime ( CLOCK_MONOTONIC, & ts ) ; 
90:151:
90:152:        ticks	=  ( double ) ( ts.tv_sec * 1000000000ULL ) + ts. tv_nsec ) ; 
90:153:# endif 
90:154:
90:155:	__last_timer_clock 	=  ticks ;
90:156:	
90:157:	return ( ticks ) ;
90:158:   }
90:159:    
90:160:    
90:161:PHP_FUNCTION ( timer_clock )
90:162:   {
90:163:	double 		ticks ;
90:164:	int 		resolution 		=  TIMER_RESOLUTION_NATIVE ;
90:165:	
90:166:	/* Parse arguments */
90:167:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "|l", & resolution )  ==  FAILURE )
90:168:		return;
90:169:	
90:170:	// Get the number of elapsed ticks
90:171:	ticks 	=  internal_timer_clock ( ) ;
90:172:	
90:173:	// Convert to the requested resolution
90:174:	ticks 	=  internal_timer_ticks_to ( ticks, resolution ) ;
90:175:	
90:176:	RETURN_DOUBLE ( ticks ) ;
90:177:    }
90:178:    
90:179:    
90:180:/*===========================================================================================================
90:181:
90:182:    NAME
90:183:	timer_ticks_to - Converts clock ticks to the specified resolution.
90:184:	
90:185:    PROTOTYPE
90:186:	$value 	=  timer_ticks_to ( $ticks [,  $resolution = TIMER_RESOLUTION_NATIVE ]) ;
90:187:	$value 	=  timer_ticks_to_seconds ( $ticks ) ;
90:188:	$value 	=  timer_ticks_to_milliseconds ( $ticks ) ;
90:189:	$value 	=  timer_ticks_to_microseconds ( $ticks ) ;
90:190:	$value 	=  timer_ticks_to_nanoseconds ( $ticks ) ;
90:191:	
90:192:    DESCRIPTION 
90:193:	Converts timer ticks to the specified resolution.
90:194:	
90:195:    PARAMETERS
90:196:	$ticks (double) -
90:197:		Tick count to be converted.
90:198:		
90:199:	$resolution (integer) -
90:200:		Indicates the resolution of the returned value :
90:201:		- TIMER_RESOLUTION_NATIVE :
90:202:			The natural number of ticks will be returned.
90:203:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
90:204:			The supplied tick count value will be converted to the specified unit.
90:205:			
90:206:    RETURNS
90:207:	The number of ticks supplied, converted to the specified resolution.
90:208:		
90:209: *===========================================================================================================*/
90:210:THRAK_API double  internal_timer_ticks_to  ( double  ticks, int  resolution ) 
90:211:   {
90:212:	switch  ( resolution )
90:213:	   {
90:214:		case 	TIMER_RESOLUTION_SECOND :
90:215:			ticks 	=  ( ticks * __timer_frequency ) ;
90:216:			break ;
90:217:		
90:218:		case 	TIMER_RESOLUTION_MILLISECOND :
90:219:			ticks 	=  ( ticks * ( 1000.0 ) ) * __timer_frequency ;
90:220:			break ;
90:221:		
90:222:		case 	TIMER_RESOLUTION_MICROSECOND :
90:223:			ticks 	=  ( ticks * ( 1000.0 * 1000.0 ) ) * __timer_frequency ;
90:224:			break ;
90:225:		
90:226:		case 	TIMER_RESOLUTION_NANOSECOND :
90:227:			ticks 	=  ( ticks * ( 1000.0 * 1000.0 * 1000.0 ) ) * __timer_frequency ;
90:228:			break ;
90:229:		
90:230:		case 	TIMER_RESOLUTION_NATIVE :
90:231:		default :
90:232:			break ;
90:233:	    }
90:234:	    
90:235:	return ( ticks ) ;
90:236:    }
90:237:    
90:238:PHP_FUNCTION ( timer_ticks_to )
90:239:   {
90:240:	double 		ticks ;
90:241:	int 		resolution 		=  TIMER_RESOLUTION_NATIVE ;
90:242:	
90:243:	/* Parse arguments */
90:244:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "d|l", & ticks, & resolution )  ==  FAILURE )
90:245:		return;
90:246:		
90:247:	ticks 	=  internal_timer_ticks_to ( ticks, resolution ) ;
90:248:	
90:249:	RETURN_DOUBLE ( ticks ) ;
90:250:    }     
90:251:     
90:252:PHP_FUNCTION ( timer_ticks_to_seconds )
90:253:   {
90:254:	double 		ticks ;
90:255:	
90:256:	/* Parse arguments */
90:257:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "d", & ticks )  ==  FAILURE )
90:258:		return;
90:259:		
90:260:	ticks 	=  internal_timer_ticks_to ( ticks, TIMER_RESOLUTION_SECOND ) ;
90:261:	
90:262:	RETURN_DOUBLE ( ticks ) ;
90:263:    }     
90:264: 
90:265:      
90:266:PHP_FUNCTION ( timer_ticks_to_milliseconds )
90:267:   {
90:268:	double 		ticks ;
90:269:	
90:270:	/* Parse arguments */
90:271:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "d", & ticks )  ==  FAILURE )
90:272:		return;
90:273:		
90:274:	ticks 	=  internal_timer_ticks_to ( ticks, TIMER_RESOLUTION_MILLISECOND ) ;
90:275:	
90:276:	RETURN_DOUBLE ( ticks ) ;
90:277:    }     
90:278:      
90:279:PHP_FUNCTION ( timer_ticks_to_microseconds )
90:280:   {
90:281:	double 		ticks ;
90:282:	
90:283:	/* Parse arguments */
90:284:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "d", & ticks )  ==  FAILURE )
90:285:		return;
90:286:		
90:287:	ticks 	=  internal_timer_ticks_to ( ticks, TIMER_RESOLUTION_MICROSECOND ) ;
90:288:	
90:289:	RETURN_DOUBLE ( ticks ) ;
90:290:    }     
90:291:      
90:292:PHP_FUNCTION ( timer_ticks_to_nanoseconds )
90:293:   {
90:294:	double 		ticks ;
90:295:	
90:296:	/* Parse arguments */
90:297:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "d", & ticks )  ==  FAILURE )
90:298:		return;
90:299:		
90:300:	ticks 	=  internal_timer_ticks_to ( ticks, TIMER_RESOLUTION_NANOSECOND ) ;
90:301:	
90:302:	RETURN_DOUBLE ( ticks ) ;
90:303:    }     
90:304: 
90:305: 
90:306: 
90:307:/*===========================================================================================================
90:308:
90:309:    NAME
90:310:	timer_diff - Computes delta between two timer values.
90:311:	
90:312:    PROTOTYPE
90:313:	$value 	=  timer_diff ( $current, $previous [, $resolution = TIMER_RESOLUTION_NATIVE ]) ;
90:314:	
90:315:    DESCRIPTION 
90:316:	Computes the differences between two timer clock values and returns the result, converted to the
90:317:	specified resolution.
90:318:	
90:319:    PARAMETERS
90:320:	$current (double) -
90:321:		Current timer value.
90:322:		
90:323:	$previous (double) -
90:324:		Previous timer value.
90:325:		
90:326:	$resolution (integer) -
90:327:		Indicates the resolution of the returned value :
90:328:		- TIMER_RESOLUTION_NATIVE :
90:329:			The natural number of ticks will be returned?
90:330:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
90:331:			The returned value will be converted to the specified unit.
90:332:			
90:333:    RETURNS
90:334:	The delta between the current and previous timer values, converted to the specified resolution.
90:335:		
90:336: *===========================================================================================================*/
90:337:PHP_FUNCTION ( timer_diff )
90:338:   {
90:339:	double 		ticks, current, previous ;
90:340:	int 		resolution 		=  TIMER_RESOLUTION_NATIVE ;
90:341:	
90:342:	/* Parse arguments */
90:343:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "dd|l", & current, & previous, & resolution )  ==  FAILURE )
90:344:		return;
90:345:	
90:346:	// Get the number of elapsed ticks
90:347:	ticks 	=  current - previous ;
90:348:	
90:349:	// Convert to the requested resolution
90:350:	ticks 	=  internal_timer_ticks_to ( ticks, resolution ) ;
90:351:	
90:352:	RETURN_DOUBLE ( ticks ) ;
90:353:    }
90:354:
90:355:    
90:356:/*===========================================================================================================
90:357:
90:358:    NAME
90:359:	timer_clock_delta - Returns the number of ticks elapsed since the last call to timer_clock().
90:360:	
90:361:    PROTOTYPE
90:362:	$value 	=  timer_clock_delta ( [ $resolution = TIMER_RESOLUTION_NATIVE ]) ;
90:363:	
90:364:    DESCRIPTION 
90:365:	Returns the delta between the call of the last timer_clock() or timer_clock_delta() functions.
90:366:	If none of these functions was called, returns the current clock value.
90:367:	
90:368:    PARAMETERS
90:369:	$resolution (integer) -
90:370:		Indicates the resolution of the returned value :
90:371:		- TIMER_RESOLUTION_NATIVE :
90:372:			The natural number of ticks will be returned?
90:373:		- TIMER_RESOLUTION_SECOND, MILLISECOND, MICROSECOND, NANO_SECOND :
90:374:			The returned value will be converted to the specified unit.
90:375:			
90:376:    RETURNS
90:377:	The delta between the current clock and the value of the clock during the last call to 
90:378:	timer_clock_delta() or timer_clock().
90:379:		
90:380: *===========================================================================================================*/
90:381:PHP_FUNCTION ( timer_clock_delta )
90:382:   {
90:383:	double 		old_ticks		=  __last_timer_clock, 
90:384:			current_ticks,
90:385:			ticks ;
90:386:	int 		resolution 		=  TIMER_RESOLUTION_NATIVE ;
90:387:	
90:388:	/* Parse arguments */
90:389:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "|l", & resolution )  ==  FAILURE )
90:390:		return;
90:391:	
90:392:	// Get the number of elapsed ticks
90:393:	current_ticks 	=  internal_timer_clock ( ) ;
90:394:	
90:395:	// Convert to the requested resolution
90:396:	ticks 	=  internal_timer_ticks_to ( current_ticks - old_ticks, resolution ) ;
90:397:	
90:398:	RETURN_DOUBLE ( ticks ) ;
90:399:    }
90:400:    
90:401:    
90:402:91:1:/************************************************************************************************************
91:2:
91:3:    NAME
91:4:	timer.h
91:5:	
91:6:    DESCRIPTION
91:7:	Definitions for timer-related functions.
91:8:	
91:9:    AUTHOR
91:10:	Christian Vigh, 11/2014.
91:11:	
91:12:    HISTORY 
91:13:	tbd
91:14:
91:15: ************************************************************************************************************/
91:16:# ifndef 	__TIMER_H__
91:17:# 	define	__TIMER_H__
91:18:
91:19:
91:20:# if  ( ! PLATFORM_WINDOWS  &&  ! PLATFORM_APPLE  &&  ! PLATFORM_POSIX )
91:21:#	error 	Unable to determine current platform.
91:22:# endif
91:23:
91:24:language_block ( C ) ;
91:25:
91:26:/*-----------------------------------------------------------------------------------------------------------
91:27:
91:28:	Platform-dependent includes.
91:29:	
91:30: *-----------------------------------------------------------------------------------------------------------*/
91:31:# if	PLATFORM_WINDOWS
91:32:# elif 	PLATFORM_APPLE
91:33:# 	include 	<mach/mach_time.h> 
91:34:# else 
91:35:#  	include 	<time.h> 
91:36:# endif
91:37:
91:38: 
91:39:/*-----------------------------------------------------------------------------------------------------------
91:40:
91:41:	Macros & constants.
91:42:	
91:43: *-----------------------------------------------------------------------------------------------------------*/
91:44:# define 	TIMER_RESOLUTION_NATIVE				0
91:45:# define 	TIMER_RESOLUTION_SECOND 			1
91:46:# define 	TIMER_RESOLUTION_MILLISECOND			2
91:47:# define 	TIMER_RESOLUTION_MICROSECOND 			3
91:48:# define 	TIMER_RESOLUTION_NANOSECOND 			4
91:49:
91:50:
91:51:/*-----------------------------------------------------------------------------------------------------------
91:52:
91:53:	Types.
91:54:	
91:55: *-----------------------------------------------------------------------------------------------------------*/
91:56:# if 	PLATFORM_WINDOWS
91:57:typedef 	unsigned __int64 				tick_t ; 
91:58:# else 
91:59:typedef 	uint64_t         				tick_t ;
91:60:# endif 
91:61:
91:62:/*-----------------------------------------------------------------------------------------------------------
91:63:
91:64:	External functions.
91:65:	
91:66: *-----------------------------------------------------------------------------------------------------------*/
91:67:extern				PHP_FUNCTION  ( timer_clock ) ;
91:68:extern THRAK_API double 	internal_timer_clock 				( void ) ;
91:69:
91:70:extern 				PHP_FUNCTION ( timer_clock_delta ) ;
91:71:extern THRAK_API double 	internal_timer_clock_delta 			( double  	ticks ) ;
91:72:
91:73:extern 				PHP_FUNCTION ( timer_diff ) ;
91:74:extern THRAK_API double 	internal_timer_diff 				( double  	current,
91:75:										  double 	previous ) ;
91:76:
91:77:extern 				PHP_FUNCTION  ( timer_ticks_to ) ;
91:78:extern 				PHP_FUNCTION  ( timer_ticks_to_seconds ) ;
91:79:extern 				PHP_FUNCTION  ( timer_ticks_to_milliseconds ) ;
91:80:extern 				PHP_FUNCTION  ( timer_ticks_to_microseconds ) ;
91:81:extern 				PHP_FUNCTION  ( timer_ticks_to_nanoseconds ) ;
91:82:extern THRAK_API double 	internal_timer_ticks_to				( double 	ticks,
91:83:										  int 		resolution ) ;
91:84:
91:85:
91:86:/* initialization/shutdown */
91:87:extern void 			timer_initialize			( THRAK_INIT_FUNC_ARGS ) ;
91:88:extern void 			timer_shutdown				( THRAK_SHUTDOWN_FUNC_ARGS ) ;
91:89:
91:90:end_language_block ( C ) ;
91:91:
91:92:# endif		/* __TIMER_H__  */92:1:/************************************************************************************************************
92:2:
92:3:    NAME
92:4:	timer_statics.h
92:5:	
92:6:    DESCRIPTION
92:7:	Variables that must be initialized only once.
92:8:	
92:9:    AUTHOR
92:10:	Christian Vigh, 11/2014.
92:11:	
92:12:    HISTORY 
92:13:	tbd
92:14:
92:15: ************************************************************************************************************/
92:16:# ifndef 	__TIMER_STATICS_H__
92:17:# 	define	__TIMER_STATICS_H__
92:18:
92:19:language_block ( C ) ;
92:20:
92:21:/*-----------------------------------------------------------------------------------------------------------
92:22:
92:23:	Function arguments type information for data.c.
92:24:	
92:25: *-----------------------------------------------------------------------------------------------------------*/
92:26:/* timer_clock() */
92:27:THRAK_BEGIN_ARG_INFO_EX(timer_clock, 0, 0, 0)
92:28:	THRAK_BYVAL_ARG_INFO(resolution)
92:29:THRAK_END_ARG_INFO ;
92:30:
92:31:/* timer_clock_delta() */
92:32:THRAK_BEGIN_ARG_INFO_EX(timer_clock_delta, 0, 0, 0)
92:33:	THRAK_BYVAL_ARG_INFO(resolution)
92:34:THRAK_END_ARG_INFO ;
92:35:
92:36:/* timer_ticks_to() */
92:37:THRAK_BEGIN_ARG_INFO_EX(timer_ticks_to, 0, 0, 1)
92:38:	THRAK_BYVAL_ARG_INFO(ticks)
92:39:	THRAK_BYVAL_ARG_INFO(resolution)
92:40:THRAK_END_ARG_INFO ;
92:41:
92:42:/* timer_ticks_to_seconds() */
92:43:THRAK_BEGIN_ARG_INFO_EX(timer_ticks_to_seconds, 0, 0, 1)
92:44:	THRAK_BYVAL_ARG_INFO(ticks)
92:45:THRAK_END_ARG_INFO ;
92:46:
92:47:/* timer_ticks_to_milliseconds() */
92:48:THRAK_BEGIN_ARG_INFO_EX(timer_ticks_to_milliseconds, 0, 0, 1)
92:49:	THRAK_BYVAL_ARG_INFO(ticks)
92:50:THRAK_END_ARG_INFO ;
92:51:
92:52:/* timer_ticks_to_microseconds() */
92:53:THRAK_BEGIN_ARG_INFO_EX(timer_ticks_to_microseconds, 0, 0, 1)
92:54:	THRAK_BYVAL_ARG_INFO(ticks)
92:55:THRAK_END_ARG_INFO ;
92:56:
92:57:/* timer_ticks_to_nanoseconds() */
92:58:THRAK_BEGIN_ARG_INFO_EX(timer_ticks_to_nanoseconds, 0, 0, 1)
92:59:	THRAK_BYVAL_ARG_INFO(ticks)
92:60:THRAK_END_ARG_INFO ;
92:61:
92:62:/* timer_diff() */
92:63:THRAK_BEGIN_ARG_INFO_EX(timer_diff, 0, 0, 2)
92:64:	THRAK_BYVAL_ARG_INFO(current)
92:65:	THRAK_BYVAL_ARG_INFO(previous)
92:66:THRAK_END_ARG_INFO ;
92:67:
92:68:end_language_block ( C ) ;
92:69:
92:70:# endif		/* __TIMER_STATICS_H__  */93:1: /************************************************************************************************************
93:2:
93:3:    NAME
93:4:	vroom.c
93:5:	
93:6:    DESCRIPTION
93:7:	Vroom-specific functions.
93:8:	
93:9:    AUTHOR
93:10:	Christian Vigh, 11/2014.
93:11:	
93:12:    HISTORY 
93:13:	tbd
93:14:
93:15: ************************************************************************************************************/
93:16:# include 	"php_vroom.h"
93:17:
93:18:
93:19:/*-----------------------------------------------------------------------------------------------------------
93:20:
93:21:	Global variables.
93:22:	
93:23: *-----------------------------------------------------------------------------------------------------------*/
93:24:int 			vroom_endianness ;
93:25:
93:26:
93:27:/*===========================================================================================================
93:28:
93:29:    NAME
93:30:	vroom_initialize 
93:31:	
93:32:    DESCRIPTION
93:33:	Register the constants published by the vroom extension.
93:34:	
93:35: *===========================================================================================================*/
93:36:static zend_bool auto_create_environment ( const char *  name, uint  name_len TSRMLS_DC )
93:37:   {
93:38:	char ** 		p ;
93:39:	char *			var,
93:40:	     *			equal_sign ;
93:41:	int 			position, length ;
93:42:	zval *			env_array ;
93:43:	
93:44:
93:45:	// Initialize a PHP array
93:46:	MAKE_STD_ZVAL ( env_array ) ;
93:47:	array_init ( env_array ) ;
93:48:	
93:49:	// Loop through environment variables
93:50:	for  ( p = environ ; * p  !=  NULL ; p ++ )
93:51:	   {
93:52:		// Search the length of variable name and value, from left & right side of the equal sign
93:53:		var 		=  * p ++ ;
93:54:		equal_sign 	=  strchr ( var, '=' ) ;
93:55:		length 		=  ( int ) strlen ( var ) ;
93:56:		
93:57:		// Paranoia : there should always be an equal sign
93:58:		if  ( equal_sign  ==  NULL )
93:59:			equal_sign 	=  var + length ;
93:60:		
93:61:		// Position of the variable value
93:62:		position 	=  ( int ) ( equal_sign - var ) + 1  ;
93:63:		
93:64:		// Add this entry to the environment array
93:65:		add_assoc_string_ex ( env_array, var, position, var + position, 1 ) ;
93:66:	    }
93:67:	    
93:68:	// All done, this variable is now a superglobal
93:69:	ZEND_SET_GLOBAL_VAR_WITH_LENGTH ( "ENVIRONMENT", sizeof ( "ENVIRONMENT" ), env_array, 2, 1 ) ;
93:70:	return ( 0 ) ;
93:71:    }
93:72:
93:73:    
93:74:void 	vroom_initialize ( THRAK_INIT_FUNC_ARGS )
93:75:   {
93:76:	/* Some information about internal (compiled) data sizes */
93:77:	REGISTER_LONG_CONSTANT ( "SIZEOF_CHAR"		, sizeof ( char      )	, CONST_CS | CONST_PERSISTENT ) ;
93:78:	REGISTER_LONG_CONSTANT ( "SIZEOF_DOUBLE"	, sizeof ( double    )	, CONST_CS | CONST_PERSISTENT ) ;
93:79:	REGISTER_LONG_CONSTANT ( "SIZEOF_FLOAT"		, sizeof ( float     )	, CONST_CS | CONST_PERSISTENT ) ;
93:80:	REGISTER_LONG_CONSTANT ( "SIZEOF_INT"		, sizeof ( int       )	, CONST_CS | CONST_PERSISTENT ) ;
93:81:	REGISTER_LONG_CONSTANT ( "SIZEOF_LONG"		, sizeof ( long      )	, CONST_CS | CONST_PERSISTENT ) ;
93:82:	REGISTER_LONG_CONSTANT ( "SIZEOF_LONG_LONG"	, sizeof ( long long )	, CONST_CS | CONST_PERSISTENT ) ;
93:83:	REGISTER_LONG_CONSTANT ( "SIZEOF_PTR"		, sizeof ( void *    )	, CONST_CS | CONST_PERSISTENT ) ;
93:84:	REGISTER_LONG_CONSTANT ( "SIZEOF_SHORT"		, sizeof ( short     )	, CONST_CS | CONST_PERSISTENT ) ;
93:85:	
93:86:	/* Machine endianness */
93:87:	REGISTER_LONG_CONSTANT ( "LITTLE_ENDIAN"	, LITTLE_ENDIAN			, CONST_CS | CONST_PERSISTENT ) ;
93:88:	REGISTER_LONG_CONSTANT ( "BIG_ENDIAN"		, BIG_ENDIAN			, CONST_CS | CONST_PERSISTENT ) ;
93:89:	REGISTER_LONG_CONSTANT ( "ENDIANNESS"		, thrak_machine_endianness	, CONST_CS | CONST_PERSISTENT ) ;
93:90:	
93:91:	/*** 
93:92:		Provide an associative array for environment variables.
93:93:		Note that the variable cannot be declared in the symbol table during module initialization.
93:94:		It must be done after ; this is why an auto_create callback is supplied. This callback will be called at
93:95:		appropriate time (after module initialization), when all the symbols are available.
93:96:	 ***/
93:97:	zend_register_auto_global ( "ENVIRONMENT", sizeof ( "ENVIRONMENT" ) - 1, 0, auto_create_environment TSRMLS_CC ) ;
93:98:    }
93:99:    
93:100:    
93:101:/*===========================================================================================================
93:102:
93:103:    NAME
93:104:	vroom_shutdown
93:105:	
93:106:    DESCRIPTION
93:107:	Sub-extension shutdown function.
93:108:	
93:109: *===========================================================================================================*/
93:110:void 	vroom_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
93:111:   {
93:112:    }94:1: /************************************************************************************************************
94:2:
94:3:    NAME
94:4:	zval.c
94:5:	
94:6:    DESCRIPTION
94:7:	Functions dealing with zvals.
94:8:	
94:9:    AUTHOR
94:10:	Christian Vigh, 10/2014.
94:11:	
94:12:    HISTORY 
94:13:	tbd
94:14:
94:15: ************************************************************************************************************/
94:16:# include 	"php_vroom.h"
94:17:# include	"zval.h"
94:18:
94:19:
94:20:/*===========================================================================================================
94:21:
94:22:    NAME
94:23:	zval_initialize - Initializes the zval functions.
94:24:		
94:25: *===========================================================================================================*/
94:26:void 	zval_initialize ( THRAK_INIT_FUNC_ARGS )
94:27:   {
94:28:	/* Register constants for ZVAL types */
94:29:	REGISTER_LONG_CONSTANT ( "ZVAL_UNKNOWN"		, -1			, CONST_CS | CONST_PERSISTENT ) ;
94:30:	REGISTER_LONG_CONSTANT ( "ZVAL_NULL"		, IS_NULL		, CONST_CS | CONST_PERSISTENT ) ;
94:31:	REGISTER_LONG_CONSTANT ( "ZVAL_BOOL"		, IS_BOOL		, CONST_CS | CONST_PERSISTENT ) ;
94:32:	REGISTER_LONG_CONSTANT ( "ZVAL_LONG"		, IS_LONG		, CONST_CS | CONST_PERSISTENT ) ;
94:33:	REGISTER_LONG_CONSTANT ( "ZVAL_DOUBLE"		, IS_DOUBLE		, CONST_CS | CONST_PERSISTENT ) ;
94:34:	REGISTER_LONG_CONSTANT ( "ZVAL_STRING"		, IS_STRING		, CONST_CS | CONST_PERSISTENT ) ;
94:35:	REGISTER_LONG_CONSTANT ( "ZVAL_RESOURCE"	, IS_RESOURCE		, CONST_CS | CONST_PERSISTENT ) ;
94:36:	REGISTER_LONG_CONSTANT ( "ZVAL_ARRAY"		, IS_ARRAY		, CONST_CS | CONST_PERSISTENT ) ;
94:37:	REGISTER_LONG_CONSTANT ( "ZVAL_OBJECT"		, IS_OBJECT		, CONST_CS | CONST_PERSISTENT ) ;
94:38:    }
94:39:
94:40:
94:41:/*===========================================================================================================
94:42:
94:43:    NAME
94:44:	zval_shutdown
94:45:	
94:46:    DESCRIPTION
94:47:	Sub-extension shutdown function.
94:48:	
94:49: *===========================================================================================================*/
94:50:void 	zval_shutdown ( THRAK_SHUTDOWN_FUNC_ARGS )
94:51:   {
94:52:    }
94:53:
94:54:    
94:55:/*===========================================================================================================
94:56:
94:57:    NAME
94:58:	zval_refcount - gets a zval reference count
94:59:	
94:60:    PROTOTYPE 
94:61:	int  	zval_refcount ( &$variable ) ;
94:62:	
94:63:    DESCRIPTION
94:64:	Returns the number of references to the specified zval.
94:65:	
94:66:    PARAMETERS
94:67:	$variable (mixed) -
94:68:		Variable whose reference count is to be returned.
94:69:
94:70:    RETURN VALUE
94:71:	The reference count of the underlying zval.
94:72:	
94:73: *===========================================================================================================*/
94:74:PHP_FUNCTION ( zval_refcount )
94:75:   {
94:76:	zval *		value ;
94:77:	
94:78:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:79:		return ;
94:80:		
94:81:	RETURN_LONG ( Z_REFCOUNT_P ( value ) - 1 ) ;
94:82:    }
94:83:
94:84:
94:85:/*===========================================================================================================
94:86:
94:87:    NAME
94:88:	zval_dump - get zval contents as an array 
94:89:	
94:90:    PROTOTYPE 
94:91:	$array 	= zval_dump ( &$variable ) ;
94:92:	
94:93:    DESCRIPTION
94:94:	Returns an associative array containing the fields of a zval structure.
94:95:	
94:96:    PARAMETERS
94:97:	$variable (mixed) -
94:98:		Variable to be dumped.
94:99:
94:100:    RETURN VALUE
94:101:	An associative array containing the following keys :
94:102:	- 'type' :
94:103:		zval value type.
94:104:	- 'type-string' :
94:105:		zval value type, as a string.
94:106:	- 'refcount' :
94:107:		Reference count. See notes below.
94:108:	- 'isref' :
94:109:		A boolean indicating whether this zval is a reference or not. See notes below.
94:110:	- 'value' :
94:111:		The underlying zval value.
94:112:	- 'value-length' :
94:113:		For string values, contain the string length.
94:114:	
94:115:    NOTES
94:116:	Since this function accepts a reference to a zval, its reference count field will be automatically
94:117:	incremented and the zval will be set to be a reference.
94:118:	We try to simulate how the original value was before calling this function :
94:119:	- Reference count is decremented by one
94:120:	- The "isref" field of the zval is set to zero if the decremented reference count is one.
94:121:	This may not reflect the actual situation but it tends to be more accurate than debug_zval_dump().
94:122:	
94:123: *===========================================================================================================*/
94:124:PHP_FUNCTION ( zval_dump )
94:125:   {
94:126:	zval *		value ;				/* Input value 								*/
94:127:	zval *		value_dump_array ;		/* Returned array 							*/
94:128:	zval *		dumped_value ;			/* Holds a copy of the value - returned in the 'value' array key 	*/
94:129:	int 		type,				/* Value type constant 							*/
94:130:			refcount, 			/* Reference count 							*/
94:131:			isref ;				/* 1 if value is a reference 						*/
94:132:	char *		type_string ;			/* Value type, as a string 						*/
94:133:	
94:134:	
94:135:	/* Parse parameters */
94:136:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:137:		return ;
94:138:	
94:139:	/* Initialize the returned array */
94:140:	MAKE_STD_ZVAL ( value_dump_array ) ;
94:141:	array_init ( value_dump_array ) ;
94:142:
94:143:	// Get type value and type string
94:144:	switch  ( Z_TYPE_P ( value ) )
94:145:	   {
94:146:		case	IS_NULL 	:  type = IS_NULL     ; type_string 	= "ZVAL_NULL"     ; break ;
94:147:		case 	IS_BOOL 	:  type = IS_BOOL     ; type_string 	= "ZVAL_BOOL"     ; break ;
94:148:		case 	IS_LONG 	:  type = IS_LONG     ; type_string 	= "ZVAL_LONG"     ; break ;
94:149:		case 	IS_DOUBLE 	:  type = IS_DOUBLE   ; type_string 	= "ZVAL_DOUBLE"   ; break ;
94:150:		case 	IS_STRING 	:  type = IS_STRING   ; type_string 	= "ZVAL_STRING"   ; break ;
94:151:		case 	IS_RESOURCE 	:  type = IS_RESOURCE ; type_string 	= "ZVAL_RESOURCE" ; break ;
94:152:		case 	IS_ARRAY 	:  type = IS_ARRAY    ; type_string 	= "ZVAL_ARRAY"    ; break ;
94:153:		case 	IS_OBJECT	:  type = IS_OBJECT   ; type_string 	= "ZVAL_OBJECT"   ; break ;
94:154:		default 		:  type = -1          ; type_string 	= "ZVAL_UNKNOWN"  ; break ;
94:155:	    }
94:156:	    
94:157:# ifdef 	PHP_WIN32
94:158:# 	pragma 		warning ( disable : 4267 )
94:159:# endif
94:160:	refcount 	=  Z_REFCOUNT_P ( value ) - 1 ;
94:161:	isref 		=  ( refcount  >  1 ) ;
94:162:	
94:163:	/* Set standard fields */
94:164:	add_assoc_string ( value_dump_array, "type-string"	, type_string, 1 ) ;
94:165:	add_assoc_long   ( value_dump_array, "type"		, type ) ;
94:166:	add_assoc_long   ( value_dump_array, "refcount" 	, refcount ) ;
94:167:	add_assoc_bool   ( value_dump_array, "isref" 		, isref ) ;
94:168:
94:169:	/* Make a copy of the underlying value */
94:170:	MAKE_STD_ZVAL ( dumped_value ) ;
94:171:	INIT_PZVAL_COPY ( dumped_value, value ) ;
94:172:	add_assoc_zval ( value_dump_array, "value", dumped_value ) ;
94:173:	
94:174:	/* Add value length if type is string */
94:175:	if  ( type  ==  IS_STRING )
94:176:		add_assoc_long ( value_dump_array, "value-length", Z_STRLEN_P ( value ) ) ;
94:177:	
94:178:# ifdef 	PHP_WIN32
94:179:# 	pragma 		warning ( default : 4267 )
94:180:# endif
94:181:	
94:182:	RETURN_ZVAL ( value_dump_array, 0, 0 ) ;
94:183:    }   
94:184:
94:185:    
94:186:/*===========================================================================================================
94:187:
94:188:    NAME
94:189:	zval_decref, zval_incref, zval_setref - Manipulate a zval reference count.
94:190:	
94:191:    PROTOTYPE 
94:192:	int  	zval_decref ( &$variable ) ;
94:193:	int  	zval_incref ( &$variable ) ;
94:194:	int  	zval_setref ( &$variable, $refcount ) ;
94:195:	
94:196:    DESCRIPTION
94:197:	Manipulates a zval reference count :
94:198:	- zval_decref decrements the reference count
94:199:	- zval_incref increments it
94:200:	- and zval_setref assigns a new reference count
94:201:	
94:202:    PARAMETERS
94:203:	$variable (mixed) -
94:204:		Variable whose reference count is to be returned.
94:205:		
94:206:	$refcount (int) -
94:207:		New reference count.
94:208:
94:209:    RETURN VALUE
94:210:	All functions return the previous reference count.
94:211:	
94:212: *===========================================================================================================*/
94:213:PHP_FUNCTION ( zval_decref )
94:214:   {
94:215:	zval *		value ;
94:216:	int 		old_refcount ;
94:217:	
94:218:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:219:		return ;
94:220:	
94:221:	// old_count is current_count - 1 because calling this function with a reference to the original variable increased by 1 its refcount
94:222:	old_refcount 	=  Z_REFCOUNT_P ( value ) - 1 ;		
94:223:	
94:224:	if  ( old_refcount  >  1 )
94:225:		Z_DELREF_P ( value ) ;
94:226:	
94:227:	RETURN_LONG ( old_refcount ) ;
94:228:    }    
94:229: 
94:230: 
94:231:PHP_FUNCTION ( zval_incref )
94:232:   {
94:233:	zval *		value ;
94:234:	int 		old_refcount ;
94:235:	
94:236:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:237:		return ;
94:238:		
94:239:	// old_count is current_count - 1 because calling this function with a reference to the original variable increased by 1 its refcount
94:240:	old_refcount 	=  Z_REFCOUNT_P ( value ) - 1 ;
94:241:	Z_ADDREF_P ( value ) ;
94:242:	
94:243:	RETURN_LONG ( old_refcount ) ;
94:244:    }    
94:245:
94:246:    
94:247: PHP_FUNCTION ( zval_setref )
94:248:   {
94:249:	zval *		value ;
94:250:	int 		new_refcount ;
94:251:	int 		old_refcount ;
94:252:	
94:253:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zl", &value, &new_refcount )  ==  FAILURE )
94:254:		return ;
94:255:		
94:256:	// old_count is current_count - 1 because calling this function with a reference to the original variable increased by 1 its refcount
94:257:	old_refcount 	=  Z_REFCOUNT_P ( value ) - 1 ;
94:258:	
94:259:	// new_refcount + 1 because the reference count of the supplied variable will be decreased upon function exit
94:260:	Z_SET_REFCOUNT_P ( value, new_refcount + 1 ) ;
94:261:	
94:262:	RETURN_LONG ( old_refcount ) ;
94:263:    }    
94:264: 
94:265:
94:266:/*===========================================================================================================
94:267:
94:268:    NAME
94:269:	zval_isref - checks if zval is a reference
94:270:	
94:271:    PROTOTYPE 
94:272:	bool  	zval_isref ( $variable ) ;
94:273:	
94:274:    DESCRIPTION
94:275:	Returns a boolean indicating whether the specified variable is a reference or not.
94:276:	
94:277:    PARAMETERS
94:278:	$variable (mixed) -
94:279:		Variable whose type is to be retrieved.
94:280:
94:281:     RETURN VALUE
94:282:	True if the specified variable is a reference, false otherwise.
94:283:	
94:284: *===========================================================================================================*/
94:285:PHP_FUNCTION ( zval_isref )
94:286:   {
94:287:	zval *		value ;
94:288:	
94:289:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:290:		return ;
94:291:
94:292:	// Since the argument of this function is a reference, the variable's reference count will be incremented by 1
94:293:	// Thus, a variable which is not a reference will have its reference count set to 2 ; we need to adjust by -1 
94:294:	// to take into account the extra reference implied by calling this function.
94:295:	RETURN_BOOL ( Z_REFCOUNT_P ( value )  >  2 ) ;
94:296:    }     
94:297:
94:298:    
94:299:/*===========================================================================================================
94:300:
94:301:    NAME
94:302:	zval_swap - Swaps two zvals.
94:303:	
94:304:    PROTOTYPE 
94:305:	zval_swap ( $value1, $value2 ) ;
94:306:	
94:307:    DESCRIPTION
94:308:	Swaps the contents of two zvals.
94:309:	
94:310:    PARAMETERS
94:311:	$value1, $value2 (mixed) -
94:312:		Variables to be swapped.
94:313:	
94:314: *===========================================================================================================*/
94:315:PHP_FUNCTION ( zval_swap )
94:316:   {
94:317:	zval *		value1,  
94:318:	     *		value2 ;
94:319:	zval 		temp ;
94:320:	
94:321:	// Parse parameters
94:322:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "zz", &value1, &value2 )  ==  FAILURE )
94:323:		return ;
94:324:
94:325:	// Swap values
94:326:	memcpy ( & temp, value1, sizeof ( zval ) ) ;
94:327:	memcpy ( value1, value2, sizeof ( zval ) ) ;
94:328:	memcpy ( value2, & temp, sizeof ( zval ) ) ;
94:329:    }     
94:330:    
94:331:    
94:332:/*===========================================================================================================
94:333:
94:334:    NAME
94:335:	zval_type - gets a zval type
94:336:	
94:337:    PROTOTYPE 
94:338:	int  	zval_type ( $variable ) ;
94:339:	
94:340:    DESCRIPTION
94:341:	Returns the type of a zval.
94:342:	
94:343:    PARAMETERS
94:344:	$variable (mixed) -
94:345:		Variable whose type is to be retrieved.
94:346:
94:347:     RETURN VALUE
94:348:	One of the constants ZVAL_NULL, ZVAL_BOOL, ZVAL_LONG, ZVAL_STRING, ZVAL_RESOURCE, ZVAL_ARRAY, 
94:349:	ZVAL_OBJECT, or ZVAL_UNKNOWN if the zval type could not be determined.
94:350:	
94:351: *===========================================================================================================*/
94:352:PHP_FUNCTION ( zval_type )
94:353:   {
94:354:	zval *		value ;
94:355:	
94:356:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:357:		return ;
94:358:		
94:359:	RETURN_LONG ( Z_TYPE_P ( value ) ) ;
94:360:    }    
94:361: 
94:362: 
94:363:/*===========================================================================================================
94:364:
94:365:    NAME
94:366:	zval_type_constant - gets a zval type as a string
94:367:	
94:368:    PROTOTYPE 
94:369:	int  	zval_type ( $variable ) ;
94:370:	
94:371:    DESCRIPTION
94:372:	Returns the type of a zval as a string constant.
94:373:	
94:374:    PARAMETERS
94:375:	$variable (mixed) -
94:376:		Variable whose type is to be retrieved.
94:377:
94:378:     RETURN VALUE
94:379:	One of the constants "ZVAL_NULL", "ZVAL_BOOL", "ZVAL_LONG", "ZVAL_STRING", "ZVAL_RESOURCE", "ZVAL_ARRAY", 
94:380:	"ZVAL_OBJECT", or "ZVAL_UNKNOWN" if the zval type could not be determined.
94:381:	
94:382: *===========================================================================================================*/
94:383:PHP_FUNCTION ( zval_type_constant )
94:384:   {
94:385:	zval *		value ;
94:386:	long 		type ;
94:387:	
94:388:	if  ( zend_parse_parameters ( ZEND_NUM_ARGS() TSRMLS_CC, "z", &value )  ==  FAILURE )
94:389:		return ;
94:390:		
94:391:	type 	=  Z_TYPE_P ( value ) ;
94:392:	
94:393:# ifdef 	PHP_WIN32
94:394:# 	pragma 		warning ( disable : 4267 )
94:395:# endif
94:396:	switch (  type )
94:397:	   {
94:398:		case	IS_NULL 	:  RETURN_STRING_CONSTANT ( "ZVAL_NULL"     ) ;
94:399:		case 	IS_BOOL 	:  RETURN_STRING_CONSTANT ( "ZVAL_BOOL"     ) ;
94:400:		case 	IS_LONG 	:  RETURN_STRING_CONSTANT ( "ZVAL_LONG"     ) ;
94:401:		case 	IS_DOUBLE 	:  RETURN_STRING_CONSTANT ( "ZVAL_DOUBLE"   ) ;
94:402:		case 	IS_STRING 	:  RETURN_STRING_CONSTANT ( "ZVAL_STRING"   ) ;
94:403:		case 	IS_RESOURCE 	:  RETURN_STRING_CONSTANT ( "ZVAL_RESOURCE" ) ;
94:404:		case 	IS_ARRAY 	:  RETURN_STRING_CONSTANT ( "ZVAL_ARRAY"    ) ;
94:405:		case 	IS_OBJECT	:  RETURN_STRING_CONSTANT ( "ZVAL_OBJECT"   ) ;
94:406:		default 		:  RETURN_STRING_CONSTANT ( "ZVAL_UNKNOWN"  ) ;
94:407:	    }
94:408:# ifdef 	PHP_WIN32
94:409:# 	pragma 		warning ( default : 4267 )
94:410:# endif
94:411:    }    
94:412: 95:1:/************************************************************************************************************
95:2:
95:3:    NAME
95:4:	zval.h
95:5:	
95:6:    DESCRIPTION
95:7:	General header file for zval-related functions.
95:8:	
95:9:    AUTHOR
95:10:	Christian Vigh, 10/2014.
95:11:	
95:12:    HISTORY 
95:13:	tbd
95:14:
95:15: ************************************************************************************************************/
95:16:# ifndef __ZVAL_H__
95:17:# 	define 	__ZVAL_H__
95:18:
95:19:/*-----------------------------------------------------------------------------------------------------------
95:20:
95:21:	External functions.
95:22:	
95:23: *-----------------------------------------------------------------------------------------------------------*/
95:24:extern  PHP_FUNCTION		( zval_decref ) ;
95:25:extern  PHP_FUNCTION 		( zval_dump ) ;
95:26:extern  PHP_FUNCTION		( zval_incref ) ;
95:27:extern  PHP_FUNCTION  		( zval_isref ) ;
95:28:extern  PHP_FUNCTION		( zval_refcount ) ;
95:29:extern  PHP_FUNCTION		( zval_setref ) ;
95:30:extern  PHP_FUNCTION 		( zval_swap ) ;
95:31:extern  PHP_FUNCTION		( zval_type ) ;
95:32:extern  PHP_FUNCTION		( zval_type_constant ) ;
95:33:
95:34:extern void 		zval_initialize		( THRAK_INIT_FUNC_ARGS ) ;
95:35:extern void 		zval_shutdown		( THRAK_SHUTDOWN_FUNC_ARGS ) ;
95:36:
95:37:
95:38:# endif		/* __ZVAL_H__ */
95:39:96:1:/************************************************************************************************************
96:2:
96:3:    NAME
96:4:	zval_statics.h
96:5:	
96:6:    DESCRIPTION
96:7:	Variables that should be declared only once.
96:8:	
96:9:    AUTHOR
96:10:	Christian Vigh, 10/2014.
96:11:	
96:12:    HISTORY 
96:13:	tbd
96:14:
96:15: ************************************************************************************************************/
96:16:# ifndef __ZVAL_STATICS_H__
96:17:# 	define 	__ZVAL_STATICS_H__
96:18:
96:19:language_block ( C ) ;
96:20:
96:21:/*-----------------------------------------------------------------------------------------------------------
96:22:
96:23:	Function arguments type information.
96:24:	
96:25: *-----------------------------------------------------------------------------------------------------------*/
96:26:/* zval_decref() */
96:27:THRAK_BEGIN_ARG_INFO ( zval_decref, 0, 0, 1 )
96:28:	THRAK_BYREF_ARG_INFO ( variable )
96:29:THRAK_END_ARG_INFO ;
96:30:
96:31:/* zval_dump() */
96:32:THRAK_BEGIN_ARG_INFO ( zval_dump, 0, 0, 1 )
96:33:	THRAK_BYREF_ARG_INFO ( variable )
96:34:THRAK_END_ARG_INFO ;
96:35:
96:36:/* zval_incref() */
96:37:THRAK_BEGIN_ARG_INFO ( zval_incref, 0, 0, 1 )
96:38:	THRAK_BYREF_ARG_INFO ( variable )
96:39:THRAK_END_ARG_INFO ;
96:40:
96:41:/* zval_isref() */
96:42:THRAK_BEGIN_ARG_INFO ( zval_isref, 0, 0, 1 )
96:43:	THRAK_BYREF_ARG_INFO ( variable )
96:44:THRAK_END_ARG_INFO ;
96:45:
96:46:/* zval_refcount() */
96:47:THRAK_BEGIN_ARG_INFO ( zval_refcount, 0, 0, 1 )
96:48:	THRAK_BYREF_ARG_INFO ( variable )
96:49:THRAK_END_ARG_INFO ;
96:50:
96:51:/* zval_setref() */
96:52:THRAK_BEGIN_ARG_INFO ( zval_setref, 0, 0, 1 )
96:53:	THRAK_BYREF_ARG_INFO ( variable )
96:54:	THRAK_BYVAL_ARG_INFO ( refcount )
96:55:THRAK_END_ARG_INFO ;
96:56:
96:57:/* zval_swap() */
96:58:THRAK_BEGIN_ARG_INFO ( zval_swap, 0, 0, 2 )
96:59:	THRAK_BYREF_ARG_INFO ( value1 )
96:60:	THRAK_BYVAL_ARG_INFO ( value2 )
96:61:THRAK_END_ARG_INFO ;
96:62:
96:63:/* zval_type() */
96:64:THRAK_BEGIN_ARG_INFO ( zval_type, 0, 0, 1 )
96:65:	THRAK_BYVAL_ARG_INFO ( variable )
96:66:THRAK_END_ARG_INFO ;
96:67:
96:68:/* zval_type_constant() */
96:69:THRAK_BEGIN_ARG_INFO ( zval_type_constant, 0, 0, 1 )
96:70:	THRAK_BYVAL_ARG_INFO ( variable )
96:71:THRAK_END_ARG_INFO ;
96:72:
96:73:end_language_block ( C ) ;
96:74:
96:75:# endif		/* __ZVAL_STATICS_H__ */
96:76: